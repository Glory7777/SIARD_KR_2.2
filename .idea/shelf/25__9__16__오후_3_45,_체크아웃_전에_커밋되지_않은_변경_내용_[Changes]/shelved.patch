Index: JdbcMysql/src/main/java/ch/admin/bar/siard2/jdbc/MySqlDriver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.admin.bar.siard2.jdbc;\r\n\r\nimport ch.enterag.utils.jdbc.BaseDriver;\r\nimport ch.enterag.utils.logging.IndentLogger;\r\n\r\nimport java.sql.Connection;\r\nimport java.sql.Driver;\r\nimport java.sql.SQLException;\r\nimport java.util.Properties;\r\n\r\n\r\npublic class MySqlDriver extends BaseDriver implements Driver {\r\n    private static IndentLogger _il = IndentLogger.getIndentLogger(MySqlDriver.class.getName());\r\n\r\n\r\n    public static final String sMYSQL_SCHEME = \"mysql\";\r\n\r\n\r\n    public static final String sMYSQL_URL_PREFIX = \"jdbc:mysql:\";\r\n\r\n\r\n    public static String getUrl(String sDatabaseName, boolean bNoSsl) {\r\n        String sUrl = sDatabaseName;\r\n        if (!sUrl.startsWith(\"jdbc:mysql:\"))\r\n            sUrl = \"jdbc:mysql://\" + sDatabaseName;\r\n        if (bNoSsl)\r\n            sUrl = sUrl + \"?verifyServerCertificate=false&useSSL=false&requireSSL=false&allowPublicKeyRetrieval=true\";\r\n        return sUrl;\r\n    }\r\n\r\n    public static void register() {\r\n\r\n        try {\r\n            BaseDriver.register(new MySqlDriver(), \"com.mysql.cj.jdbc.Driver\", \"jdbc:mysql://localhost:3306/testschema\");\r\n        } catch (Exception e) {\r\n            throw new Error(e);\r\n        }\r\n\r\n    }\r\n\r\n    static {\r\n        register();\r\n    }\r\n\r\n\r\n    public Connection connect(String url, Properties info) throws SQLException {\r\n        _il.enter(new Object[]{url, info});\r\n\r\n        if (info == null) {\r\n            info = new Properties();\r\n        }\r\n\r\n        info.setProperty(\"useCursorFetch\", \"true\");\r\n        info.setProperty(\"defaultFetchSize\", \"1\");\r\n        info.setProperty(\"enableEscapeProcessing\", \"false\");\r\n        info.setProperty(\"processEscapeCodesForPrepStmts\", \"false\");\r\n        info.setProperty(\"sessionVariables\", \"sql_mode='ANSI'\"); // NO_BACKSLASH_ESCAPSES 설정 제거\r\n        Connection conn = super.connect(url, info);\r\n        if (conn != null)\r\n            conn = new MySqlConnection(conn);\r\n        _il.exit(conn);\r\n        return conn;\r\n    }\r\n\r\n\r\n    public boolean acceptsURL(String url) {\r\n        _il.enter(new Object[]{url});\r\n        boolean bAccepts = url.startsWith(\"jdbc:mysql:\");\r\n        _il.exit(Boolean.valueOf(bAccepts));\r\n        return bAccepts;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/JdbcMysql/src/main/java/ch/admin/bar/siard2/jdbc/MySqlDriver.java b/JdbcMysql/src/main/java/ch/admin/bar/siard2/jdbc/MySqlDriver.java
--- a/JdbcMysql/src/main/java/ch/admin/bar/siard2/jdbc/MySqlDriver.java	(revision d261e70452149cce970d307f8363780404af80cb)
+++ b/JdbcMysql/src/main/java/ch/admin/bar/siard2/jdbc/MySqlDriver.java	(date 1757983445609)
@@ -55,6 +55,8 @@
         info.setProperty("enableEscapeProcessing", "false");
         info.setProperty("processEscapeCodesForPrepStmts", "false");
         info.setProperty("sessionVariables", "sql_mode='ANSI'"); // NO_BACKSLASH_ESCAPSES 설정 제거
+        info.setProperty("zeroDateTimeBehavior", "convertToNull");
+
         Connection conn = super.connect(url, info);
         if (conn != null)
             conn = new MySqlConnection(conn);
Index: SiardApi/src/main/java/ch/admin/bar/siard2/api/primary/ValueImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.admin.bar.siard2.api.primary;\r\n\r\nimport ch.admin.bar.siard2.api.*;\r\nimport ch.admin.bar.siard2.api.generated.CategoryType;\r\nimport ch.enterag.utils.BU;\r\nimport ch.enterag.utils.DU;\r\nimport ch.enterag.utils.FU;\r\nimport ch.enterag.utils.database.SqlTypes;\r\nimport ch.enterag.utils.mime.MimeTypes;\r\nimport ch.enterag.utils.xml.XU;\r\n\r\nimport java.io.*;\r\nimport java.math.BigDecimal;\r\nimport java.math.BigInteger;\r\nimport java.net.URI;\r\nimport java.net.URL;\r\nimport java.nio.file.Files;\r\nimport java.sql.Date;\r\nimport java.sql.Time;\r\nimport java.sql.Timestamp;\r\nimport java.text.ParseException;\r\nimport java.util.*;\r\nimport javax.xml.datatype.Duration;\r\n\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.Node;\r\n\r\npublic abstract class ValueImpl implements Value {\r\n    private static final String _sSEQUENCE_PREFIX = \"seq\";\r\n    private static final DU _du = DU.getInstance(\"en\", \"yyyy-MM-dd HH:mm:ss.S\");\r\n    private static final String _sRECORD_PREFIX = \"record\";\r\n    private static final String _sEXTENSION_TEXT = \"txt\";\r\n    private static final String _sEXTENSION_XML = \"xml\";\r\n    private static final String _sEXTENSION_BIN = \"bin\";\r\n    private URI _uriTemporaryLobFolder = null;\r\n\r\n    public URI getTemporaryLobFolder() {\r\n        return this._uriTemporaryLobFolder;\r\n    }\r\n\r\n    private long _lRecord = -1L;\r\n\r\n\r\n    protected long getRecord() {\r\n        return this._lRecord;\r\n    }\r\n\r\n    private int _iIndex = -1;\r\n\r\n\r\n    protected int getIndex() {\r\n        return this._iIndex;\r\n    }\r\n\r\n    Element _elValue = null;\r\n\r\n\r\n    private Element getValueElement() throws IOException {\r\n        if (this._elValue == null) {\r\n            if (this instanceof Cell) {\r\n                this._elValue = RecordImpl.getDocument().createElementNS(\"http://www.bar.admin.ch/xmlns/siard/2/table.xsd\", getColumnTag(getIndex()));\r\n            } else {\r\n\r\n                ValueImpl viParent = (ValueImpl) ((Field) this).getParent();\r\n                int iCardinalityParent = viParent.getCardinality();\r\n                if (iCardinalityParent >= 0) {\r\n                    this._elValue = RecordImpl.getDocument().createElementNS(\"http://www.bar.admin.ch/xmlns/siard/2/table.xsd\", getElementTag(getIndex()));\r\n                } else {\r\n\r\n                    MetaType mtParent = viParent.getMetaType();\r\n                    CategoryType catParent = mtParent.getCategoryType();\r\n                    if (catParent == CategoryType.UDT)\r\n                        this._elValue = RecordImpl.getDocument().createElementNS(\"http://www.bar.admin.ch/xmlns/siard/2/table.xsd\", getAttributeTag(getIndex()));\r\n                }\r\n                viParent.getValueElement().appendChild(this._elValue);\r\n            }\r\n        }\r\n        return this._elValue;\r\n    }\r\n\r\n    private MetaValue _mv = null;\r\n\r\n\r\n    public MetaValue getMetaValue() {\r\n        return this._mv;\r\n    }\r\n\r\n\r\n    protected void extendArray(int iSize, int iCardinality) throws IOException {\r\n        for (int iField = 0; iField < iSize; iField++) {\r\n\r\n            String sTag = getElementTag(iField);\r\n            Field field = getFieldMap().get(sTag);\r\n            if (field == null) {\r\n\r\n                MetaField mfNull = getMetaField(iField);\r\n                getFieldMap().put(sTag, createField(iField, mfNull, null));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    protected abstract Field createField(int paramInt, MetaField paramMetaField, Element paramElement) throws IOException;\r\n\r\n\r\n    protected abstract String getInternalLobFolder() throws IOException;\r\n\r\n\r\n    public abstract Cell getAncestorCell();\r\n\r\n\r\n    private int getMetaFields() throws IOException {\r\n        return getMetaValue().getMetaFields();\r\n    }\r\n\r\n\r\n    private MetaField getMetaField(int iField) throws IOException {\r\n        return getMetaValue().getMetaField(iField);\r\n    }\r\n\r\n\r\n    private URI getAbsoluteLobFolder() {\r\n        return getMetaValue().getAbsoluteLobFolder();\r\n    }\r\n\r\n\r\n    private TableImpl getTableImpl() {\r\n        return (TableImpl) getAncestorCell().getParentRecord().getParentTable();\r\n    }\r\n\r\n\r\n    private ArchiveImpl getArchiveImpl() {\r\n        return (ArchiveImpl) getTableImpl().getParentSchema().getParentArchive();\r\n    }\r\n\r\n\r\n    private int getCardinality() throws IOException {\r\n        return getMetaValue().getCardinality();\r\n    }\r\n\r\n\r\n    private int getPreType() throws IOException {\r\n        return getMetaValue().getPreType();\r\n    }\r\n\r\n\r\n    private MetaType getMetaType() throws IOException {\r\n        return getMetaValue().getMetaType();\r\n    }\r\n\r\n\r\n    private String getMimeType() {\r\n        return getMetaValue().getMimeType();\r\n    }\r\n\r\n\r\n    public static String getColumnTag(int iColumn) {\r\n        return \"c\" + (iColumn + 1);\r\n    }\r\n\r\n\r\n    public static String getElementTag(int iIndex) {\r\n        return \"a\" + (iIndex + 1);\r\n    }\r\n\r\n\r\n    public static String getAttributeTag(int iIndex) {\r\n        return \"u\" + (iIndex + 1);\r\n    }\r\n\r\n\r\n    public static String getFieldTag(int iIndex) {\r\n        return \"r\" + (iIndex + 1);\r\n    }\r\n\r\n\r\n    public static int getIndex(String sTag) {\r\n        return Integer.parseInt(sTag.substring(1)) - 1;\r\n    }\r\n\r\n\r\n    private String getTag(MetaType mtParent, int iCardinalityParent, int iField) {\r\n        String sTag = null;\r\n        if (iCardinalityParent >= 0) {\r\n            sTag = getElementTag(iField);\r\n        } else {\r\n\r\n            CategoryType catParent = mtParent.getCategoryType();\r\n            if (catParent == CategoryType.UDT) {\r\n                sTag = getAttributeTag(iField);\r\n            } else {\r\n                sTag = getFieldTag(iField);\r\n            }\r\n        }\r\n        return sTag;\r\n    }\r\n\r\n\r\n    public String getLobFilename() throws IOException {\r\n        int iPreType = getPreType();\r\n        String sExtension = \"txt\";\r\n        if (iPreType == 2009) {\r\n            sExtension = \"xml\";\r\n        } else if (iPreType == -2 || iPreType == -3 || iPreType == 2004 || iPreType == 70) {\r\n\r\n\r\n            sExtension = \"bin\";\r\n            String sMimeType = getMimeType();\r\n            if (sMimeType != null)\r\n                sExtension = MimeTypes.getExtension(sMimeType);\r\n        }\r\n        String sFilename = \"record\" + getRecord();\r\n        return sFilename + \".\" + sExtension;\r\n    }\r\n\r\n\r\n    private Map<String, Field> _mapFields = null;\r\n\r\n\r\n    private Map<String, Field> getFieldMap() throws IOException {\r\n        if (this._mapFields == null) {\r\n\r\n            this._mapFields = new HashMap<>();\r\n            int iCardinality = getCardinality();\r\n            if (iCardinality < 0) {\r\n\r\n                MetaType mt = getMetaType();\r\n                if (mt != null) {\r\n\r\n                    for (int iField = 0; iField < getMetaFields(); iField++) {\r\n\r\n                        MetaField mf = getMetaField(iField);\r\n                        String sTag = getTag(mt, iCardinality, iField);\r\n                        this._mapFields.put(sTag, createField(iField, mf, null));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this._mapFields;\r\n    }\r\n\r\n\r\n    private void setValue(Element elValue) throws IOException {\r\n        if (elValue != null) {\r\n\r\n            int iField = 0;\r\n\r\n            for (int iChild = 0; iChild < elValue.getChildNodes().getLength(); iChild++) {\r\n\r\n                Node node = elValue.getChildNodes().item(iChild);\r\n                if (node.getNodeType() == 1) {\r\n\r\n                    Element elChild = (Element) node;\r\n                    MetaField mf = getMetaField(getIndex(elChild.getLocalName()));\r\n                    String sFieldTag = elChild.getLocalName();\r\n                    Field field = createField(iField, mf, elChild);\r\n                    getFieldMap().put(sFieldTag, field);\r\n                    iField++;\r\n                }\r\n            }\r\n        }\r\n        this._elValue = elValue;\r\n    }\r\n\r\n\r\n    public Element getValue() throws IOException {\r\n        if (getFieldMap() != null) {\r\n\r\n            if (getMetaFields() > 0) {\r\n                XU.clearElement(getValueElement());\r\n            }\r\n            int iCardinality = getCardinality();\r\n            MetaType mt = getMetaType();\r\n            for (int iField = 0; iField < getMetaFields(); iField++) {\r\n\r\n                String sTag = getTag(mt, iCardinality, iField);\r\n                Field field = getFieldMap().get(sTag);\r\n                if (field != null && !field.isNull()) {\r\n\r\n                    Element elField = ((FieldImpl) field).getValue();\r\n                    if (elField != null)\r\n                        getValueElement().appendChild(elField);\r\n                }\r\n            }\r\n        }\r\n        return this._elValue;\r\n    }\r\n\r\n\r\n    protected void initialize(long lRecord, URI uriTemporaryLobFolder, int iIndex, Element elValue, MetaValue mv) throws IOException {\r\n        this._lRecord = lRecord;\r\n        this._uriTemporaryLobFolder = uriTemporaryLobFolder;\r\n        this._iIndex = iIndex;\r\n        this._mv = mv;\r\n        setValue(elValue);\r\n        if (elValue != null) {\r\n\r\n            int iCardinality = mv.getCardinality();\r\n            if (iCardinality > 0) {\r\n\r\n\r\n                Element elChild = null;\r\n                for (Node nodeChild = elValue.getLastChild(); elChild == null && nodeChild != null; nodeChild = nodeChild.getPreviousSibling()) {\r\n\r\n                    if (nodeChild.getNodeType() == 1)\r\n                        elChild = (Element) nodeChild;\r\n                }\r\n                if (elChild != null) {\r\n\r\n\r\n                    int iArrayIndex = getIndex(elChild.getTagName());\r\n\r\n                    extendArray(iArrayIndex + 1, iCardinality);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public boolean isNull() {\r\n        return (this._elValue == null);\r\n    }\r\n\r\n\r\n    public String getString() throws IOException {\r\n        String s = null;\r\n        if (!getValueElement().hasAttribute(\"file\")) {\r\n            s = XU.fromXml(getValueElement());\r\n        } else {\r\n\r\n            Reader rdrClob = getReader();\r\n            if (rdrClob != null) {\r\n\r\n                StringWriter swr = new StringWriter();\r\n                char[] cbufTransfer = new char[8192];\r\n                int iRead;\r\n                for (iRead = rdrClob.read(cbufTransfer); iRead != -1; iRead = rdrClob.read(cbufTransfer))\r\n                    swr.write(cbufTransfer, 0, iRead);\r\n                rdrClob.close();\r\n                s = swr.getBuffer().toString();\r\n            }\r\n        }\r\n        return s;\r\n    }\r\n\r\n\r\n    public void setString(String s) throws IOException {\r\n        boolean bShort = (this._mv.getMaxLength() <= getArchiveImpl().getMaxInlineSize());\r\n        if (bShort) {\r\n            XU.toXml(s, getValueElement());\r\n        } else {\r\n\r\n            StringReader srdr = new StringReader(s);\r\n            setReader(srdr);\r\n        }\r\n    }\r\n\r\n\r\n    public byte[] getBytes() throws IOException {\r\n        byte[] buf = null;\r\n        if (!getValueElement().hasAttribute(\"file\")) {\r\n            buf = BU.fromHex(getValueElement().getTextContent());\r\n        } else {\r\n\r\n            InputStream isBlob = getInputStream();\r\n            if (isBlob != null) {\r\n\r\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                byte[] bufTransfer = new byte[8192];\r\n                int iRead;\r\n                for (iRead = isBlob.read(bufTransfer); iRead != -1; iRead = isBlob.read(bufTransfer))\r\n                    baos.write(bufTransfer, 0, iRead);\r\n                isBlob.close();\r\n                buf = baos.toByteArray();\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n\r\n    public void setBytes(byte[] buf) throws IOException {\r\n        boolean bShort = (this._mv.getMaxLength() <= getArchiveImpl().getMaxInlineSize());\r\n        if (bShort) {\r\n            getValueElement().appendChild(getValueElement().getOwnerDocument().createTextNode(BU.toHex(buf)));\r\n        } else {\r\n\r\n            ByteArrayInputStream bais = new ByteArrayInputStream(buf);\r\n            setInputStream(bais);\r\n        }\r\n    }\r\n\r\n\r\n    public Boolean getBoolean() throws IOException {\r\n        Boolean b = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 16) {\r\n                b = Boolean.valueOf(Boolean.parseBoolean(getValueElement().getTextContent()));\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to boolean!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to boolean!\");\r\n            }\r\n\r\n        }\r\n        return b;\r\n    }\r\n\r\n\r\n    public void setBoolean(boolean b) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 16) {\r\n            getValueElement().setTextContent(String.valueOf(b));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to boolean value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to boolean!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Short getShort() throws IOException {\r\n        Short sh = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 5 || iPreType == 4 || iPreType == -5) {\r\n                sh = Short.valueOf(Short.parseShort(getValueElement().getTextContent()));\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to short!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to short!\");\r\n            }\r\n\r\n        }\r\n        return sh;\r\n    }\r\n\r\n\r\n    public void setShort(short sh) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 5 || iPreType == 4 || iPreType == -5) {\r\n            getValueElement().setTextContent(String.valueOf(sh));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to short value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to short!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Integer getInt() throws IOException {\r\n        Integer i = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 5 || iPreType == 4 || iPreType == -5) {\r\n                i = Integer.valueOf(Integer.parseInt(getValueElement().getTextContent()));\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to int!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to int!\");\r\n            }\r\n\r\n        }\r\n        return i;\r\n    }\r\n\r\n\r\n    public void setInt(int i) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 5 || iPreType == 4 || iPreType == -5) {\r\n            getValueElement().setTextContent(String.valueOf(i));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to int value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to int!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Long getLong() throws IOException {\r\n        Long l = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 5 || iPreType == 4 || iPreType == -5) {\r\n                l = Long.valueOf(Long.parseLong(getValueElement().getTextContent()));\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to int!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to int!\");\r\n            }\r\n\r\n        }\r\n        return l;\r\n    }\r\n\r\n\r\n    public void setLong(long l) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 5 || iPreType == 4 || iPreType == -5) {\r\n            getValueElement().setTextContent(String.valueOf(l));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to int value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to int!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public BigInteger getBigInteger() throws IOException {\r\n        BigInteger bi = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 5 || iPreType == 4 || iPreType == -5) {\r\n                bi = new BigInteger(getValueElement().getTextContent());\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to BigInteger!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to BigInteger!\");\r\n            }\r\n\r\n        }\r\n        return bi;\r\n    }\r\n\r\n\r\n    public void setBigInteger(BigInteger bi) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 5 || iPreType == 4 || iPreType == -5) {\r\n            getValueElement().setTextContent(bi.toString());\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to BigInteger value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to BigInteger!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public BigDecimal getBigDecimal() throws IOException {\r\n        BigDecimal bd = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 3 || iPreType == 2 || iPreType == 5 || iPreType == 4 || iPreType == -5 || iPreType == 6 || iPreType == 7 || iPreType == 8) {\r\n\r\n\r\n                bd = new BigDecimal(getValueElement().getTextContent());\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to BigDecimal!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to BigDecimal!\");\r\n            }\r\n\r\n        }\r\n        return bd;\r\n    }\r\n\r\n\r\n    public void setBigDecimal(BigDecimal bd) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 3 || iPreType == 2 || iPreType == 5 || iPreType == 4 || iPreType == -5 || iPreType == 6 || iPreType == 7 || iPreType == 8) {\r\n\r\n\r\n            String s = bd.toPlainString();\r\n\r\n            try {\r\n                long l = bd.longValueExact();\r\n                s = String.valueOf(l);\r\n            } catch (ArithmeticException arithmeticException) {\r\n            }\r\n            getValueElement().setTextContent(s);\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to BigDecimal value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to BigDecimal!\");\r\n        }\r\n    }\r\n\r\n\r\n    public Float getFloat() throws IOException {\r\n        Float f = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 7 || iPreType == 8 || iPreType == 6) {\r\n                f = Float.valueOf(Float.parseFloat(getValueElement().getTextContent()));\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to float!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to float!\");\r\n            }\r\n\r\n        }\r\n        return f;\r\n    }\r\n\r\n\r\n    public void setFloat(float f) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 7 || iPreType == 8 || iPreType == 6) {\r\n            getValueElement().setTextContent(String.valueOf(f));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to float value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to float!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Double getDouble() throws IOException {\r\n        Double d = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 7 || iPreType == 6 || iPreType == 8) {\r\n                d = Double.valueOf(Double.parseDouble(getValueElement().getTextContent()));\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to double!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to double!\");\r\n            }\r\n\r\n        }\r\n        return d;\r\n    }\r\n\r\n\r\n    public void setDouble(double d) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 7 || iPreType == 8 || iPreType == 6) {\r\n            getValueElement().setTextContent(String.valueOf(d));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to double value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to double!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Date getDate() throws IOException {\r\n        Date date = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 91) {\r\n                try {\r\n                    date = _du.fromXsDate(getValueElement().getTextContent());\r\n                } catch (ParseException pe) {\r\n                    throw new IllegalArgumentException(\"Cell value \" + getValueElement().getTextContent() + \" could not be parsed as xs:date!\", pe);\r\n                }\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to date!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to date!\");\r\n            }\r\n\r\n        }\r\n        return date;\r\n    }\r\n\r\n\r\n    public void setDate(Date date) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 91) {\r\n            getValueElement().setTextContent(_du.toXsDate(date));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to date value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to date!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Time getTime() throws IOException {\r\n        Time time = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 92) {\r\n                try {\r\n                    time = _du.fromXsTime(getValueElement().getTextContent());\r\n                } catch (ParseException pe) {\r\n                    throw new IllegalArgumentException(\"Cell value \" + getValueElement().getTextContent() + \" could not be parsed as xs:time!\", pe);\r\n                }\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to time!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to time!\");\r\n            }\r\n\r\n        }\r\n        return time;\r\n    }\r\n\r\n\r\n    public void setTime(Time time) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 92) {\r\n            getValueElement().setTextContent(_du.toXsTime(time));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to time value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to time!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Timestamp getTimestamp() throws IOException {\r\n        Timestamp ts = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 93) {\r\n                try {\r\n                    ts = _du.fromXsDateTime(getValueElement().getTextContent());\r\n                } catch (ParseException pe) {\r\n                    throw new IllegalArgumentException(\"Cell value \" + getValueElement().getTextContent() + \" could not be parsed as xs:dateTime!\", pe);\r\n                }\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to timestamp!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to timestamp!\");\r\n            }\r\n\r\n        }\r\n        return ts;\r\n    }\r\n\r\n\r\n    public void setTimestamp(Timestamp ts) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 93) {\r\n            getValueElement().setTextContent(_du.toXsDateTime(ts));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to timestamp value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to timestamp!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Duration getDuration() throws IOException {\r\n        Duration duration = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 1111) {\r\n                try {\r\n                    duration = _du.fromXsDuration(getValueElement().getTextContent());\r\n                } catch (ParseException pe) {\r\n                    throw new IllegalArgumentException(\"Cell value \" + getValueElement().getTextContent() + \" could not be parsed as xs:duration!\", pe);\r\n                }\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be converted to duration!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be converted to duration!\");\r\n            }\r\n\r\n        }\r\n        return duration;\r\n    }\r\n\r\n\r\n    public void setDuration(Duration duration) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 1111) {\r\n            getValueElement().setTextContent(_du.toXsDuration(duration));\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set to duration value!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set to duration!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public Reader getReader() throws IOException {\r\n        Reader reader = null;\r\n        if (!isNull()) {\r\n            int iPreType = getPreType();\r\n            if (iPreType == 1 || iPreType == 12 || iPreType == 2005 || iPreType == -15 || iPreType == -9 || iPreType == 2011 || iPreType == 2009 || iPreType == 70) {\r\n\r\n\r\n                InputStream inputStream = getInputStreamFromLobFile();\r\n                reader = new ValidatingReader(getValueElement(), inputStream);\r\n            } else {\r\n                if (iPreType != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be read from input stream!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be read from input stream!\");\r\n            }\r\n        }\r\n        return reader;\r\n    }\r\n\r\n\r\n    public long getCharLength() throws IOException {\r\n        long lCharLength = -1L;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == 1 || iPreType == 12 || iPreType == 2005 || iPreType == -15 || iPreType == -9 || iPreType == 2011 || iPreType == 2009 || iPreType == 70) {\r\n\r\n\r\n                String sLength = getValueElement().getAttribute(\"length\");\r\n                if (sLength != null && sLength.length() > 0) {\r\n                    lCharLength = Long.parseLong(sLength);\r\n                } else {\r\n                    lCharLength = getString().length();\r\n                }\r\n            } else {\r\n                lCharLength = Long.MIN_VALUE;\r\n            }\r\n        }\r\n        return lCharLength;\r\n    }\r\n\r\n\r\n    public void setReader(Reader reader) throws IOException {\r\n        int iPreType = getPreType();\r\n        if (iPreType == 1 || iPreType == 12 || iPreType == 2005 || iPreType == -15 || iPreType == -9 || iPreType == 2011 || iPreType == 2009 || iPreType == 70) {\r\n\r\n\r\n            int iMaxInlineSize = getArchiveImpl().getMaxInlineSize();\r\n\r\n            char[] bufferPrefix = new char[iMaxInlineSize + 1];\r\n            int iOffset = 0;\r\n            int iRead = -1;\r\n            iRead = reader.read(bufferPrefix);\r\n            for (; iOffset < bufferPrefix.length && iRead != -1;\r\n                 iRead = reader.read(bufferPrefix, iOffset, bufferPrefix.length - iOffset)) {\r\n                iOffset += iRead;\r\n            }\r\n\r\n            String lobFilename = getLobFilename();\r\n            URI externalLobFolder = getAbsoluteLobFolder();\r\n\r\n            AbstractMap.SimpleEntry<File, String> lobFileAndLobFilename = getLobFileAndUpdateLobFilename(lobFilename, externalLobFolder);\r\n            File lobFile = lobFileAndLobFilename.getKey();\r\n            lobFilename = lobFileAndLobFilename.getValue();\r\n\r\n            OutputStream outputStream = new FileOutputStream(lobFile);\r\n            getValueElement().setAttribute(\"file\", lobFilename);\r\n            Writer writer = new ValidatingWriter(getValueElement(), outputStream);\r\n            writer.write(bufferPrefix, 0, iOffset);\r\n            if (iRead != -1) {\r\n                char[] bufferTransfer = new char[8192];\r\n                for (iRead = reader.read(bufferTransfer); iRead != -1; iRead = reader.read(bufferTransfer))\r\n                    writer.write(bufferTransfer, 0, iRead);\r\n            }\r\n            writer.close();\r\n            reader.close();\r\n        } else {\r\n            if (iPreType != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(iPreType) + \" cannot be set using a reader!\");\r\n            }\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set using a reader!\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public String getFilename() throws IOException {\r\n        String sFilename = null;\r\n        if (getValueElement().hasAttribute(\"file\"))\r\n            sFilename = getValueElement().getAttribute(\"file\");\r\n        return sFilename;\r\n    }\r\n\r\n\r\n    public InputStream getInputStream() throws IOException {\r\n        InputStream inputStream = null;\r\n        if (!isNull())\r\n            if (getPreType() == -2 ||\r\n                    getPreType() == -3 ||\r\n                    getPreType() == 2004 ||\r\n                    getPreType() == 70) {\r\n\r\n                inputStream = getInputStreamFromLobFile();\r\n                inputStream = new ValidatingInputStream(getValueElement(), inputStream);\r\n            } else {\r\n                if (getPreType() != 0) {\r\n                    throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(getPreType()) + \" cannot be read from input stream!\");\r\n                }\r\n                throw new IllegalArgumentException(\"Value of cell of complex type cannot be read from input stream!\");\r\n            }\r\n        return inputStream;\r\n    }\r\n\r\n    private InputStream getInputStreamFromLobFile() throws IOException {\r\n        InputStream inputStream = null;\r\n\r\n        if (getValueElement().hasAttribute(\"dlurlpathonly\")) {\r\n            String lobFileName = getValueElement().getAttribute(\"dlurlpathonly\");\r\n            URL dlURL = new URL(lobFileName);\r\n            inputStream = dlURL.openStream();\r\n        } else if (getValueElement().hasAttribute(\"file\")) {\r\n            String lobFileName = getValueElement().getAttribute(\"file\");\r\n            URI externalLobFolderUri = getAbsoluteLobFolder();\r\n            if (externalLobFolderUri == null) {\r\n                inputStream = getArchiveImpl().openFileEntry(lobFileName);\r\n            } else {\r\n                URI uriExternal = externalLobFolderUri.resolve(lobFileName);\r\n                inputStream = new FileInputStream(FU.fromUri(uriExternal));\r\n            }\r\n        }\r\n        return inputStream;\r\n    }\r\n\r\n\r\n    public long getByteLength() throws IOException {\r\n        long lByteLength = -1L;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType == -2 || iPreType == -3 || iPreType == 2004 || iPreType == 70) {\r\n\r\n\r\n                String sLength = getValueElement().getAttribute(\"length\");\r\n                if (sLength != null && sLength.length() > 0) {\r\n                    lByteLength = Long.parseLong(sLength);\r\n                } else {\r\n                    lByteLength = (getBytes()).length;\r\n                }\r\n            } else {\r\n                lByteLength = Long.MIN_VALUE;\r\n            }\r\n        }\r\n        return lByteLength;\r\n    }\r\n\r\n\r\n    public void setInputStream(InputStream inputStream) throws IOException {\r\n        if (getPreType() == -2 || getPreType() == -3 || getPreType() == 2004 || getPreType() == 70) {\r\n\r\n            int iMaxInlineSize = getArchiveImpl().getMaxInlineSize();\r\n\r\n            byte[] bufferPrefix = new byte[1 + iMaxInlineSize];\r\n            int iOffset = 0;\r\n            int iRead = -1;\r\n            iRead = inputStream.read(bufferPrefix);\r\n            for (; iOffset < bufferPrefix.length && iRead != -1; iRead = inputStream.read(bufferPrefix, iOffset,bufferPrefix.length - iOffset)) {\r\n                iOffset += iRead;\r\n            }\r\n\r\n            String lobFilename = getLobFilename();\r\n            URI externalLobFolder = getAbsoluteLobFolder();\r\n\r\n            AbstractMap.SimpleEntry<File, String> lobFileAndLobFilename = getLobFileAndUpdateLobFilename(lobFilename, externalLobFolder);\r\n            File lobFile = lobFileAndLobFilename.getKey();\r\n            lobFilename = lobFileAndLobFilename.getValue();\r\n\r\n            OutputStream outputStream = Files.newOutputStream(lobFile.toPath());\r\n            getValueElement().setAttribute(\"file\", lobFilename);\r\n            outputStream = new ValidatingOutputStream(getValueElement(), outputStream);\r\n            outputStream.write(bufferPrefix, 0, iOffset);\r\n\r\n            if (iRead != -1) {\r\n                byte[] bufferTransfer = new byte[8192];\r\n                for (iRead = inputStream.read(bufferTransfer); iRead != -1; iRead = inputStream.read(bufferTransfer)) {\r\n                    outputStream.write(bufferTransfer, 0, iRead);\r\n                }\r\n            }\r\n            outputStream.close();\r\n            inputStream.close();\r\n        } else {\r\n            if (getPreType() != 0) {\r\n                throw new IllegalArgumentException(\"Cell of type \" + SqlTypes.getTypeName(getPreType()) + \" cannot be set using an input stream!\");\r\n            }\r\n\r\n            throw new IllegalArgumentException(\"Value of cell of complex type cannot be set using an input stream!\");\r\n        }\r\n    }\r\n\r\n    private AbstractMap.SimpleEntry<File, String> getLobFileAndUpdateLobFilename(String lobFilename, URI externalLobFolderUri) throws IOException {\r\n        File lobFile;\r\n        if (externalLobFolderUri == null) {\r\n            lobFilename = getInternalLobFolder() + lobFilename;\r\n            URI uriTemporaryLobFolder = getTemporaryLobFolder();\r\n            lobFile = FU.fromUri(uriTemporaryLobFolder.resolve(lobFilename));\r\n            lobFilename = getTableImpl().getTableFolder() + lobFilename;\r\n        } else {\r\n            int iMaxLobsPerFolder = getArchiveImpl().getMaxLobsPerFolder();\r\n            if (iMaxLobsPerFolder > 0 && getTableImpl().getMetaTable().getRows() > iMaxLobsPerFolder) {\r\n                long lSequence = getRecord() / getArchiveImpl().getMaxLobsPerFolder();\r\n                lobFilename = \"seq\" + lSequence + File.separator + lobFilename;\r\n            }\r\n            URI uriExternal = externalLobFolderUri.resolve(lobFilename);\r\n            lobFile = FU.fromUri(uriExternal);\r\n        }\r\n        if (!lobFile.getParentFile().exists()) {\r\n            lobFile.getParentFile().mkdirs();\r\n        }\r\n        return new AbstractMap.SimpleEntry<>(lobFile, lobFilename);\r\n    }\r\n\r\n\r\n    public void setInputStream(InputStream inputStream, String filePath) throws IOException {\r\n        if (getPreType() == 70) {\r\n            setInputStream(inputStream);\r\n            if (getValueElement().hasAttribute(\"dlurlpathonly\")) {\r\n                getValueElement().setAttribute(\"dlurlpathonly\", filePath);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public int getElements() throws IOException {\r\n        int iElements = 0;\r\n        int iCardinality = getCardinality();\r\n        if (iCardinality >= 0)\r\n            iElements = getMetaValue().getMetaFields();\r\n        return iElements;\r\n    }\r\n\r\n\r\n    public Field getElement(int iElement) throws IOException {\r\n        Field field = null;\r\n        int iCardinality = getCardinality();\r\n        if (iCardinality >= 0) {\r\n\r\n\r\n            extendArray(iElement + 1, iCardinality);\r\n            field = getFieldMap().get(getElementTag(iElement));\r\n        } else {\r\n\r\n            throw new IllegalArgumentException(\"Cell or field is not an ARRAY!\");\r\n        }\r\n        return field;\r\n    }\r\n\r\n\r\n    public int getAttributes() throws IOException {\r\n        int iAttributes = 0;\r\n        MetaType mt = getMetaType();\r\n        CategoryType cat = null;\r\n        if (mt != null)\r\n            cat = mt.getCategoryType();\r\n        if (cat == CategoryType.UDT)\r\n            iAttributes = getFieldMap().size();\r\n        return iAttributes;\r\n    }\r\n\r\n\r\n    public Field getAttribute(int iAttribute) throws IOException {\r\n        Field field = null;\r\n        MetaType mt = getMetaType();\r\n        CategoryType cat = null;\r\n        if (mt != null)\r\n            cat = mt.getCategoryType();\r\n        if (cat == CategoryType.UDT) {\r\n            field = getFieldMap().get(getAttributeTag(iAttribute));\r\n        } else {\r\n            throw new IllegalArgumentException(\"Cell or field is not a UDT!\");\r\n        }\r\n        return field;\r\n    }\r\n\r\n\r\n    public Object getObject() throws IOException {\r\n        Object o = null;\r\n        if (!isNull()) {\r\n\r\n            int iPreType = getPreType();\r\n            if (iPreType != 0) {\r\n\r\n                switch (iPreType) {\r\n\r\n                    case -15:\r\n                    case -9:\r\n                    case 1:\r\n                    case 12:\r\n                        o = getString();\r\n                        break;\r\n                    case 2005:\r\n                    case 2009:\r\n                    case 2011:\r\n                        o = getReader();\r\n                        break;\r\n                    case -3:\r\n                    case -2:\r\n                        o = getBytes();\r\n                        break;\r\n                    case 70:\r\n                    case 2004:\r\n                        o = getInputStream();\r\n                        break;\r\n                    case 2:\r\n                    case 3:\r\n                        o = getBigDecimal();\r\n                        break;\r\n                    case 5:\r\n                        o = getInt();\r\n                        break;\r\n                    case 4:\r\n                        o = getLong();\r\n                        break;\r\n                    case -5:\r\n                        o = getBigInteger();\r\n                        break;\r\n                    case 6:\r\n                    case 8:\r\n                        o = getDouble();\r\n                        break;\r\n                    case 7:\r\n                        o = getFloat();\r\n                        break;\r\n                    case 16:\r\n                        o = getBoolean();\r\n                        break;\r\n                    case 91:\r\n                        o = getDate();\r\n                        break;\r\n                    case 92:\r\n                        o = getTime();\r\n                        break;\r\n                    case 93:\r\n                        o = getTimestamp();\r\n                        break;\r\n                    case 1111:\r\n                        o = getDuration();\r\n                        break;\r\n                }\r\n\r\n            } else {\r\n                throw new IllegalArgumentException(\"Cell is a structured type!\");\r\n            }\r\n        }\r\n        return o;\r\n    }\r\n\r\n\r\n    public List<Value> getValues(boolean bSupportsArrays, boolean bSupportsUdts) throws IOException {\r\n        List<Value> listValues = new ArrayList<>();\r\n        if (!bSupportsArrays) {\r\n            for (int iElement = 0; iElement < getElements(); iElement++)\r\n                listValues.addAll(getElement(iElement).getValues(bSupportsArrays, bSupportsUdts));\r\n        }\r\n        if (!bSupportsUdts) {\r\n            for (int iAttribute = 0; iAttribute < getAttributes(); iAttribute++)\r\n                listValues.addAll(getAttribute(iAttribute).getValues(bSupportsArrays, bSupportsUdts));\r\n        }\r\n        if (listValues.size() == 0)\r\n            listValues.add(this);\r\n        return listValues;\r\n    }\r\n\r\n\r\n    private void dumpElement(Element el, String sIndent) {\r\n        System.out.print(\"\\r\\n\" + sIndent + el.getTagName() + \":\");\r\n        int iElements = 0;\r\n        for (int i = 0; i < el.getChildNodes().getLength(); i++) {\r\n\r\n            Node node = el.getChildNodes().item(i);\r\n            if (node.getNodeType() == 1) {\r\n\r\n                Element elChild = (Element) node;\r\n                dumpElement(elChild, sIndent + \"  \");\r\n                iElements++;\r\n            }\r\n        }\r\n        if (iElements == 0)\r\n            System.out.println(\" \" + el.getTextContent());\r\n    }\r\n\r\n    public void dumpDom() {\r\n        if (this._elValue != null) {\r\n            dumpElement(this._elValue, \"\");\r\n        } else {\r\n            System.out.println(\"null\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/* Location:              C:\\Users\\lenovo\\IdeaProjects\\siardapi.jar!\\ch\\admin\\bar\\siard2\\api\\primary\\ValueImpl.class\r\n * Java compiler version: 8 (52.0)\r\n * JD-Core Version:       1.1.3\r\n */
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/SiardApi/src/main/java/ch/admin/bar/siard2/api/primary/ValueImpl.java b/SiardApi/src/main/java/ch/admin/bar/siard2/api/primary/ValueImpl.java
--- a/SiardApi/src/main/java/ch/admin/bar/siard2/api/primary/ValueImpl.java	(revision d261e70452149cce970d307f8363780404af80cb)
+++ b/SiardApi/src/main/java/ch/admin/bar/siard2/api/primary/ValueImpl.java	(date 1757653147779)
@@ -936,8 +936,12 @@
             String lobFileName = getValueElement().getAttribute("file");
             URI externalLobFolderUri = getAbsoluteLobFolder();
             if (externalLobFolderUri == null) {
-                inputStream = getArchiveImpl().openFileEntry(lobFileName);
+                // 내부 LOB: table 폴더를 기준으로 상대 경로를 해석 후 정규화
+                String base = getTableImpl().getTableFolder();
+                String resolved = resolveAgainstBase(base, lobFileName);
+                inputStream = getArchiveImpl().openFileEntry(resolved);
             } else {
+                // 외부 LOB: 외부 폴더 URI 기준으로 해석
                 URI uriExternal = externalLobFolderUri.resolve(lobFileName);
                 inputStream = new FileInputStream(FU.fromUri(uriExternal));
             }
@@ -945,6 +949,32 @@
         return inputStream;
     }
 
+    private String normalizeZipEntryPath(String path) {
+        if (path == null || path.isEmpty()) return path;
+        String[] parts = path.split("/");
+        Deque<String> stack = new ArrayDeque<>();
+        for (String part : parts) {
+            if (part.isEmpty() || part.equals(".")) continue;
+            if (part.equals("..")) {
+                if (!stack.isEmpty()) stack.removeLast();
+            } else {
+                stack.addLast(part);
+            }
+        }
+        return String.join("/", stack);
+    }
+
+    private String resolveAgainstBase(String base, String relative) {
+        if (relative == null || relative.isEmpty()) return normalizeZipEntryPath(base);
+        // 이미 content/로 시작하면 content 루트 기준으로 정규화만 수행
+        if (relative.startsWith("content/")) {
+            return normalizeZipEntryPath(relative);
+        }
+        // base + relative 결합 후 정규화
+        String joined = base + relative;
+        return normalizeZipEntryPath(joined);
+    }
+
 
     public long getByteLength() throws IOException {
         long lByteLength = -1L;
@@ -1013,9 +1043,12 @@
     private AbstractMap.SimpleEntry<File, String> getLobFileAndUpdateLobFilename(String lobFilename, URI externalLobFolderUri) throws IOException {
         File lobFile;
         if (externalLobFolderUri == null) {
-            lobFilename = getInternalLobFolder() + lobFilename;
+            // 내부 LOB: 테이블 폴더 하위에 LOB 폴더 생성
+            String internalLobFolder = getInternalLobFolder(); // "lobX/"
+            lobFilename = internalLobFolder + lobFilename;
             URI uriTemporaryLobFolder = getTemporaryLobFolder();
             lobFile = FU.fromUri(uriTemporaryLobFolder.resolve(lobFilename));
+            // XML에서 참조할 상대 경로: 테이블 폴더 기준
             lobFilename = getTableImpl().getTableFolder() + lobFilename;
         } else {
             int iMaxLobsPerFolder = getArchiveImpl().getMaxLobsPerFolder();
@@ -1026,9 +1059,12 @@
             URI uriExternal = externalLobFolderUri.resolve(lobFilename);
             lobFile = FU.fromUri(uriExternal);
         }
+        // LOB 파일의 부모 디렉토리 생성 (임시 폴더 내)
         if (!lobFile.getParentFile().exists()) {
-            lobFile.getParentFile().mkdirs();
+            boolean created = lobFile.getParentFile().mkdirs();
+            System.out.println("DEBUG: LOB 폴더 생성 시도: " + lobFile.getParentFile().getAbsolutePath() + " -> " + created);
         }
+        System.out.println("DEBUG: LOB 파일 경로: " + lobFile.getAbsolutePath() + ", XML 참조: " + lobFilename);
         return new AbstractMap.SimpleEntry<>(lobFile, lobFilename);
     }
 
Index: SiardApi/src/main/java/ch/admin/bar/siard2/api/meta/MetaColumnImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.admin.bar.siard2.api.meta;\r\n\r\nimport ch.admin.bar.siard2.api.Archive;\r\nimport ch.admin.bar.siard2.api.MetaAttribute;\r\nimport ch.admin.bar.siard2.api.MetaColumn;\r\nimport ch.admin.bar.siard2.api.MetaField;\r\nimport ch.admin.bar.siard2.api.MetaSchema;\r\nimport ch.admin.bar.siard2.api.MetaTable;\r\nimport ch.admin.bar.siard2.api.MetaType;\r\nimport ch.admin.bar.siard2.api.MetaView;\r\nimport ch.admin.bar.siard2.api.Schema;\r\nimport ch.admin.bar.siard2.api.Table;\r\nimport ch.admin.bar.siard2.api.generated.CategoryType;\r\nimport ch.admin.bar.siard2.api.generated.ColumnType;\r\nimport ch.admin.bar.siard2.api.generated.FieldType;\r\nimport ch.admin.bar.siard2.api.generated.FieldsType;\r\nimport ch.admin.bar.siard2.api.generated.ObjectFactory;\r\nimport ch.admin.bar.siard2.api.primary.ArchiveImpl;\r\nimport ch.enterag.sqlparser.BaseSqlFactory;\r\nimport ch.enterag.sqlparser.SqlFactory;\r\nimport ch.enterag.sqlparser.datatype.PredefinedType;\r\nimport ch.enterag.sqlparser.datatype.enums.PreType;\r\nimport ch.enterag.sqlparser.ddl.enums.Multiplier;\r\nimport ch.enterag.utils.DU;\r\nimport ch.enterag.utils.SU;\r\nimport ch.enterag.utils.xml.XU;\r\nimport java.io.IOException;\r\nimport java.math.BigInteger;\r\nimport java.net.URI;\r\nimport java.net.URISyntaxException;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\nimport java.util.regex.Matcher;\r\n\r\npublic class MetaColumnImpl extends MetaValueImpl implements MetaColumn {\r\n  private static final long lKILO = 1024L;\r\n  private static final long lMEGA = 1048576L;\r\n  private static final ObjectFactory _of = new ObjectFactory(); private static final long lGIGA = 1073741824L; public static final String _sLOB_FOLDER_PREFIX = \"lob\";\r\n  private final Map<String, MetaField> _mapMetaFields = new HashMap<>();\r\n\r\n  \r\n  private Map<String, MetaField> getMetaFieldsMap() throws IOException {\r\n    if (getArchiveImpl().canModifyPrimaryData())\r\n    {\r\n      if (getCardinality() < 0) {\r\n        \r\n        MetaType mt = getMetaType();\r\n        if (mt != null) {\r\n          \r\n          CategoryType cat = mt.getCategoryType();\r\n          if (cat != CategoryType.DISTINCT)\r\n          {\r\n            for (int i = this._mapMetaFields.size(); i < mt.getMetaAttributes(); i++)\r\n              createMetaField(); \r\n          }\r\n        } \r\n      } \r\n    }\r\n    return this._mapMetaFields;\r\n  }\r\n  \r\n  private String _sFolder = null;\r\n  \r\n  private MetaTable _mtParent = null;\r\n  \r\n  public MetaTable getParentMetaTable() {\r\n    return this._mtParent;\r\n  }\r\n  private MetaView _mvParent = null;\r\n  \r\n  public MetaView getParentMetaView() {\r\n    return this._mvParent;\r\n  }\r\n  \r\n  public MetaColumn getAncestorMetaColumn() {\r\n    return this;\r\n  }\r\n  \r\n  public boolean isValid() {\r\n    return (getType() != null || getTypeName() != null);\r\n  }\r\n  private ColumnType _ct = null;\r\n\r\n  \r\n  public ColumnType getColumnType() throws IOException {\r\n    for (int iField = 0; iField < getMetaFields(); iField++) {\r\n      \r\n      MetaField mf = getMetaField(iField);\r\n      ((MetaFieldImpl)mf).getFieldType();\r\n    } \r\n    return this._ct;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  private Table getTable() {\r\n    Table table = null;\r\n    if (getParentMetaTable() != null)\r\n      table = getParentMetaTable().getTable(); \r\n    return table;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  private ArchiveImpl getArchiveImpl() {\r\n    Archive archive = null;\r\n    if (getParentMetaTable() != null) {\r\n      archive = getParentMetaTable().getTable().getParentSchema().getParentArchive();\r\n    } else if (getParentMetaView() != null) {\r\n      archive = getParentMetaView().getParentMetaSchema().getSchema().getParentArchive();\r\n    }  return (ArchiveImpl)archive;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  private MetaSchema getMetaSchema() {\r\n    MetaSchema ms = null;\r\n    if (getParentMetaTable() != null) {\r\n      ms = getParentMetaTable().getParentMetaSchema();\r\n    } else if (getParentMetaView() != null) {\r\n      ms = getParentMetaView().getParentMetaSchema();\r\n    }  return ms;\r\n  }\r\n  \r\n  private ColumnType _ctTemplate = null;\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setTemplate(ColumnType ctTemplate) throws IOException {\r\n    this._ctTemplate = ctTemplate;\r\n    if (!SU.isNotEmpty(getDescription()))\r\n      setDescription(XU.fromXml(this._ctTemplate.getDescription())); \r\n    if (getParentMetaTable() != null)\r\n    {\r\n      if (getArchiveImpl().canModifyPrimaryData()) {\r\n        \r\n        if (getLobFolder() == null && SU.isNotEmpty(this._ctTemplate.getLobFolder()))\r\n          setLobFolder(URI.create(XU.fromXml(this._ctTemplate.getLobFolder()))); \r\n        if (getMimeType() == null && SU.isNotEmpty(this._ctTemplate.getMimeType()))\r\n          setMimeType(XU.fromXml(this._ctTemplate.getMimeType())); \r\n      } \r\n    }\r\n    FieldsType fts = this._ctTemplate.getFields();\r\n    if (fts != null)\r\n    {\r\n      \r\n      for (int iField = 0; iField < fts.getField().size(); iField++) {\r\n        \r\n        FieldType ftTemplate = fts.getField().get(iField);\r\n        String sName = XU.fromXml(ftTemplate.getName());\r\n        MetaField mf = getMetaField(sName);\r\n        if (mf != null) {\r\n          \r\n          MetaFieldImpl mfi = (MetaFieldImpl)mf;\r\n          mfi.setTemplate(ftTemplate);\r\n        } \r\n      } \r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  private void openMetaFields() throws IOException {\r\n    FieldsType fts = this._ct.getFields();\r\n    if (fts != null)\r\n    {\r\n      for (int iField = 0; iField < fts.getField().size(); iField++) {\r\n        \r\n        FieldType ft = fts.getField().get(iField);\r\n        MetaField mf = MetaFieldImpl.newInstance(this, ft, this._sFolder, iField + 1);\r\n        this._mapMetaFields.put(mf.getName(), mf);\r\n      } \r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  private MetaColumnImpl(MetaTable mtParent, ColumnType ct, int iPosition) throws IOException {\r\n    super(iPosition);\r\n    this._mtParent = mtParent;\r\n    this._ct = ct;\r\n    this._sFolder = \"../lob\" + (iPosition - 1) + \"/\";\r\n    openMetaFields();\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  private MetaColumnImpl(MetaView mvParent, ColumnType ct, int iPosition) throws IOException {\r\n    super(iPosition);\r\n    this._mvParent = mvParent;\r\n    this._ct = ct;\r\n    openMetaFields();\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public static MetaColumn newInstance(MetaTable mtParent, int iPosition, ColumnType ct) throws IOException {\r\n    return new MetaColumnImpl(mtParent, ct, iPosition);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public static MetaColumn newInstance(MetaView mvParent, int iPosition, ColumnType ct) throws IOException {\r\n    return new MetaColumnImpl(mvParent, ct, iPosition);\r\n  }\r\n\r\n\r\n  \r\n  public String getName() {\r\n    return XU.fromXml(this._ct.getName());\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public String getFolder() {\r\n    String sFolder = null;\r\n    if (getLobFolder() == null)\r\n      sFolder = this._sFolder; \r\n    return sFolder;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setLobFolder(URI uriLobFolder) throws IOException {\r\n    boolean bMayBeSet = false;\r\n    if (getLobFolder() == null) {\r\n      \r\n      if (getTable() != null && getTable().isEmpty()) {\r\n        bMayBeSet = true;\r\n      }\r\n    } else {\r\n      bMayBeSet = true;\r\n    }  if (bMayBeSet) {\r\n      \r\n      if (getArchiveImpl().isMetaDataDifferent(getLobFolder(), uriLobFolder))\r\n      {\r\n        if (uriLobFolder != null) {\r\n          \r\n          MetaDataImpl mdi = (MetaDataImpl)getParentMetaTable().getTable().getParentSchema().getParentArchive().getMetaData();\r\n          if (uriLobFolder.getPath().endsWith(\"/\")) {\r\n            \r\n            if (uriLobFolder.isAbsolute()) {\r\n              \r\n              if (uriLobFolder.getScheme() == null) {\r\n                try {\r\n                  uriLobFolder = new URI(\"file\", \"\", uriLobFolder.getPath(), null);\r\n                } catch (URISyntaxException uRISyntaxException) {}\r\n              }\r\n              if (!uriLobFolder.getScheme().equals(\"file\")) {\r\n                throw new IllegalArgumentException(\"Only URIs with scheme \\\"file\\\" allowed for LOB folder!\");\r\n              }\r\n            } else if (mdi.getLobFolder() == null) {\r\n              \r\n              if (!uriLobFolder.getPath().startsWith(\"../\"))\r\n                throw new IllegalArgumentException(\"Relative LOB folder URIs must start with \\\"..\\\"!\"); \r\n            } \r\n            this._ct.setLobFolder(XU.toXml(uriLobFolder.toString()));\r\n          } else {\r\n            \r\n            throw new IllegalArgumentException(\"Path of LOB folder URI must denote a folder (end with \\\"/\\\")!\");\r\n          } \r\n        } else {\r\n          throw new IllegalArgumentException(\"LOB folder URI must not be null!\");\r\n        } \r\n      }\r\n    } else {\r\n      throw new IOException(\"LOB folder value cannot be set!\");\r\n    } \r\n  }\r\n\r\n\r\n  \r\n  public URI getLobFolder() {\r\n    URI uriLobFolder = null;\r\n    if (this._ct.getLobFolder() != null) {\r\n      try {\r\n        uriLobFolder = new URI(XU.fromXml(this._ct.getLobFolder()));\r\n      } catch (URISyntaxException uRISyntaxException) {}\r\n    }\r\n    return uriLobFolder;\r\n  }\r\n\r\n\r\n\r\n\r\n  \r\n  public URI getAbsoluteLobFolder() {\r\n    URI uriLocal = getLobFolder();\r\n    MetaDataImpl mdi = (MetaDataImpl)getArchiveImpl().getMetaData();\r\n    if (uriLocal != null)\r\n    {\r\n      if (!uriLocal.isAbsolute()) {\r\n        \r\n        URI uriGlobal = mdi.getLobFolder();\r\n        if (uriGlobal != null) {\r\n          \r\n          uriGlobal = mdi.getAbsoluteUri(uriGlobal);\r\n          uriLocal = uriGlobal.resolve(uriLocal);\r\n        } else {\r\n          \r\n          uriLocal = mdi.getAbsoluteUri(uriLocal);\r\n        } \r\n      }  } \r\n    return uriLocal;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setType(String sType) throws IOException {\r\n    ArchiveImpl ai = getArchiveImpl();\r\n    if (ai.canModifyPrimaryData()) {\r\n      \r\n      if (ai.isMetaDataDifferent(getTypeSchema(), null))\r\n        this._ct.setTypeSchema(null); \r\n      if (ai.isMetaDataDifferent(getTypeName(), null))\r\n        this._ct.setTypeName(null); \r\n      BaseSqlFactory baseSqlFactory = new BaseSqlFactory();\r\n      PredefinedType pt = new PredefinedType(baseSqlFactory);\r\n      pt.parse(sType);\r\n      sType = pt.format();\r\n      if (ai.isMetaDataDifferent(getType(), sType)) {\r\n        this._ct.setType(XU.toXml(pt.format()));\r\n      }\r\n    } else {\r\n      throw new IOException(\"Type cannot be set!\");\r\n    } \r\n  }\r\n\r\n\r\n\r\n  \r\n  public void setPreType(int iDataType, long lPrecision, int iScale) throws IOException {\r\n    BaseSqlFactory baseSqlFactory = new BaseSqlFactory();\r\n    PredefinedType prt = baseSqlFactory.newPredefinedType();\r\n    prt.initialize(iDataType, lPrecision, iScale);\r\n    String sType = prt.format();\r\n    setType(sType);\r\n  }\r\n  \r\n  public String getType() {\r\n    return XU.fromXml(this._ct.getType());\r\n  }\r\n\r\n\r\n\r\n  \r\n  public int getPreType() throws IOException {\r\n    int iDataType = 0;\r\n    MetaType mt = getMetaType();\r\n    CategoryType cat = null;\r\n    if (mt != null)\r\n      cat = mt.getCategoryType(); \r\n    String sType = getType();\r\n    if (sType != null) {\r\n      \r\n      BaseSqlFactory baseSqlFactory = new BaseSqlFactory();\r\n      PredefinedType prt = baseSqlFactory.newPredefinedType();\r\n      prt.parse(sType);\r\n      PreType pt = prt.getType();\r\n      iDataType = pt.getSqlType();\r\n    }\r\n    else if (cat == CategoryType.DISTINCT) {\r\n      iDataType = mt.getBasePreType();\r\n    }  return iDataType;\r\n  }\r\n\r\n\r\n\r\n\r\n  \r\n  public long getLength() throws IOException {\r\n    long lLength = -1L;\r\n    MetaType mt = getMetaType();\r\n    CategoryType cat = null;\r\n    if (mt != null)\r\n      cat = mt.getCategoryType(); \r\n    String sType = getType();\r\n    if (sType != null) {\r\n      \r\n      BaseSqlFactory baseSqlFactory = new BaseSqlFactory();\r\n      PredefinedType prt = baseSqlFactory.newPredefinedType();\r\n      prt.parse(sType);\r\n      lLength = prt.getLength();\r\n      if (lLength != -1L) {\r\n        \r\n        Multiplier mult = prt.getMultiplier();\r\n        if (mult != null)\r\n        {\r\n          switch (mult) {\r\n            case K:\r\n              lLength *= 1024L; break;\r\n            case M: lLength *= 1048576L; break;\r\n            case G: lLength *= 1073741824L;\r\n              break;\r\n          } \r\n        }\r\n      } else {\r\n        lLength = prt.getPrecision();\r\n      } \r\n    } else if (cat == CategoryType.DISTINCT) {\r\n      lLength = mt.getBaseLength();\r\n    }  return lLength;\r\n  }\r\n\r\n\r\n\r\n\r\n  \r\n  public int getScale() throws IOException {\r\n    int iScale = -1;\r\n    MetaType mt = getMetaType();\r\n    CategoryType cat = null;\r\n    if (mt != null)\r\n      cat = mt.getCategoryType(); \r\n    String sType = getType();\r\n    if (sType != null) {\r\n      \r\n      BaseSqlFactory baseSqlFactory = new BaseSqlFactory();\r\n      PredefinedType prt = baseSqlFactory.newPredefinedType();\r\n      prt.parse(sType);\r\n      iScale = prt.getScale();\r\n    }\r\n    else if (cat == CategoryType.DISTINCT) {\r\n      iScale = mt.getBaseScale();\r\n    }  return iScale;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setTypeOriginal(String sTypeOriginal) throws IOException {\r\n    if (getArchiveImpl().canModifyPrimaryData()) {\r\n      \r\n      if (getArchiveImpl().isMetaDataDifferent(getTypeOriginal(), sTypeOriginal)) {\r\n        this._ct.setTypeOriginal(XU.toXml(sTypeOriginal));\r\n      }\r\n    } else {\r\n      throw new IOException(\"Original type cannot be set!\");\r\n    } \r\n  }\r\n  public String getTypeOriginal() {\r\n    return XU.fromXml(this._ct.getTypeOriginal());\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setNullable(boolean bNullable) throws IOException {\r\n    if (getArchiveImpl().canModifyPrimaryData() && getTable() != null && getTable().isEmpty()) {\r\n      \r\n      if (getArchiveImpl().isMetaDataDifferent(Boolean.valueOf(isNullable()), Boolean.valueOf(bNullable))) {\r\n        this._ct.setNullable(Boolean.valueOf(bNullable));\r\n      }\r\n    } else {\r\n      throw new IOException(\"Nullability cannot be set!\");\r\n    } \r\n  }\r\n\r\n  \r\n  public boolean isNullable() {\r\n    boolean bNullable = true;\r\n    if (this._ct.isNullable() != null)\r\n      bNullable = this._ct.isNullable().booleanValue(); \r\n    return bNullable;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setDefaultValue(String sDefaultValue) throws IOException {\r\n    if (getArchiveImpl().canModifyPrimaryData() && getTable() != null && getTable().isEmpty()) {\r\n      \r\n      if (getArchiveImpl().isMetaDataDifferent(getDefaultValue(), sDefaultValue)) {\r\n        this._ct.setDefaultValue(XU.toXml(sDefaultValue));\r\n      }\r\n    } else {\r\n      throw new IOException(\"Default value cannot be set!\");\r\n    } \r\n  }\r\n  public String getDefaultValue() {\r\n    return XU.fromXml(this._ct.getDefaultValue());\r\n  }\r\n\r\n\r\n  \r\n  public void setMimeType(String mimeType) throws IOException {\r\n    if (getArchiveImpl().isMetaDataDifferent(getMimeType(), mimeType))\r\n      this._ct.setMimeType(XU.toXml(mimeType)); \r\n  }\r\n  \r\n  public String getMimeType() {\r\n    return XU.fromXml(this._ct.getMimeType());\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setTypeSchema(String sTypeSchema) throws IOException {\r\n    if (getArchiveImpl().canModifyPrimaryData()) {\r\n      \r\n      if (getArchiveImpl().isMetaDataDifferent(getType(), null))\r\n        this._ct.setType(null); \r\n      if (getArchiveImpl().isMetaDataDifferent(getTypeSchema(), sTypeSchema)) {\r\n        this._ct.setTypeSchema(XU.toXml(sTypeSchema));\r\n      }\r\n    } else {\r\n      throw new IOException(\"Type schema cannot be set!\");\r\n    } \r\n  }\r\n  public String getTypeSchema() {\r\n    return XU.fromXml(this._ct.getTypeSchema());\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setTypeName(String sTypeName) throws IOException {\r\n    if (getArchiveImpl().canModifyPrimaryData()) {\r\n      \r\n      if (getArchiveImpl().isMetaDataDifferent(getType(), null))\r\n        this._ct.setType(null); \r\n      if (getArchiveImpl().isMetaDataDifferent(getTypeName(), sTypeName)) {\r\n        \r\n        this._ct.setTypeName(XU.toXml(sTypeName));\r\n        if (getTypeSchema() == null) {\r\n          setTypeSchema(getMetaSchema().getName());\r\n        }\r\n      } \r\n    } else {\r\n      throw new IOException(\"Type name cannot be set!\");\r\n    } \r\n  }\r\n  public String getTypeName() {\r\n    return XU.fromXml(this._ct.getTypeName());\r\n  }\r\n\r\n\r\n  \r\n  public MetaType getMetaType() {\r\n    MetaType mt = null;\r\n    if (getTypeName() != null) {\r\n      \r\n      Schema schema = getArchiveImpl().getSchema(getTypeSchema());\r\n      if (schema != null)\r\n        mt = schema.getMetaSchema().getMetaType(getTypeName()); \r\n    } \r\n    return mt;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public int getMetaFields() throws IOException {\r\n    return getMetaFieldsMap().size();\r\n  }\r\n\r\n\r\n\r\n\r\n  \r\n  public MetaField getMetaField(int iField) throws IOException {\r\n    MetaField mf = null;\r\n    \r\n    if (getCardinality() > 0)\r\n    {\r\n      for (int i = this._mapMetaFields.size(); i < iField + 1; i++)\r\n        createMetaField(); \r\n    }\r\n    for (Iterator<String> iterField = getMetaFieldsMap().keySet().iterator(); mf == null && iterField.hasNext(); ) {\r\n      \r\n      String sName = iterField.next();\r\n      MetaFieldImpl mfi = (MetaFieldImpl)getMetaField(sName);\r\n      if (this._ct.getFields().getField().get(iField) == mfi._ft)\r\n        mf = mfi; \r\n    } \r\n    return mf;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public MetaField getMetaField(String sName) throws IOException {\r\n    if (getCardinality() > 0) {\r\n      \r\n      Matcher match = _patARRAY_INDEX.matcher(sName);\r\n      if (match.matches()) {\r\n        \r\n        int iIndex = Integer.parseInt(match.group(1));\r\n        for (int i = this._mapMetaFields.size(); i < iIndex; i++)\r\n          createMetaField(); \r\n      } \r\n    } \r\n    return getMetaFieldsMap().get(sName);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public MetaField createMetaField() throws IOException {\r\n    MetaField mf = null;\r\n    if (getArchiveImpl().canModifyPrimaryData()) {\r\n      \r\n      FieldsType fts = this._ct.getFields();\r\n      if (fts == null) {\r\n        \r\n        fts = _of.createFieldsType();\r\n        this._ct.setFields(fts);\r\n      } \r\n      FieldType ft = _of.createFieldType();\r\n      fts.getField().add(ft);\r\n      int iPosition = this._mapMetaFields.size() + 1;\r\n      String sName = getName() + \"[\" + iPosition + \"]\";\r\n      if (getCardinality() < 0) {\r\n        \r\n        MetaType mt = getMetaType();\r\n        MetaAttribute ma = mt.getMetaAttribute(iPosition - 1);\r\n        if (ma != null)\r\n          sName = ma.getName(); \r\n      } \r\n      ft.setName(XU.toXml(sName));\r\n      mf = MetaFieldImpl.newInstance(this, ft, this._sFolder, iPosition);\r\n      this._mapMetaFields.put(mf.getName(), mf);\r\n      getArchiveImpl().isMetaDataDifferent(null, mf);\r\n      if (this._ctTemplate != null) {\r\n        \r\n        FieldsType ftsTemplate = this._ctTemplate.getFields();\r\n        if (ftsTemplate != null) {\r\n          \r\n          FieldType ftTemplate = null;\r\n          for (int iField = 0; iField < ftsTemplate.getField().size(); iField++) {\r\n            \r\n            FieldType ftTry = ftsTemplate.getField().get(iField);\r\n            if (sName.equals(ftTry.getName()))\r\n              ftTemplate = ftTry; \r\n          } \r\n          if (ftTemplate != null) {\r\n            \r\n            MetaFieldImpl mfi = (MetaFieldImpl)mf;\r\n            mfi.setTemplate(ftTemplate);\r\n          } \r\n        } \r\n      } \r\n    } else {\r\n      \r\n      throw new IOException(\"New field cannot be added!\");\r\n    }  return mf;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setCardinality(int iCardinality) throws IOException {\r\n    if (getArchiveImpl().canModifyPrimaryData() && (getTable() == null || getTable().isEmpty())) {\r\n      \r\n      if (getArchiveImpl().isMetaDataDifferent(Integer.valueOf(getCardinality()), Integer.valueOf(iCardinality))) {\r\n        this._ct.setCardinality(BigInteger.valueOf(iCardinality));\r\n      }\r\n    } else {\r\n      throw new IOException(\"Cardinality cannot be set!\");\r\n    } \r\n  }\r\n\r\n\r\n\r\n\r\n  \r\n  public int getCardinality() throws IOException {\r\n    int iCardinality = -1;\r\n    BigInteger bi = this._ct.getCardinality();\r\n    if (bi != null)\r\n      iCardinality = bi.intValue(); \r\n    return iCardinality;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public void setDescription(String sDescription) {\r\n    if (getArchiveImpl().isMetaDataDifferent(getDescription(), sDescription))\r\n      this._ct.setDescription(XU.toXml(sDescription)); \r\n  }\r\n  \r\n  public String getDescription() {\r\n    return XU.fromXml(this._ct.getDescription());\r\n  }\r\n\r\n\r\n\r\n  \r\n  public String[] getSearchElements(DU du) throws IOException {\r\n    return new String[] {\r\n        \r\n        getName(), \r\n        String.valueOf(getPosition()), \r\n        (getLobFolder() == null) ? \"\" : getLobFolder().toString(), \r\n        getMimeType(), \r\n        getType(), \r\n        getTypeSchema(), \r\n        getTypeName(), \r\n        getTypeOriginal(), \r\n        String.valueOf(isNullable()), \r\n        getDefaultValue(), \r\n        (getCardinality() <= 0) ? \"\" : String.valueOf(getCardinality()), \r\n        getDescription()\r\n      };\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  public String toString() {\r\n    return getName();\r\n  }\r\n}\r\n\r\n\r\n/* Location:              C:\\Users\\lenovo\\IdeaProjects\\siardapi.jar!\\ch\\admin\\bar\\siard2\\api\\meta\\MetaColumnImpl.class\r\n * Java compiler version: 8 (52.0)\r\n * JD-Core Version:       1.1.3\r\n */
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/SiardApi/src/main/java/ch/admin/bar/siard2/api/meta/MetaColumnImpl.java b/SiardApi/src/main/java/ch/admin/bar/siard2/api/meta/MetaColumnImpl.java
--- a/SiardApi/src/main/java/ch/admin/bar/siard2/api/meta/MetaColumnImpl.java	(revision d261e70452149cce970d307f8363780404af80cb)
+++ b/SiardApi/src/main/java/ch/admin/bar/siard2/api/meta/MetaColumnImpl.java	(date 1757652986159)
@@ -204,7 +204,8 @@
     super(iPosition);
     this._mtParent = mtParent;
     this._ct = ct;
-    this._sFolder = "../lob" + (iPosition - 1) + "/";
+    // LOB 내부 폴더는 테이블 폴더 하위로만 구성해야 한다. 상위 경로 참조("../")를 제거한다.
+    this._sFolder = "lob" + (iPosition - 1) + "/";
     openMetaFields();
   }
 
