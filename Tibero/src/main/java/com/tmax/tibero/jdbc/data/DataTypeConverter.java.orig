/**
 * Copyright (c) 2011-, TmaxData, Inc. / Seoul, Republic of Korea
 *
 * This document contains proprietary and confidential information.  No
 * parts of this document or the computer program it embodies may be in
 * any way copied, duplicated, reproduced, translated into a different
 * programming language, or distributed to any person, company, or
 * corporation without the prior written consent of Tibero, Inc.
 */
package tibero.jdbc.data;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.text.NumberFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.TimeZone;

import tibero.Debug;
import tibero.jdbc.TbArray;
import tibero.jdbc.TbArrayDescriptor;
import tibero.jdbc.TbBlob;
import tibero.jdbc.TbClob;
import tibero.jdbc.TbIntervalDts;
import tibero.jdbc.TbIntervalYtm;
import tibero.jdbc.TbLob;
import tibero.jdbc.TbNClob;
import tibero.jdbc.TbRowId;
import tibero.jdbc.TbSQLXML;
import tibero.jdbc.TbStruct;
import tibero.jdbc.TbStructDescriptor;
import tibero.jdbc.TbTypeDescriptor;
import tibero.jdbc.TbXMLInputStream;
import tibero.jdbc.data.charset.Charset;
import tibero.jdbc.data.charset.CharsetMapper;
import tibero.jdbc.dbconst.DBConst;
import tibero.jdbc.driver.TbConnection;
import tibero.jdbc.driver.TbResultSet;
import tibero.jdbc.driver.TbResultSetFactory;
import tibero.jdbc.driver.TbStatement;
import tibero.jdbc.err.TbError;
import tibero.jdbc.msg.TbColumnDesc;
import tibero.jdbc.util.TbCommon;
import tibero.jdbc.util.TbDTFormatter;

// #ifdef JDK1.6
import java.sql.NClob;
import java.sql.SQLXML;
// #endif

/**
 * DataTypeConverter class.
 * 
 * @author �̿���, yjlee@tmax.co.kr ��Ի�, gusami@tmax.co.kr
 * @version $Id: DataTypeConverter.java 186284 2020-10-20 09:17:47Z kyungtak_min $
 */
public class DataTypeConverter implements Cloneable {
    /* UDT rpcol */
    public final static byte RPCOL_UDT_OBJ = (byte) 0x84;
    public final static byte RPCOL_UDT_COLL = (byte) 0x88;
    public final static byte RPCOL_UDT_ROOT = 0x1;
    public final static byte RPCOL_UDT_SUBTYPE = 0x2;
    public final static byte[] RPCOL_UDT_NOT_FINAL = { (byte) 0xFE, 0, 0, 0 };
    public final static int RPCOL_UDT_MIN_SIZE = 3; // Magic number 2bytes + rpcol len 1byte
    public final static byte RPCOL_NULLOBJ_W_DEPTH = (byte) 0xFC;
    public static byte RPCOL_NULLOBJ; // �������� 2.16���� 253->251 ����
    public static byte RPCOL_5BYTE; // �������� 2.16���� 251->253 ����

    public final static int COLLECTION_META_LENGTH = 40;
    public final static int STRUCT_META_LENGTH = 40;

    public final static String _DESC_OID_PREFIX = "/O";
    public final static String _DESC_TOBJ_ID_PREFIX = "/T";
    public final static String _DESC_VERSION_NO_PREFIX = "/V";

    private TbConnection conn = null;
    private CharsetMapper charsetMapper = null;
    private CharsetMapper nCharsetMapper = null;

    public final static String BUDDHA_CALENDAR = "THAI BUDDHA";
    public final static int BUDDHA_YEAR_GAP = 543;

    public DataTypeConverter(TbConnection conn1) throws SQLException {
        charsetMapper = new CharsetMapper(Charset.MSWIN949);
        conn = conn1;
    }

    public void buildColumnMetadata(TbColumnDesc[] colDesc, TbResultSet rs,
                                    int colCnt) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.buildColumnMetadata",
                            new Object[] {
                                    colDesc, rs, Integer.toString(colCnt)
            });
        }
        buildColumnMetaData(colDesc, 0, colCnt, rs.getCols());

        for (int i = 0; i < colCnt; i++) {
            if (DataType.isLocatorCategory(colDesc[i].dataType))
                rs.setHaveLocator(true);
        }
    }

    public void buildColumnMetaData(TbColumnDesc[] colDesc, int off, int colCnt,
                                    Column[] cols) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.buildColumnMetadata",
                            new Object[] {
                                    colDesc, cols, Integer.toString(colCnt)
            });
            Debug.log(colDesc2Str(colDesc));
        }

        /*
         * colDesc[] ���� 0 ~ (colCnt - 1)�� �÷� �������̸�,
         * colCnt ���ʹ� Object, Collection Ÿ�� ���� ���� �߰����� ��Ÿ�����̴�. 
         */
        if (colDesc.length > colCnt) {
            // #ifdef JDK1.5
            HashMap<Integer, TbTypeDescriptor> newDescMap =
                    new HashMap<Integer, TbTypeDescriptor>();
//            // #else
//            HashMap newDescMap = new HashMap();
            // #endif
            /*
             * == Object/Collection header�� ����� ColumnDesc �ʵ� ==
             * type    -> DataType.OBJECT | DataType.VARRAY
             * length  -> 0
             * prec    -> tb object id
             * scale   -> object�� ���, colDesc[] ������ header index // XXX: 0���θ� ��������.
             * name    -> HEX encoded OID string
             * etcMeta -> 0
             */
            try {
                for (int i = colCnt; i < colDesc.length; i++) {
                    if (colDesc[i].name != null &&
                            colDesc[i].name.matches("[0-9a-zA-Z]{32}")) {
                        switch (colDesc[i].dataType) {
                        case DataType.OBJECT:
                        case DataType.RECORD:
                            /*
                             * FIXME: CLIENT_INTERNAL ��Ű���� �̿��� ��Ӱ��迡 �ִ�
                             *  Ÿ�������� �ѹ��� ������ �� �ִ�. ����� ���� ������ �־�
                             *  ������ DD ��ȸ�� ���� �������� ����
                             */
                            TbStructDescriptor newStDesc = TbStructDescriptor
                                    .createDescriptor(colDesc[i].dataType,
                                                      colDesc[i].name, conn);
                            descPut(newDescMap, i, newStDesc);
//                            // ��� subtype�� ������ descriptor���� ��� desc map�� �ε�
//                            TbStructDescriptor.lookupUdtMeta(colDesc[i].name, // oid
//                                                              conn);
//                            // �÷� �������� root type�� descriptor�� ����
//                            descPut(newDescMap, i,
//                                    (TbTypeDescriptor) conn
//                                            .getDescriptor(_DESC_OID_PREFIX +
//                                                    colDesc[i].name));
                            break;

                        case DataType.VARRAY:
                        case DataType.TABLE:
                        case DataType.IDX_BY_TBL:
                            TbArrayDescriptor newArrDesc = TbArrayDescriptor
                                    .createDescriptor(colDesc[i].dataType,
                                                      colDesc[i].name, conn);
                            descPut(newDescMap, i, newArrDesc);
                            break;
                        }
                    }
                }
            }
            catch (SQLException e) {
                if (e.getErrorCode() <= TbError.COMM_ERROR &&
                        e.getErrorCode() > TbError.SVR_BACKEND_ERROR) {
                    throw e;
                }
                conn.addWarning(TbError
                                .newSQLWarning(TbError.MU_UDT_META_DATA_LOAD_FAIL, e));
            }
            catch (Exception e) {
                conn.addWarning(TbError
                        .newSQLWarning(TbError.MU_UDT_META_DATA_LOAD_FAIL, e));
            }

            for (int i = 0; i < colCnt; i++) {
                if (DataType.isUDTCategory(colDesc[i].dataType)) {
                    /*
                     * == Object/Collection �÷��� ����� ColumnDesc �ʵ� ==
                     * type
                     * length
                     * prec    -> type object id
                     * scale   -> colDesc[] ������ header index
                     * name
                     * etcMeta
                     */
                    cols[i].set(i, colDesc[i],
                                descGet(newDescMap, colDesc[i].scale));
                }
                else {
                    cols[i].set(i, colDesc[i]);
                }
            }
        }
        else {
            for (int i = 0; i < colCnt; i++) {
                cols[i].set(i, colDesc[i]);
            }
        }
    }

    private static String colDesc2Str(TbColumnDesc[] descs) {
        if (descs == null) {
            return "[(null)]";
        }
        StringBuffer sb = new StringBuffer(descs.length * 40);
        sb.append("[#\n");
        for (int i = 0; i < descs.length; i++) {
            sb.append("  coldesc idx=").append(i).append("/type=")
                    .append(descs[i].dataType).append("/size=")
                    .append(descs[i].maxSize).append("/prec=")
                    .append(descs[i].precision).append("/scale=")
                    .append(descs[i].scale).append("/etc=")
                    .append(descs[i].etcMeta).append("/name=")
                    .append(descs[i].name).append("\n");
        }
        sb.append("#]");
        return sb.toString();
    }

    // #ifdef JDK1.5
//    private <T> T ctxPeek(Stack<T> stk) {
//        return stk.peek();
//    }
    private <K, V> V descGet(Map<K, V> map, K key) {
        return map.get(key);
    }
    private <K, V> V descPut(Map<K, V> map, K key, V value) {
        return map.put(key, value);
    }
//    // #else
////    private TypeDescBldCtx ctxPeek(Stack stk) {
////        return (TypeDescBldCtx) stk.peek();
////    }
//    private TbTypeDescriptor descGet(Map map, int key) {
//        return (TbTypeDescriptor) map.get(new Integer(key));
//    }
//    private TbTypeDescriptor descPut(Map map, int key, TbTypeDescriptor value) {
//        return (TbTypeDescriptor) map.put(new Integer(key), value);
//    }
    // #endif

    public int bytesToChars(byte[] srcBytes, int srcStart, int srcLen,
                            char[] destChars, int destStart, int destLen) throws SQLException {
        return charsetMapper.bytesToChars(srcBytes, srcStart, srcLen,
                                          destChars, destStart, destLen, false);
    }

    public int bytesToNChars(byte[] srcBytes, int srcStart, int srcLen,
                             char[] destChars, int destStart, int destLen) throws SQLException {
        return nCharsetMapper.bytesToChars(srcBytes, srcStart, srcLen,
                                           destChars, destStart, destLen, false);
    }

    public byte[] castFromBigDecimal(BigDecimal data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(data.toString());

        case DataType.NUMBER:
            return fromBigDecimal(data);

        case DataType.RAW:
            return data.toString().getBytes();

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromBigDecimal(byte[] buf, int offset, BigDecimal data,
                                  int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data.toString());

        case DataType.NUMBER:
            return fromBigDecimal(buf, offset, data);

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromBoolean(boolean data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.NUMBER:
            return fromInt(data ? 1 : 0);

        case DataType.CHAR:
        case DataType.VARCHAR:
            return fromString(data ? "1" : "0");

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(data ? "1" : "0");

        case DataType.DATE:
        case DataType.LONG:
        case DataType.RAW:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int
        castFromBoolean(byte[] buf, int offset, boolean data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.NUMBER:
            return fromInt(buf, offset, data ? 1 : 0);

        case DataType.CHAR:
        case DataType.VARCHAR:
            return fromString(buf, offset, data ? "1" : "0");

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data ? "1" : "0");

        case DataType.DATE:
        case DataType.LONG:
        case DataType.RAW:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromByte(byte data, int svrType) throws SQLException {
        switch (svrType) {
        case DataType.NUMBER:
            return fromInt(data);

        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
        case DataType.RAW:
        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCHAR:
        case DataType.NVARCHAR:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromByte(byte[] buf, int offset, byte data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.NUMBER:
            return fromInt(buf, offset, data);

        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
        case DataType.RAW:
        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCHAR:
        case DataType.NVARCHAR:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromBytes(byte[] data, int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(new String(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(new String(data));

        case DataType.RAW:
            return data;

        case DataType.NUMBER:
        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromBytes(byte[] buf, int offset, byte[] data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, new String(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, new String(data));

        case DataType.RAW:
            System.arraycopy(data, 0, buf, offset, data.length);
            return data.length;

        case DataType.NUMBER:
        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromDate(byte[] buf, int offset, Date data, int svrType)
        throws SQLException {
        Calendar cal;

        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data.toString());

        case DataType.DATE:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromDate(buf, offset, cal);

        case DataType.TIMESTAMP:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTimestamp(buf, offset, cal, 0); // 0:nano second

        case DataType.TIME:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTime(buf, offset, cal, 0); // 0:nano second

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromTbDate(byte[] buf, int offset, TbDate data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data.toString());

        case DataType.TIME:
        case DataType.DATE:
            return fromTbDate(buf, offset, data);

        case DataType.TIMESTAMP:
            TbTimestamp t = new TbTimestamp(data.getYear(), data.getMonth(),
                                            data.getDayOfMonth(), data.getHourOfDay(),
                                            data.getMinutes(), data.getSeconds(), 0);
            return fromTbTimestamp(buf, offset, t);

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromDate(Date data, int svrType) throws SQLException {
        Calendar cal;

        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(data.toString());

        case DataType.DATE:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromDate(cal);

        case DataType.TIMESTAMP:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTimestamp(cal, 0); // 0:nano second

        case DataType.TIME:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTime(cal, 0); // 0:nano second

        case DataType.RAW:
            return data.toString().getBytes();

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromDouble(byte[] buf, int offset, double data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, Double.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, Double.toString(data));

        case DataType.NUMBER:
            return fromDouble(buf, offset, data);

        case DataType.RAW:
            byte[] bytes = Double.toString(data).getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.BIN_DOUBLE:
            return fromBinaryDouble(buf, offset, data);

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromDouble(double data, int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(Double.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(Double.toString(data));

        case DataType.NUMBER:
            return fromDouble(data);

        case DataType.RAW:
            return Double.toString(data).getBytes();

        case DataType.BIN_DOUBLE:
            return fromBinaryDouble(data);

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromFloat(byte[] buf, int offset, float data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, Float.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, Float.toString(data));

        case DataType.NUMBER:
            return fromFloat(buf, offset, data);

        case DataType.RAW:
            byte[] bytes = Float.toString(data).getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.BIN_FLOAT:
            return fromBinaryFloat(buf, offset, data);

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromFloat(float data, int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(Float.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(Float.toString(data));

        case DataType.NUMBER:
            return fromFloat(data);

        case DataType.RAW:
            return Float.toString(data).getBytes();

        case DataType.BIN_FLOAT:
            return fromBinaryFloat(data);

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromInt(byte[] buf, int offset, int data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, Integer.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, Integer.toString(data));

        case DataType.NUMBER:
            return fromInt(buf, offset, data);

        case DataType.RAW:
            byte[] bytes = Integer.toString(data).getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromInt(int data, int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(Integer.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(Integer.toString(data));

        case DataType.NUMBER:
            return fromInt(data);

        case DataType.RAW:
            return Integer.toString(data).getBytes();

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromLong(byte[] buf, int offset, long data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, Long.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, Long.toString(data));

        case DataType.NUMBER:
            return fromLong(buf, offset, data);

        case DataType.RAW:
            byte[] bytes = Long.toString(data).getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromLong(long data, int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(Long.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(Long.toString(data));

        case DataType.NUMBER:
            return fromLong(data);

        case DataType.RAW:
            return Long.toString(data).getBytes();

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromObject(Object data, int svrType) throws SQLException {
        if (data instanceof String)
            return castFromString((String) data, svrType);
        else if (data instanceof Boolean)
            return castFromBoolean(((Boolean) data).booleanValue(), svrType);
        else if (data instanceof Byte)
            return castFromByte(((Byte) data).byteValue(), svrType);
        else if (data instanceof byte[])
            return castFromBytes((byte[]) data, svrType);
        else if (data instanceof BigDecimal)
            return castFromBigDecimal((BigDecimal) data, svrType);
        else if (data instanceof Integer)
            return castFromInt(((Integer) data).intValue(), svrType);
        else if (data instanceof Float)
            return castFromFloat(((Float) data).floatValue(), svrType);
        else if (data instanceof Double)
            return castFromDouble(((Double) data).doubleValue(), svrType);
        else if (data instanceof Long)
            return castFromLong(((Long) data).longValue(), svrType);
        else if (data instanceof Short)
            return castFromShort(((Short) data).shortValue(), svrType);
        else if (data instanceof Date)
            return castFromDate(((Date) data), svrType);
        else if (data instanceof Time)
            return castFromTime((Time) data, svrType);
        else if (data instanceof Timestamp)
            return castFromTimestamp((Timestamp) data, svrType);
        else
            throw TbError.newSQLException(TbError.MU_BAD_DATA_FORMAT,
                                          data.toString());
    }

    public int castFromRowId(byte[] buf, int offset, String data, int svrType)
        throws SQLException {
        ServerInfo svrInfo = conn.getServerInfo();
        int endian = svrInfo.getServerEndian();

        switch (svrType) {
        case DataType.ROWID:
            if (svrInfo.getServerIsNanobase() == ServerInfo.NANOBASE_SVR)
                return new TbNrowId(conn).getServerBytes(buf, offset, endian,
                                                         data);
            else
                return new TbRowId().fromString(buf, offset, endian, data);

        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
        case DataType.NUMBER:
        case DataType.RAW:
        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.CURSOR:
        case DataType.NCHAR:
        case DataType.NVARCHAR:
        case DataType.NCLOB:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromShort(byte[] buf, int offset, short data, int svrType)
        throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, Short.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, Short.toString(data));

        case DataType.NUMBER:
            return fromShort(buf, offset, data);

        case DataType.RAW:
            byte[] bytes = Short.toString(data).getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromShort(short data, int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(Short.toString(data));

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(Short.toString(data));

        case DataType.NUMBER:
            return fromShort(data);

        case DataType.RAW:
            return Short.toString(data).getBytes();

        case DataType.DATE:
        case DataType.TIME:
        case DataType.TIMESTAMP:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromString(byte[] buf, int offset, String data, int svrType)
        throws SQLException {
        Calendar cal;

        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data);

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data);

        case DataType.NUMBER:
            BigDecimal bd = new BigDecimal(data);
            return fromBigDecimal(buf, offset, bd);

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.DATE:
            Date date = Date.valueOf(data);
            cal = Calendar.getInstance();
            cal.setTime(date);
            return fromDate(buf, offset, cal);

        case DataType.TIME:
            Time time = Time.valueOf(data);
            cal = Calendar.getInstance();
            cal.setTime(time);
            return fromTime(buf, offset, cal, 0); // 0:nano Second..

        case DataType.TIMESTAMP:
            Timestamp ts = Timestamp.valueOf(data);
            cal = Calendar.getInstance();
            cal.setTime(ts);
            return fromTimestamp(buf, offset, cal, ts.getNanos());

        case DataType.CLOB:
            return stringToFixedBytes(data, 0, data.length(), buf, offset,
                                      buf.length - offset);

        case DataType.NCLOB:
            return getDBEncodedNBytes(buf, offset, data);

        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromString(String data, int svrType) throws SQLException {
        Calendar cal;

        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(data);

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(data);

        case DataType.NUMBER:
            BigDecimal bd = new BigDecimal(data);
            return fromBigDecimal(bd);

        case DataType.RAW:
            return data.toString().getBytes();

        case DataType.DATE:
            Date date = Date.valueOf(data);
            cal = Calendar.getInstance();
            cal.setTime(date);
            return fromDate(cal);

        case DataType.TIME:
            Time time = Time.valueOf(data);
            cal = Calendar.getInstance();
            cal.setTime(time);
            return fromTime(cal, 0);

        case DataType.TIMESTAMP:
            Timestamp ts = Timestamp.valueOf(data);
            cal = Calendar.getInstance();
            cal.setTime(ts);
            return fromTimestamp(cal, ts.getNanos());

        case DataType.CLOB:
            byte[] buf = new byte[data.length() * 2];
            stringToFixedBytes(data, 0, data.length(), buf, 0, buf.length);
            return buf;

        case DataType.NCLOB:
            return getDBEncodedNBytes(data);

        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromTime(byte[] buf, int offset, Time data, int svrType)
        throws SQLException {
        Calendar cal;

        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data.toString());

        case DataType.TIME:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTime(buf, offset, cal, 0); // 0: nano second..

        case DataType.DATE:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromDate(buf, offset, cal);

        case DataType.TIMESTAMP:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTimestamp(buf, offset, cal, 0);

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromTime(Time data, int svrType) throws SQLException {
        Calendar cal;

        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(data.toString());

        case DataType.TIME:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTime(cal, 0); // 0: nano second..

        case DataType.DATE:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromDate(cal);

        case DataType.TIMESTAMP:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTimestamp(cal, 0);

        case DataType.RAW:
            return data.toString().getBytes();

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromTimestamp(byte[] buf, int offset, Timestamp data,
                                 int svrType) throws SQLException {
        Calendar cal;

        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data.toString());

        case DataType.DATE:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromDate(buf, offset, cal);

        case DataType.TIME:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTime(buf, offset, cal, data.getNanos());

        case DataType.TIMESTAMP:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTimestamp(buf, offset, cal, data.getNanos());

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public byte[] castFromTimestamp(Timestamp data, int svrType)
        throws SQLException {
        Calendar cal;

        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(data.toString());

        case DataType.DATE:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromDate(cal);

        case DataType.TIME:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTime(cal, data.getNanos());

        case DataType.TIMESTAMP:
            cal = Calendar.getInstance();
            cal.setTime(data);
            return fromTimestamp(cal, data.getNanos());

        case DataType.RAW:
            return data.toString().getBytes();

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromTbTimestamp(byte[] buf, int offset, TbTimestamp data,
                                   int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data.toString());

        case DataType.TIME:
        case DataType.DATE:
            TbDate d = new TbDate(data.getYear(), data.getMonth(),
                                  data.getDayOfMonth(), data.getHourOfDay(),
                                  data.getMinutes(), data.getSeconds());
            return fromTbDate(buf, offset, d);

        case DataType.TIMESTAMP:
            return fromTbTimestamp(buf, offset, data);

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromTbTimestampTZ(byte[] buf, int offset, TbTimestampTZ data,
                                     int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data.toString());

        case DataType.TIME:
        case DataType.DATE:
            Calendar c = Calendar.getInstance(data.getTimeZone());
            c.setTimeInMillis(data.getTime());
            TbDate d = new TbDate(c.get(Calendar.YEAR), 
                                  c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH),
                                  c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE),
                                  c.get(Calendar.SECOND));
            return fromTbDate(buf, offset, d);

        case DataType.TIMESTAMP:
            Calendar cal = Calendar.getInstance(data.getTimeZone());
            cal.setTimeInMillis(data.getTime());
            TbTimestamp t = new TbTimestamp(cal.getTimeInMillis());
            return fromTbTimestamp(buf, offset, t);
            
        case DataType.TIMESTAMP_TZ:
            return fromTbTimestampTZ(buf, offset, data);

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromTimestampLTZ(byte[] buf, int offset, Timestamp data,
                                    int svrType) throws SQLException {
        switch (svrType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.LONG:
            return fromString(buf, offset, data.toString());

        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return fromNString(buf, offset, data.toString());

        case DataType.TIME:
        case DataType.DATE:
            {
                TimeZone timezone = TimeZone.getTimeZone("UTC");
                Calendar c = Calendar.getInstance(timezone);
                c.setTimeInMillis(data.getTime());
                TbDate d = new TbDate(c.get(Calendar.YEAR), 
                                      c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH),
                                      c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE),
                                      c.get(Calendar.SECOND));
                return fromTbDate(buf, offset, d);
            }

        case DataType.TIMESTAMP_LTZ:
            {
                TimeZone timezone = TimeZone.getTimeZone("UTC");
                Calendar calLTZ = Calendar.getInstance(timezone);
                calLTZ.setTimeInMillis(data.getTime());
                TbTimestamp tsLTZ = new TbTimestamp(calLTZ.getTimeInMillis(), timezone);
                return fromTbTimestamp(buf, offset, tsLTZ);
            }

        case DataType.RAW:
            byte[] bytes = data.toString().getBytes();
            System.arraycopy(bytes, 0, buf, offset, bytes.length);
            return bytes.length;

        case DataType.NUMBER:
        case DataType.ROWID:
        case DataType.BLOB:
        case DataType.CLOB:
        case DataType.NCLOB:
        case DataType.CURSOR:
        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromTbIntervalYtm(byte[] buf, int offset,
                                     TbIntervalYtm data, int svrType) throws SQLException {
        switch (svrType) {

        case DataType.ITV_YTM:
            return fromTbIntervalYtm(buf, offset, data);

        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int castFromTbIntervalDts(byte[] buf, int offset,
                                     TbIntervalDts data, int svrType) throws SQLException {
        switch (svrType) {

        case DataType.ITV_DTS:
            return fromTbIntervalDts(buf, offset, data);

        default:
            throw TbError.newSQLException(
                    TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                    DataType.getDBTypeName(svrType));
        }
    }

    public int charsToBytes(char[] srcChars, int srcStart, int srcLen,
                            byte[] destBytes, int destStart, int destLen) throws SQLException {
        return charsetMapper.charsToBytes(srcChars, srcStart, srcLen,
                                          destBytes, destStart, destLen, false);
    }

    public int charsToFixedBytes(char[] src, int srcOff, int srcLen,
                                 byte[] dest, int destOff, int destLen) throws SQLException {
        byte highByte = 0;
        byte lowByte = 0;
        int index = destOff;

        for (int i = srcOff; i < srcOff + srcLen; i++) {
            highByte = (byte) ((src[i] >> 8) & 0xff);
            lowByte = (byte) (src[i] & 0xff);

            if (index + 1 >= destOff + destLen) {
                throw TbError
                    .newSQLException(
                            TbError.INTERNAL_FAIL_CHARSET_CONVERSION_CONVERSION_OVERFLOW,
                            (index + 1) + " >= " + destLen);
            }

            dest[index++] = highByte;
            dest[index++] = lowByte;
        }

        return index - destOff;
    }

    public int fixedBytesToChars(byte[] src, int srcOff, int srcLen,
                                 char[] dest, int destOff, int destLen) throws SQLException {
        /* destLen�� destStart�� �� ������ ���� ���̸� ���� */
        int j = destOff;

        if ((srcLen % 2) != 0) {
            throw TbError
                .newSQLException(
                        TbError.INTERNAL_FAIL_CHARSET_CONVERSION_INVALID_UCS2_ARRAY,
                        srcLen);
        }

        for (int i = srcOff; i < srcOff + srcLen; i += 2) {
            if (j >= destOff + destLen) {
                throw TbError
                    .newSQLException(
                            TbError.INTERNAL_FAIL_CHARSET_CONVERSION_CONVERSION_OVERFLOW,
                            j + " >= " + destOff + " + " + destLen);
            }

            dest[j++] =
                (char) ((short) ((src[i] << 8) & 0xffff) + (short) (src[i + 1] & 0xff));
        }

        return j - destOff;
    }

    private byte[] fromBigDecimal(BigDecimal x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromBigDecimal",
                            new Object[] { x });
        }

        return TbNumber.fromString(x.toString());
    }

    public int fromBigDecimal(byte[] buf, int offset, BigDecimal x)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromBigDecimal",
                            new Object[] { x });
        }

        return TbNumber.fromString(buf, offset, x.toString());
    }

    public int fromDate(byte[] buf, int offset, Calendar x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromDate", new Object[] { x });
        }

        int year = x.get(Calendar.YEAR);

        buf[offset] = (byte) (year / 100 + 100);
        buf[offset + 1] = (byte) (year % 100 + 100);
        buf[offset + 2] = (byte) (x.get(Calendar.MONTH) + 1);
        buf[offset + 3] = (byte) x.get(Calendar.DATE);

        if (x.get(Calendar.AM_PM) == Calendar.AM)
            buf[offset + 4] = (byte) x.get(Calendar.HOUR);
        else
            buf[offset + 4] = (byte) (x.get(Calendar.HOUR) + 12);

        buf[offset + 5] = (byte) x.get(Calendar.MINUTE);
        buf[offset + 6] = (byte) x.get(Calendar.SECOND);
        buf[offset + 7] = 0;

        return DBConst.TB_DATE_SIZE;
    }

    private byte[] fromDate(Calendar x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromDate", new Object[] { x });
        }

        byte[] date = new byte[DBConst.TB_DATE_SIZE];
        int year = x.get(Calendar.YEAR);

        date[0] = (byte) (year / 100 + 100);
        date[1] = (byte) (year % 100 + 100);
        date[2] = (byte) (x.get(Calendar.MONTH) + 1);
        date[3] = (byte) x.get(Calendar.DATE);

        if (x.get(Calendar.AM_PM) == Calendar.AM)
            date[4] = (byte) x.get(Calendar.HOUR);
        else
            date[4] = (byte) (x.get(Calendar.HOUR) + 12);

        date[5] = (byte) x.get(Calendar.MINUTE);
        date[6] = (byte) x.get(Calendar.SECOND);

        return date;
    }

    public int fromTbDate(byte[] buf, int offset, TbDate date) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTbDate",
                            new Object[] { date });
        }

        System.arraycopy(date.getBytes(), 0, buf, offset, DBConst.TB_DATE_SIZE);

        return DBConst.TB_DATE_SIZE;
    }

    public int fromDouble(byte[] buf, int offset, double x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromDouble",
                            new Object[] { Double.toString(x) });
        }

        return TbNumber.fromString(buf, offset, Double.toString(x));
    }

    private byte[] fromDouble(double x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromDouble",
                            new Object[] { Double.toString(x) });
        }

        return TbNumber.fromString(Double.toString(x));
    }

    public int fromFloat(byte[] buf, int offset, float x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromFloat",
                            new Object[] { Float.toString(x) });
        }

        return TbNumber.fromString(buf, offset, Float.toString(x));
    }

    private byte[] fromFloat(float x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromFloat",
                            new Object[] { Float.toString(x) });
        }

        return TbNumber.fromString(Float.toString(x));
    }

    public int fromBinaryDouble(byte[] buf, int offset, double x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromBinaryDouble",
                    new Object[] { Long.toHexString(Double.doubleToLongBits(x)) });
        }

        return convertDouble2Bytes(buf, offset, x);
    }

    public byte[] fromBinaryDouble(double x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromBinaryDouble",
                            new String[] {"binary_double"},
                            new Object[] {Long.toHexString(Double.doubleToLongBits(x))});
        }

        byte[] ret = new byte[8];
        convertDouble2Bytes(ret, 0, x);

        return ret;
    }

    private int convertDouble2Bytes(byte[] buf, int offset, double x) {
        long longBits;
        int doubleSize = 8;

        if (Double.compare(x, Double.NaN) == 0) {
            buf[offset] = (byte) 0xff;
            buf[offset + 1] = (byte) 0xf8;
            buf[offset + 2] = 0x00;
            buf[offset + 3] = 0x00;
            buf[offset + 4] = 0x00;
            buf[offset + 5] = 0x00;
            buf[offset + 6] = 0x00;
            buf[offset + 7] = 0x00;
        } else if (Double.compare(x, -0d) == 0
                   || Double.compare(x, 0d) == 0) {
            buf[offset] = (byte) 0x80;
            buf[offset + 1] = 0x00;
            buf[offset + 2] = 0x00;
            buf[offset + 3] = 0x00;
            buf[offset + 4] = 0x00;
            buf[offset + 5] = 0x00;
            buf[offset + 6] = 0x00;
            buf[offset + 7] = 0x00;
        } else if (x > 0) {
            x *= -1;
            longBits = Double.doubleToRawLongBits(x);
            TbCommon.long2Bytes(longBits, buf, offset, doubleSize);
        } else if (x < 0) {
            longBits = Double.doubleToRawLongBits(x);
            longBits = ~longBits;
            TbCommon.long2Bytes(longBits, buf, offset, doubleSize);
        } else {
            longBits = Double.doubleToRawLongBits(x);
            TbCommon.long2Bytes(longBits, buf, offset, doubleSize);
        }

        return doubleSize;
    }

    public int fromBinaryFloat(byte[] buf, int offset, float x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromBinaryFloat",
                    new Object[] { Long.toHexString(Float.floatToIntBits(x)) });
        }

        return convertFloat2Bytes(buf, offset, x);
    }

    public byte[] fromBinaryFloat(float x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromBinaryFloat",
                            new String[] {"binary_float"},
                            new Object[] {Long.toHexString(Float.floatToIntBits(x))});
        }

        byte[] ret = new byte[4];
        convertFloat2Bytes(ret, 0, x);

        return ret;
    }

    private int convertFloat2Bytes(byte[] buf, int offset, float x) {
        int intBits;
        int floatSize = 4;

        if (Float.compare(x, Float.NaN) == 0) {
            buf[offset] = (byte) 0xff;
            buf[offset + 1] = (byte) 0xc0;
            buf[offset + 2] = 0x00;
            buf[offset + 3] = 0x00;
        } else if (Float.compare(x, -0f) == 0
                   || Float.compare(x, 0f) == 0) {
            buf[offset] = (byte) 0x80;
            buf[offset + 1] = 0x00;
            buf[offset + 2] = 0x00;
            buf[offset + 3] = 0x00;
        } else if (x > 0) {
            x *= -1;
            intBits = Float.floatToRawIntBits(x);
            TbCommon.int2Bytes(intBits, buf, offset, floatSize);
        } else if (x < 0) {
            intBits = Float.floatToRawIntBits(x);
            intBits = ~intBits;
            TbCommon.int2Bytes(intBits, buf, offset, floatSize);
        } else {
            intBits = Float.floatToRawIntBits(x);
            TbCommon.int2Bytes(intBits, buf, offset, floatSize);
        }

        return floatSize;
    }

    public int fromInt(byte[] buf, int offset, int x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromInt",
                            new Object[] { Integer.toString(x) });
        }

        return TbNumber.fromInteger(buf, offset, x);
    }

    private byte[] fromInt(int x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromInt",
                            new Object[] { Integer.toString(x) });
        }

        return TbNumber.fromInteger(x);
    }

    public int fromLong(byte[] buf, int offset, long x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromLong",
                            new Object[] { Long.toString(x) });
        }

        return TbNumber.fromLong(buf, offset, x);
    }

    private byte[] fromLong(long x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromLong",
                            new Object[] { Long.toString(x) });
        }

        return TbNumber.fromLong(x);
    }

    public int fromNString(byte[] buf, int offset, String x)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromNString", new Object[] { x });
        }

        return getDBEncodedNBytes(buf, offset, x);
    }

    private byte[] fromNString(String x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromNString", new Object[] { x });
        }

        return getDBEncodedNBytes(x);
    }

    public int fromShort(byte[] buf, int offset, short x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromShort",
                            new Object[] { Short.toString(x) });
        }

        return fromInt(buf, offset, x);
    }

    private byte[] fromShort(short x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromShort",
                            new Object[] { Short.toString(x) });
        }

        return fromInt(x);
    }

    public int fromString(byte[] buffer, int offset, String x)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromString", new Object[] { x });
        }

        return getDBEncodedBytes(buffer, offset, x);
    }

    public byte[] fromString(String x) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromString", new Object[] { x });
        }

        return getDBEncodedBytes(x);
    }

    public int fromTime(byte[] buf, int offset, Calendar cal, int nanoSec)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTime", new Object[] { cal });
        }

        int hour = cal.get(Calendar.HOUR);

        if (cal.get(Calendar.AM_PM) == Calendar.PM)
            hour += 12;

        buf[offset] = (byte) hour;
        buf[offset + 1] = (byte) cal.get(Calendar.MINUTE);
        buf[offset + 2] = (byte) cal.get(Calendar.SECOND);
        buf[offset + 3] = (byte) 0;
        // copy nano second
        TbCommon.int2Bytes(nanoSec, buf, offset + 4, 4);

        return DBConst.TB_TIME_SIZE;
    }

    private byte[] fromTime(Calendar cal, int nanoSec) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTime", new Object[] { cal });
        }

        byte[] time = new byte[DBConst.TB_TIME_SIZE];
        int hour = cal.get(Calendar.HOUR);

        if (cal.get(Calendar.AM_PM) == Calendar.PM)
            hour += 12;

        time[0] = (byte) hour;
        time[1] = (byte) cal.get(Calendar.MINUTE);
        time[2] = (byte) cal.get(Calendar.SECOND);
        time[3] = (byte) 0;
        // copy nano second
        TbCommon.int2Bytes(nanoSec, time, 4, 4);

        return time;
    }

    public int fromTimestamp(byte[] buf, int offset, Calendar cal, int nanoSec)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTimestamp",
                            new Object[] { cal });
        }

        int year = cal.get(Calendar.YEAR);// + 1900;
        int hour = cal.get(Calendar.HOUR);

        if (cal.get(Calendar.AM_PM) == Calendar.PM)
            hour += 12;

        buf[offset] = (byte) (year / 100 + 100);
        buf[offset + 1] = (byte) (year % 100 + 100);
        buf[offset + 2] = (byte) (cal.get(Calendar.MONTH) + 1);
        buf[offset + 3] = (byte) cal.get(Calendar.DATE);
        buf[offset + 4] = (byte) hour;
        buf[offset + 5] = (byte) cal.get(Calendar.MINUTE);
        buf[offset + 6] = (byte) cal.get(Calendar.SECOND);
        buf[offset + 7] = 0;
        // copy nano second
        TbCommon.int2Bytes(nanoSec, buf, offset + 8, 4);

        return DBConst.TB_TIMESTAMP_SIZE;
    }

    public int fromTimestampTZ(byte[] buf, int offset, Calendar cal,
                               int nanoSec, TimeZone timezone) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTimestamp",
                            new Object[] { cal });
        }

        int year = cal.get(Calendar.YEAR);// + 1900;
        int hour = cal.get(Calendar.HOUR);

        if (cal.get(Calendar.AM_PM) == Calendar.PM)
            hour += 12;

        buf[offset] = (byte) (year / 100 + 100);
        buf[offset + 1] = (byte) (year % 100 + 100);
        buf[offset + 2] = (byte) (cal.get(Calendar.MONTH) + 1);
        buf[offset + 3] = (byte) cal.get(Calendar.DATE);
        buf[offset + 4] = (byte) hour;
        buf[offset + 5] = (byte) cal.get(Calendar.MINUTE);
        buf[offset + 6] = (byte) cal.get(Calendar.SECOND);
        buf[offset + 7] = 0;
        // copy nano second
        TbCommon.int2Bytes(nanoSec, buf, offset + 8, 4);

        String timezoneName = timezone.getID();
        int zoneID = ZoneInfo.getTimeZoneIdByName(timezoneName);

        // timezone
        int zoneOffset = timezone.getOffset(cal.getTimeInMillis());

        zoneOffset /= 1000;
        int utcSecond = zoneOffset % 60;
        int utcMinute = (zoneOffset / 60) % 60;
        int utcHour = zoneOffset / 3600;

        buf[offset + 12] = (byte) ((0xff & utcHour) + 100);
        buf[offset + 13] = (byte) (0xff & utcMinute);
        buf[offset + 14] = (byte) (0xff & utcSecond);
        TbCommon.int2Bytes(zoneID, buf, offset + 15, 2);

        return DBConst.TB_TS_TZ_SIZE;
    }

    private byte[] fromTimestamp(Calendar cal, int nanoSec) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTimestamp",
                            new Object[] { cal });
        }

        byte[] ts = new byte[DBConst.TB_TIMESTAMP_SIZE];
        int year = cal.get(Calendar.YEAR);// + 1900;
        int hour = cal.get(Calendar.HOUR);

        if (cal.get(Calendar.AM_PM) == Calendar.PM)
            hour += 12;

        ts[0] = (byte) (year / 100 + 100);
        ts[1] = (byte) (year % 100 + 100);
        ts[2] = (byte) (cal.get(Calendar.MONTH) + 1);
        ts[3] = (byte) cal.get(Calendar.DATE);
        ts[4] = (byte) hour;
        ts[5] = (byte) cal.get(Calendar.MINUTE);
        ts[6] = (byte) cal.get(Calendar.SECOND);
        // copy nano second
        TbCommon.int2Bytes(nanoSec, ts, 8, 4);

        return ts;
    }

    public int fromTbTimestamp(byte[] buf, int offset, TbTimestamp timestamp)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTbTimestamp",
                    new Object[] { timestamp });
        }

        System.arraycopy(timestamp.getBytes(), 0, buf, offset,
                DBConst.TB_TIMESTAMP_SIZE);

        return DBConst.TB_TIMESTAMP_SIZE;
    }

    public int fromTbTimestampTZ(byte[] buf, int offset, TbTimestampTZ tstz)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTbTimestampTZ",
                            new Object[] { tstz });
        }
        
        Calendar cal = Calendar.getInstance(ZoneInfo.TZ_UTC);
        cal.setTimeInMillis(tstz.getTime());
        
        return fromTimestampTZ(buf, offset, cal, tstz.getNanos(),
                               tstz.getTimeZone());
    }

    public int fromTbIntervalYtm(byte[] buf, int offset, TbIntervalYtm x)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTbIntervalYtm",
                            new Object[] { x });
        }

        System.arraycopy(x.getBytes(), 0, buf, offset,
                         TbIntervalYtm.TB_INTERVAL_YTM_SIZE);

        return TbIntervalYtm.TB_INTERVAL_YTM_SIZE;
    }

    public int fromTbIntervalDts(byte[] buf, int offset, TbIntervalDts x)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.fromTbIntervalDts",
                            new Object[] { x });
        }

        System.arraycopy(x.getBytes(), 0, buf, offset,
                         TbIntervalDts.TB_INTERVAL_DTS_SIZE);

        return TbIntervalDts.TB_INTERVAL_DTS_SIZE;
    }

    private String getDBDecodedNString(byte[] bytes, int offset, int length)
        throws SQLException {
        return nCharsetMapper.bytesToString(bytes, offset, length, false);
    }

    public String getDBDecodedString(byte[] bytes, int offset, int length)
        throws SQLException {
        return charsetMapper.bytesToString(bytes, offset, length, false);
    }

    private int getDBEncodedBytes(byte[] buffer, int offset, String msg)
        throws SQLException {
        return charsetMapper.stringToBytes(buffer, offset, msg);
    }

    public byte[] getDBEncodedBytes(String msg) throws SQLException {
        return charsetMapper.stringToBytes(msg);
    }

    private int getDBEncodedNBytes(byte[] buf, int offset, String msg)
        throws SQLException {
        return nCharsetMapper.stringToBytes(buf, offset, msg);
    }

    private byte[] getDBEncodedNBytes(String msg) throws SQLException {
        return nCharsetMapper.stringToBytes(msg);
    }

    public int getEndingBytePos(byte[] srcBytes, int offset) {
        return charsetMapper.getEndingBytePos(srcBytes, offset);
    }

    public int getEndingBytePosNCharset(byte[] srcBytes, int offset) {
        return nCharsetMapper.getEndingBytePos(srcBytes, offset);
    }

    public int getLeadingBytePos(byte[] srcBytes, int offset) {
        return charsetMapper.getLeadingBytePos(srcBytes, offset);
    }

    public int getLeadingBytePosNCharset(byte[] srcBytes, int offset) {
        return nCharsetMapper.getLeadingBytePos(srcBytes, offset);
    }

    public int getMaxBytesPerChar() {
        return charsetMapper.getMaxBytesPerChar();
    }

    public int getMaxBytesPerNChar() {
        return nCharsetMapper.getMaxBytesPerChar();
    }

    public int getUCS2MaxBytesPerChar() {
        return 2;
    }

    public boolean isEndingByte(byte[] srcBytes, int offset) {
        return charsetMapper.isEndingByte(srcBytes, offset);
    }

    public boolean isEndingByteNCharset(byte[] srcBytes, int offset) {
        return nCharsetMapper.isEndingByte(srcBytes, offset);
    }

    public boolean isLeadingByte(byte[] srcBytes, int offset) {
        return charsetMapper.isLeadingByte(srcBytes, offset);
    }

    public boolean isLeadingByteNCharset(byte[] srcBytes, int offset) {
        return nCharsetMapper.isLeadingByte(srcBytes, offset);
    }

    public int nCharsToBytes(char[] srcChars, int srcStart, int srcLen,
                             byte[] destBytes, int destStart, int destLen) throws SQLException {
        return nCharsetMapper.charsToBytes(srcChars, srcStart, srcLen,
                                           destBytes, destStart, destLen, false);
    }

    public void reset() {
        charsetMapper = null;
        nCharsetMapper = null;
        conn = null;
    }

    public void setCharset(int charset, int nCharset) throws SQLException {

        // IMS 117777. SJISTILDE charset�� ���� ��ȸ ����
        if (charset == Charset.SJISTILDE) {
            charset = Charset.JA16SJIS_TILDE;
        }

        if (nCharset == Charset.SJISTILDE) {
            nCharset = Charset.JA16SJIS_TILDE;
        }

        // IMS 131943
        if ((charset == Charset.ZHT16BIG5) || charset == Charset.ZHT16MSWIN950) {
            charset = Charset.MSWIN950;
        }

        if ((nCharset == Charset.ZHT16BIG5) || nCharset == Charset.ZHT16MSWIN950) {
            nCharset = Charset.MSWIN950;
        }
        charsetMapper = new CharsetMapper(charset);
        nCharsetMapper = new CharsetMapper(nCharset);
    }

    private int stringToFixedBytes(String src, int srcOff, int srcLen,
                                   byte[] dest, int destOff, int destLen) throws SQLException {
        byte highByte = 0;
        byte lowByte = 0;
        int index = destOff;

        for (int i = srcOff; i < srcLen; i++) {
            highByte = (byte) ((src.charAt(i) >> 8) & 0xff);
            lowByte = (byte) (src.charAt(i) & 0xff);

            if (index + 1 >= destLen) {
                throw TbError
                    .newSQLException(
                            TbError.INTERNAL_FAIL_CHARSET_CONVERSION_CONVERSION_OVERFLOW,
                            (index + 1) + " >= " + destLen);
            }

            dest[index++] = highByte;
            dest[index++] = lowByte;
        }

        return index - destOff;
    }

    public Object toStruct(Object x, int offset, int length, int dataType,
                           boolean freeTmpLobOnEOF, TbStructDescriptor desc,
                           // #ifdef JDK1.5
                           Class<?> clazz, Map<String, Class<?>> typeMap)
//                           // #else
//                           Class clazz, Map typeMap)
                           // #endif
                                   throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toStruct", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType),
            });
        }
        
        if (length <= 0 || x == null)
            return null;
        
        byte[] b;
        int off;
        if (dataType != DataType.OBJECT && dataType != DataType.RECORD)
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          DataType.getDBTypeName(dataType));

        if (desc == null)
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "obj_desc null");

        if (!(x instanceof byte[]))
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "inst=" + x.toString());

        b = (byte[]) x;
        if (b.length > offset + RPCOL_UDT_MIN_SIZE &&
                b[offset] == RPCOL_UDT_OBJ) {
            off = offset;
        }
        else if (b.length > offset + 5 && length > 5) {
            /*
             * deserialize from lob.
             * Empty lob�� �ƴ� �̻� �ּ� 6byte�̻��� �ƴϸ� TbLob ������ ���� �߻��� �� �ִ�.
             * �����δ� ���� �׻� 96byte�� ��������, jdbc���� locator�� ���� ���̳ʸ� �����ʹ�
             * ���� �������� �����Ƿ� ���⼭�� �ּұ��̸����� �˻��Ѵ�.
             */
            byte[] locator = new byte[length];
            System.arraycopy(b, offset, locator, 0, length);
            TbBlob blob = new TbBlob(conn, locator, true);
            /*
             * subrp�� Lob�� ���, length��û�� �����ϰ� �ܼ��ϰ� ���̷� int max�� ����Ͽ�
             * �����͸� ��û�� ���� �ִ�. �׷��� �� ��쿡�� TbBlob.getBytes(long, int) ������
             * ������ length��ŭ new byte[]�� �Ҵ��ϴ� �κж����� �޸𸮸� �����ϰ� ����ϰ� �Ǿ�
             * OutOfMemoryError�� �߻��� ������ �ִ�.
             * �� ���������� length�� ȣ���� �����κ��� ���̸� �޾ƿ��� ������� �Ͽ���.
             */
            long lobLen = blob.length();
            if (lobLen > Integer.MAX_VALUE) { // 1-3-5 system���� maxsize�� int max.
                throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                              "rp(lob) len=" + lobLen);
            }
            b = blob.getBytes(1L, (int) lobLen);
            int readLen = (b == null) ? 0 : b.length;
            if (readLen < RPCOL_UDT_MIN_SIZE)
                throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                              "udt_lob_len=" + readLen);
            else if (b[0] != RPCOL_UDT_OBJ)
                throw TbError
                        .newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                         "udt_rpflag=0x" + Integer
                                                 .toHexString(0xff & b[0]));

            off = 0;
        }
        else
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());

        boolean isRoot;
        if (b[off + 1] == RPCOL_UDT_ROOT)
            isRoot = true;
        else if (b[off + 1] == RPCOL_UDT_SUBTYPE)
            isRoot = false;
        else
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "udt_inherit=0x" +
                                                  Integer.toHexString(0xff &
                                                          b[off + 1]));

        off += 2; // 2bytes magic number.
        TbStructDescriptor realDesc = desc;

        // check isFinal
        if (!(b[off] != RPCOL_UDT_NOT_FINAL[0] || b.length < off + 4 ||
                b[off + 1] != RPCOL_UDT_NOT_FINAL[1] ||
                b[off + 2] != RPCOL_UDT_NOT_FINAL[2] ||
                b[off + 3] != RPCOL_UDT_NOT_FINAL[3]))
            off += RPCOL_UDT_NOT_FINAL.length;

        // check protocol
        if (conn.serverInfo.getProtocolMajorVersion() >= 2 && conn.serverInfo.getProtocolMinorVersion() >=16){
            RPCOL_NULLOBJ=(byte)251;
            RPCOL_5BYTE=(byte)253;
        } else {
            RPCOL_NULLOBJ=(byte)253;
            RPCOL_5BYTE=(byte)251;
        }

        // read rplen
        int rplen = (int) (b[off] & 0xff);
        if (rplen <= DBConst.RPCOL_1BYTE) {
            // 1st byte value is length
            off += 1;
        }
        else if (rplen == DBConst.RPCOL_LARGE) {
            rplen = TbCommon.bytes2Int(b, off + 1, 2);
            off += 3;
        }
        else if ((byte)rplen == DataTypeConverter.RPCOL_5BYTE /* XXX: RPCOL_5BYTE */) {
            rplen = TbCommon.bytes2Int(b, off + 1, 4);
            off += 5;
        }
        else
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "udt_rplen=0x" + Integer
                                                  .toHexString(rplen));

        if (!isRoot) {
            // read OID (raw) of subtype

            int oidRpLen = 0xff & b[off]; // always 1 byte
            byte[] rawOID = toBytes(b, off + 1, oidRpLen, DataType.RAW,
                                    freeTmpLobOnEOF);
            off += 1 + oidRpLen;

            final char[] hexCode = "0123456789ABCDEF".toCharArray();
            // #ifdef JDK1.5
            StringBuilder sb = new StringBuilder(oidRpLen * 2);
//            // #else
//                StringBuffer sb = new StringBuffer(oidRpLen * 2);
            // #endif
            for (int i = 0; i < oidRpLen; i++) {
                sb.append(hexCode[(rawOID[i] >> 4) & 0xF]);
                sb.append(hexCode[(rawOID[i] & 0xF)]);
            }
            String hexEncodedOID = sb.toString();
            try {
                realDesc = TbStructDescriptor
                        .createDescriptor(dataType, hexEncodedOID, conn);
            }
            catch (SQLException e) {
                throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                              e);
            }
        }

        // #ifdef JDK1.5
        LinkedList<ObjInstBldCtx> llCtx = new LinkedList<ObjInstBldCtx>();
//        // #else
//            LinkedList llCtx = new LinkedList();
        // #endif
        ObjInstBldCtx cur = new ObjInstBldCtx(realDesc);

        while (true) {
            /* sub row piece�� ���� �о� Null ���� �� Ÿ�� Ȯ��. */
            int objGrpDepth = 0;
            int nullObjGrpDepth = 0;
            int subRpLen = 0;
            switch (b[off]) {
            case (byte) 252: /* 0xFC means RPCOL_NULLOBJ_W_DEPTH: object group�� �߰� node */
                nullObjGrpDepth = (int) (0xff & b[off + 1]);
                off += 2;
                break;

            case 0: /* NULL: leaf node */
                nullObjGrpDepth = Integer.MAX_VALUE;
                off++;
                break;

            default: /* row piece with value. leaf node */

                if (b[off]==RPCOL_NULLOBJ){ /* RPCOL_NULLOBJ: object group�� top node */
                    off++;
                    break;
                }

                subRpLen = (int) (b[off] & 0xff);
                if (subRpLen <= DBConst.RPCOL_1BYTE) {
                    // 1st byte value is length
                    off++;
                }
                else if (subRpLen == DBConst.RPCOL_LARGE) {
                    subRpLen = TbCommon.bytes2Int(b, off + 1, 2);
                    off += 3;
                }
                else if ((byte)subRpLen == DataTypeConverter.RPCOL_5BYTE /* XXX: RPCOL_5BYTE */) {
                    subRpLen = TbCommon.bytes2Int(b, off + 1, 4);
                    off += 5;
                }
                else
                    throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                                  "subRpLen=" + subRpLen);

                /*
                // NUMBER Ÿ���� ���, offset�� �������ش�.
                if (cur.desc.getAttributeTypes()[cur.attrProcessed] == DataType.NUMBER) {
                    off--;
                    subRpLen++;
                }
                */
            }

            /*
             * Value Tree�� Leaf�� �ƴ϶�� Meta Tree�� child�� �̵��Ѵ�.
             * 
             * Leaf Value�� �Ǵ� ���� ������ ����
             * - Attribute�� Ÿ���� primitive Ÿ���� ���
             * - Attribute�� Ÿ���� Collection �� ���
             * - Attribute�� Ÿ���� Object�̸鼭 ���� row piece�� null�� ���
             * - Attribute�� Ÿ���� Object�̸鼭 NOT FINAL�� ���
             * 
             */
            while (cur.desc.getAttributeTypes()[cur.attrProcessed] == DataType.OBJECT
                    && (subRpLen != 0 || objGrpDepth < nullObjGrpDepth)) {
                /*
                 * JDBC�󿡼� ����loop ���ɼ��ִ� ��ȯ���� ���� �˻�.
                 *   1st-child�θ� ����� path ��λ� Ÿ�� ���ǰ� �ߺ��Ǿ� ��Ÿ���� ���,
                 *   ���� rp�� ��Ī�� Object Tree leaf�� Ȯ���� �� ����.
                 * 
                 * cf. ��ȯ�����̴��� 1st-child�θ� ����� path�� �ƴ϶��, 
                 *   ���� attribute�� ���� �����Ͱ� �����ؾ� �ϰ� �ǹǷ�,  
                 *   next row piece�� �ش��ϴ� leaf node�� Ư���ϴ� ���� ����.
                 */ 
                String attrTypeName = cur.desc.getAttributeTypeNames()[cur.attrProcessed];
                String attrOID = cur.desc.getAttributeOIDs()[cur.attrProcessed];
                for (Iterator
                        // #ifdef JDK1.5
                        <ObjInstBldCtx>
                        // #endif
                        iter = llCtx.iterator(); iter.hasNext();) {
                    ObjInstBldCtx ctx = (ObjInstBldCtx) iter.next();
                    if (ctx.attrProcessed > 0)
                        break;
                    if ((attrTypeName != null &&
                            attrTypeName.equalsIgnoreCase(
                                                          ctx.desc.getSQLTypeName()) ||
                            (attrOID != null && attrOID
                                    .equalsIgnoreCase(ctx.desc.getOID())))) {
                        throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                                      b.toString());
                    }
                }

                Object attrDescObj = null;
                if (attrOID != null) {
                    attrDescObj = conn.getDescriptor(_DESC_OID_PREFIX + attrOID);
                    if (attrDescObj == null)
                        attrDescObj = TbStructDescriptor
                                .createDescriptor(DataType.OBJECT, attrOID,
                                                  conn);
                }
                if (attrDescObj == null && attrTypeName != null) {
                    attrDescObj = conn.getDescriptor(attrTypeName);
                    if (attrDescObj == null) {
                        attrDescObj = TbStructDescriptor
                                .createDescriptor(attrTypeName, conn);
                    }
                }
                if (attrDescObj == null)
                    throw TbError
                            .newSQLException(TbError.MU_UDT_NOT_EXIST,
                                             "parent=" +
                                                     cur.desc.getSQLTypeName() +
                                                     ", attrIdx=" +
                                                     cur.attrProcessed +
                                                     ", attr=" + attrTypeName +
                                                     ", attrOID=" + attrOID);

                /*
                 * Meta tree�� child�� �̵��ϱ� ���� ���� ctx�� stack�� �ְ�
                 * cur ���� child object�� ������ ����
                 */
                if (attrDescObj instanceof TbStructDescriptor &&
                        ((TbStructDescriptor) attrDescObj).isFinal()) {
                    TbStructDescriptor attrDesc = (TbStructDescriptor) attrDescObj;
                    ObjInstBldCtx newCtx = new ObjInstBldCtx(attrDesc);
                    llCtx.addFirst(cur); // push()
                    cur = newCtx;
                    objGrpDepth++;
                }
                else {
                    break;
                }
            }

            // rp�� �����Ǵ� ��ġ - Leaf node or Null Object
            int attrDataType = cur.desc.getAttributeTypes()[cur.attrProcessed];
            int attrSqlType = DataType.getSqlType(attrDataType);
            String attrTypeName = cur.desc.getAttributeTypeNames()[cur.attrProcessed];
            String attrOID = cur.desc.getAttributeOIDs()[cur.attrProcessed];
            Object descObj = null;
            switch (attrDataType) {
            case DataType.VARRAY:
            case DataType.TABLE:
            case DataType.IDX_BY_TBL:
                if (attrOID != null) {
                    if ((descObj = conn.getDescriptor(attrOID)) == null) {
                        descObj = TbArrayDescriptor
                                .createDescriptor(attrDataType, attrOID, conn);
                    }
                }
                if (descObj == null && attrTypeName != null) {
                    if ((descObj = conn.getDescriptor(attrTypeName)) == null) {
                        descObj = TbArrayDescriptor
                                .createDescriptor(attrTypeName, conn);
                    }
                }
                if (descObj == null)
                    throw TbError
                            .newSQLException(TbError.MU_UDT_NOT_EXIST,
                                             "parent=" +
                                                     cur.desc.getSQLTypeName() +
                                                     ", attrIdx=" +
                                                     cur.attrProcessed +
                                                     ", attr=" + attrTypeName +
                                                     ", attrOID=" + attrOID);

                break;
            case DataType.RECORD:
            case DataType.OBJECT:
                if (attrOID != null) {
                    if ((descObj = conn.getDescriptor(attrOID)) == null) {
                        descObj = TbStructDescriptor
                                .createDescriptor(attrDataType, attrOID, conn);
                    }
                }
                if (descObj == null && attrTypeName != null) {
                    if ((descObj = conn.getDescriptor(attrTypeName)) == null) {
                        descObj = TbStructDescriptor
                                .createDescriptor(attrTypeName, conn);
                    }
                }
                if (descObj == null)
                    throw TbError
                            .newSQLException(TbError.MU_UDT_NOT_EXIST,
                                             "parent=" +
                                                     cur.desc.getSQLTypeName() +
                                                     ", attrIdx=" +
                                                     cur.attrProcessed +
                                                     ", attr=" + attrTypeName +
                                                     ", attrOID=" + attrOID);
                break;
            }

            if (descObj instanceof TbArrayDescriptor) {
                TbArrayDescriptor attrArrDesc = (TbArrayDescriptor) descObj;
                cur.values[cur.attrProcessed] =
                        toArray(b, off, subRpLen, attrDataType, freeTmpLobOnEOF,
                                attrArrDesc, typeMap);
            }
            else if (descObj instanceof TbStructDescriptor) {
                /*
                 * XXX: Struct deserialize �� Leaf���� �ٽ� Struct�� ���� �ִ��� ���̽� �м� �ʿ�.
                 *  Lob wrapping object ���̽��� object Ʈ�� �߰����� ���� �� �ִ��� ���� Ȯ�� �ʿ�
                 */
                TbStructDescriptor attrStDesc = (TbStructDescriptor) descObj;
                cur.values[cur.attrProcessed] =
                        toStruct(b, off, subRpLen, attrDataType,
                                 freeTmpLobOnEOF, attrStDesc, null, typeMap);
            }
            else {
                // NUMBER Ÿ���� ���, offset�� �������ش�.
                if (cur.desc.getAttributeTypes()[cur.attrProcessed] == DataType.NUMBER) {
                    if(subRpLen > 0) {
                        off--;
                        subRpLen++;
                    }
                }
                cur.values[cur.attrProcessed] =
                        toObject(b, off, subRpLen, attrDataType, attrSqlType,
                                 freeTmpLobOnEOF);
            }
            cur.attrProcessed++;
            off += subRpLen;
            objGrpDepth = 0;

            /*
             * ���� ���(ctx)������ ��� attribute�� ó���� �����ٸ� Struct (or SQLData)��
             * instance�� �����ϰ�, parent node�� attribute�� assign���ش�.
             * ���� ���� row piece�� �о���̱� ����, attribute���� ��� ó������ ���� ���� node����
             * Ʈ���� �Ž��� �ö�, ���� row piece�� �ش��ϴ� ��ġ�� �̵��Ѵ�.
             * root������ ��� attribute���� ä�����ٸ� root�� �ش��ϴ� instance�� �����Ͽ� return�Ѵ�.
             */
            while (cur.values.length <= cur.attrProcessed) {
                // gen object
                TbStruct newStruct = new TbStruct(cur.desc, conn, cur.values);

                Object newClsInstOrStruct = null;
                boolean isRootNode = llCtx.isEmpty();
                if (newStruct != null) {
                    if (isRootNode && clazz != null)
                        newClsInstOrStruct = newStruct.toClass(clazz, typeMap);
                    else
                        newClsInstOrStruct = newStruct.toClass(typeMap);
                }

                // root node
                if (isRootNode) {
                    return newClsInstOrStruct;
                }
                else {
                    ObjInstBldCtx parent = (ObjInstBldCtx) llCtx.removeFirst(); // pop()
                    parent.values[parent.attrProcessed++] = newClsInstOrStruct;
                    cur = parent;
                }
            }
        }
    }

    public Array toArray(Object x, int offset, int length, int dataType,
                         boolean freeTmpLobOnEOF, TbArrayDescriptor desc, Map
                         // #ifdef JDK1.5
                         <String, Class<?>>
                         // #endif
                         typeMap) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toArray", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType),
            });
        }

        if (length <= 0 || x == null)
            return null;

        byte[] b;
        int off;
        if (!(x instanceof byte[]))
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "inst=" + x.toString());

        if (dataType != DataType.VARRAY && dataType != DataType.TABLE &&
                dataType != DataType.IDX_BY_TBL)
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          DataType.getDBTypeName(dataType));

        if (desc == null)
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "arr_desc=null");

        b = (byte[]) x;
        // �ι�° byte�� RPCOL_UDT_ROOT ����. COLLECTION Ÿ���� ����� ������� �ʴ´�.
        if (b.length > offset + RPCOL_UDT_MIN_SIZE &&
                b[offset] == RPCOL_UDT_COLL &&
                b[offset + 1] == RPCOL_UDT_ROOT) {
            off = offset + 2; // 2bytes magic number.
        }
        else if (b.length > offset + 5) {
            /*
             * deserialize from lob.
             * Empty lob�� �ƴ� �̻� �ּ� 6byte�̻��� �ƴϸ� TbLob ������ ���� �߻��� �� �ִ�.
             * �����δ� ���� �׻� 96byte�� �������� jdbc���� locator�� ���� ���̳ʸ� �����ʹ�
             * ���� �������� �����Ƿ�, �ּұ��̸�üũ�ϰ�, ������ ȣ���غ��� ������ �����Ѵ�.
             */
            byte[] locator = new byte[length];
            System.arraycopy(b, offset, locator, 0, length);
            TbBlob blob = new TbBlob(conn, locator, true);
            /*
             * subrp�� Lob�� ���, length��û�� �����ϰ� �ܼ��ϰ� ���̷� int max�� ����Ͽ�
             * �����͸� ��û�� ���� �ִ�. �׷��� �� ��쿡�� TbBlob.getBytes(long, int) ������
             * ������ length��ŭ new byte[]�� �Ҵ��ϴ� �κж����� �޸𸮸� �����ϰ� ����ϰ� �Ǿ�
             * OutOfMemoryError�� �߻��� ������ �ִ�.
             * �� ���������� length�� ȣ���� �����κ��� ���̸� �޾ƿ��� ������� �Ͽ���.
             */
            long lobLen = blob.length();
            if (lobLen > Integer.MAX_VALUE) { // 1-3-5 system���� maxsize�� int max.
                throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                              "rp(lob) len=" + lobLen);
            }
            b = blob.getBytes(1L, (int) lobLen);
            int readLen = (b == null) ? 0 : b.length;
            if (readLen < RPCOL_UDT_MIN_SIZE)
                throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                              "udt_lob_len=" + readLen);
            else if (b[0] != RPCOL_UDT_COLL || b[1] != RPCOL_UDT_ROOT)
                throw TbError.newSQLException(
                                              TbError.MU_COVERSION_RULE_VIOLATION,
                                              "udt_rpflag=0x" +
                                                      Integer.toHexString(0xff &
                                                              b[0]) +
                                                      ",0x" +
                                                      Integer.toHexString(0xff &
                                                              b[1]));

            off = 2; // 2bytes magic number.
        }
        else
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());

        int elemType = desc.getElementType();
        int elemSqlType = desc.getBaseType();

        // check protocol
        if (conn.serverInfo.getProtocolMajorVersion() >= 2 && conn.serverInfo.getProtocolMinorVersion() >=16){
            RPCOL_NULLOBJ=(byte)251;
            RPCOL_5BYTE=(byte)253;
        } else {
            RPCOL_NULLOBJ=(byte)253;
            RPCOL_5BYTE=(byte)251;
        }

        // read rplen (1-3-5 system)
        int rplen = (int) (b[off] & 0xff);
        if (rplen <= DBConst.RPCOL_1BYTE) {
            // 1st byte value is length
            off += 1;
        }
        else if (rplen == DBConst.RPCOL_LARGE) {
            rplen = TbCommon.bytes2Int(b, off + 1, 2);
            off += 3;
        }
        else if ((byte)rplen == DataTypeConverter.RPCOL_5BYTE /* XXX: RPCOL_5BYTE */) {
            rplen = TbCommon.bytes2Int(b, off + 1, 4);
            off += 5;
        }
        else
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "rplen=" + rplen);

        if (b[off] != 0 || b[off + 1] != 0|| b[off + 2] != 0)
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "illegal_input");
        off += 3; // skip empty 3 bytes

        // read array element counts (1-3-5 system)
        int arrayElemCnt = (int) (b[off] & 0xff);
        if (arrayElemCnt <= DBConst.RPCOL_1BYTE) {
            // 1st byte value is length
            off += 1;
        }
        else if (arrayElemCnt == DBConst.RPCOL_LARGE) {
            arrayElemCnt = TbCommon.bytes2Int(b, off + 1, 2);
            off += 3;
        }
        else if ((byte)arrayElemCnt == DataTypeConverter.RPCOL_5BYTE /* XXX: RPCOL_5BYTE */) {
            arrayElemCnt = TbCommon.bytes2Int(b, off + 1, 4);
            off += 5;
        }
        else
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          "arrayElemCnt=" + arrayElemCnt);

        Object[] elem = new Object[arrayElemCnt];

        for (int i = 0; i < arrayElemCnt; i ++) {
            int subRpLen = (int) (b[off] & 0xff);
            if (subRpLen <= DBConst.RPCOL_1BYTE) {
                // 1st byte value is length
                off++;
            }
            else if (subRpLen == DBConst.RPCOL_LARGE) {
                subRpLen = TbCommon.bytes2Int(b, off + 1, 2);
                off += 3;
            }
            else if ((byte)subRpLen == DataTypeConverter.RPCOL_5BYTE /* XXX: RPCOL_5BYTE */) {
                subRpLen = TbCommon.bytes2Int(b, off + 1, 4);
                off += 5;
            }
            else
                throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                              "subRpLen=" + subRpLen);

            switch (elemType) {
            case DataType.VARRAY:
            case DataType.TABLE:
            case DataType.IDX_BY_TBL:
                Object aDscObj = conn
                .getDescriptor(desc.getElementTypeName());

                if (aDscObj == null) {
                    aDscObj = TbArrayDescriptor.createDescriptor(elemType, desc.getElementTypeName(), conn);
                }

                if (aDscObj instanceof TbArrayDescriptor) {
                    TbArrayDescriptor arrDesc = (TbArrayDescriptor) aDscObj;
                    elem[i] = toArray(b, off, subRpLen, elemType,
                                      freeTmpLobOnEOF, arrDesc, typeMap);
                }
                else
                    TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                            DataType.getDBTypeName(dataType));
                break;

            case DataType.OBJECT:
            case DataType.RECORD:
                Object sDscObj = conn.getDescriptor(desc.getElementTypeName());
                if (sDscObj == null) {
                    sDscObj = TbStructDescriptor
                            .createDescriptor(elemType, desc.getElementTypeName(), conn);
                }

                if (sDscObj instanceof TbStructDescriptor) {
                    TbStructDescriptor structDesc = (TbStructDescriptor) sDscObj;
                    elem[i] = toStruct(b, off, subRpLen, elemType,
                                       freeTmpLobOnEOF, structDesc, null,
                                       typeMap);
                }
                else
                    TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                            DataType.getDBTypeName(dataType));
                break;

            case DataType.NUMBER:
                // NUMBER Ÿ���� ���, offset�� �������ش�.
                if (subRpLen == 0)
                    elem[i] = null;
                else
                    elem[i] = toObject(b, off - 1, subRpLen + 1, elemType,
                                       elemSqlType, freeTmpLobOnEOF);
                break;

            default:
                elem[i] = toObject(b, off, subRpLen, elemType, elemSqlType,
                                   freeTmpLobOnEOF);
            }

            off += subRpLen;
        }
        return new TbArray(desc, conn, elem);
    }

    public InputStream toAsciiStream(Object x, int offset, int length,
                                     int dataType) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toAsciiStream", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType) });
        }

        if (length == 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                return new ByteArrayInputStream(data, offset, length);

            case DataType.LONG:
                byte[] locator = new byte[length];
                System.arraycopy(data, offset, locator, 0, length);
                byte[] longData;
                synchronized (conn) {
                    longData = conn.getTbComm().readLongRaw(locator);
                }
                return new ByteArrayInputStream(longData, 0,
                                                longData.length);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public BigDecimal toBigDecimal(Object x, int offset, int length,
                                   int dataType) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toBigDecimal", new Object[] { x,
                                                                             Integer.toString(offset), Integer.toString(length),
                                                                             DataType.getDBTypeName(dataType) });
        }

        if (length == 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                try {
                    String value = getDBDecodedString(data, offset, length);
                    return new BigDecimal(value.trim());
                } catch (NumberFormatException e) {
                    if (Debug.TRACE) {
                        Debug.log("DataTypeConverter.toBigDecimal (FAILED): " +
                                  e.getMessage());
                    }
                    return null;
                }

            case DataType.NUMBER:
                return TbNumber.toBigDecimal(data, offset, length);
            case DataType.BIN_DOUBLE:
            	Double dbl = new Double(TbNumber.toBinaryDouble(data, offset, length)); 
                return new BigDecimal(dbl.toString());
            case DataType.BIN_FLOAT:
            	Float flt = new Float(TbNumber.toBinaryFloat(data, offset, length)); 
                return new BigDecimal(flt.toString());
            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public InputStream toBinaryStream(Object x, int offset, int length,
                                      int dataType) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toBinaryStream", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType) });
        }

        if (length == 0 || x == null)
            return null;

        if (x instanceof InputStream) {
            try {
                ((InputStream) x).reset();
                return (InputStream) x;
            } catch (IOException e) {
                throw TbError.newSQLException(TbError.MU_READ_FROM_INPUT_FAILED,
                                              e);
            }
        } else if (x instanceof Blob) {
            return ((TbBlob) x).getBinaryStream();
        } else if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                return new ByteArrayInputStream(data, offset, length);

            case DataType.LONGRAW:
                byte[] longLoc = new byte[length];
                System.arraycopy(data, offset, longLoc, 0, length);
                byte[] longRawData ;
                synchronized (conn) {
                    longRawData = conn.getTbComm().readLongRaw(longLoc);
                }
                return new ByteArrayInputStream(longRawData, 0,
                                                longRawData.length);

            case DataType.BLOB:
                byte[] lobLoc = new byte[length];
                System.arraycopy(data, offset, lobLoc, 0, length);
                return new TbBlob(conn, lobLoc, false).getBinaryStream();

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public Blob toBlob(Object x, int offset, int length, int dataType,
                       boolean freeTmpLobOnEOF) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toBlob", new Object[] { x,
                                                                       Integer.toString(offset), Integer.toString(length),
                                                                       DataType.getDBTypeName(dataType) });
        }

        if (length == 0 || x == null)
            return null;

        if (x instanceof Blob) {
            return (Blob) x;
        } else if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.BLOB:
                byte[] locator = new byte[length];
                System.arraycopy(data, offset, locator, 0, length);
                return new TbBlob(conn, locator, freeTmpLobOnEOF);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public boolean toBoolean(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toBoolean", new Object[] { x,
                                                                          Integer.toString(offset), Integer.toString(length),
                                                                          DataType.getDBTypeName(dataType) });
        }

        if (length == 0 || x == null)
            return false;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                String val1 = getDBDecodedString(data, offset, length).trim();
                return val1 != null &&
                    (val1.equals("t") || val1.equals("1") || val1
                     .equalsIgnoreCase("true"));

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                String val2 = getDBDecodedNString(data, offset, length).trim();
                return val2 != null &&
                    (val2.equals("t") || val2.equals("1") || val2
                     .equalsIgnoreCase("true"));

            case DataType.NUMBER:
                return TbNumber.toInteger(data, offset, length) != 0;

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public byte toByte(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toByte", new Object[] { x,
                                                                       Integer.toString(offset), Integer.toString(length),
                                                                       DataType.getDBTypeName(dataType) });
        }

        int value = toIntInternal(x, offset, length, dataType);

        if (value > 127 || value < -128)
            throw TbError.newSQLException(
                    TbError.INTERNAL_MU_BAD_DATA_FORMAT_CORRUPTED, value);

        return (byte) value;
    }

    public byte[] toBytes(Object x, int offset, int length, int dataType,
                          boolean freeTmpLobOnEOF) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toBytes", new Object[] { x,
                                                                        Integer.toString(offset), Integer.toString(length),
                                                                        DataType.getDBTypeName(dataType) });
        }

        if (length == 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.LONG:
            case DataType.LONGRAW:
                byte[] longLoc = new byte[length];
                System.arraycopy(data, offset, longLoc, 0, length);
                synchronized (conn) {
                    return conn.getTbComm().readLongRaw(longLoc);
                }

            case DataType.BLOB:
                byte[] lobLoc = new byte[length];
                System.arraycopy(data, offset, lobLoc, 0, length);
                TbBlob blob = new TbBlob(conn, lobLoc, freeTmpLobOnEOF);
                byte[] tmpBlobBytes = blob.getBytes(1, (int) blob.length());
                if (blob.getIsTempLob() && freeTmpLobOnEOF)
                    blob.free();
                return tmpBlobBytes;

            case DataType.CLOB:
            case DataType.NCLOB:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));

            default:
                byte[] result = new byte[length];
                System.arraycopy(data, offset, result, 0, length);

                return result;
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public int toBytes(Object x, int offset, int length, int dataType,
                       byte[] result) throws SQLException {
        /* This method is only for tbExpImp performance */
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toBytes", new Object[] { x,
                                                                        Integer.toString(offset), Integer.toString(length),
                                                                        DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return 0;

        if (x instanceof byte[]) {
            switch (dataType) {
            case DataType.LONG:
            case DataType.LONGRAW:
            case DataType.BLOB:
            case DataType.CLOB:
            case DataType.NCLOB:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));

            default:
                if (length > result.length)
                    throw TbError.newSQLException(TbError.MU_DATA_NOT_FIT);

                System.arraycopy(x, offset, result, 0, length);

                return length;
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public Reader toCharacterStream(Object x, int offset, int length,
                                    int dataType) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod(
                    "DataTypeConverter.toCharacterStream",
                    new Object[] { x, Integer.toString(offset),
                                   Integer.toString(length),
                                   DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof Reader) {
            try {
                ((Reader) x).reset();
                return (Reader) x;
            } catch (IOException e) {
                throw TbError.newSQLException(TbError.MU_READ_FROM_INPUT_FAILED,
                                              e);
            }
        } else if (x instanceof Clob) {
            return ((TbClob) x).getCharacterStream();
        } else if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                return new StringReader(getDBDecodedString(data, offset, length));

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                return new StringReader(getDBDecodedNString(data, offset, length));

            case DataType.LONG:
                byte[] longLoc = new byte[length];
                System.arraycopy(data, offset, longLoc, 0, length);
                String str;
                synchronized (conn) {
                    str = conn.getTbComm().readLong(longLoc);
                }
                return new StringReader(str);
            case DataType.CLOB:
                byte[] clobLoc = new byte[length];
                System.arraycopy(data, offset, clobLoc, 0, length);
                return new TbClob(conn, clobLoc, false).getCharacterStream();

            case DataType.NCLOB:
                byte[] nclobLoc = new byte[length];
                System.arraycopy(data, offset, nclobLoc, 0, length);
                return new TbNClob(conn, nclobLoc, false).getCharacterStream();

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public Clob toClob(Object x, int offset, int length, int dataType,
                       boolean freeTmpLobOnEOF) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toClob", new Object[] { x,
                                                                       Integer.toString(offset), Integer.toString(length),
                                                                       DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof Clob) {
            return (Clob) x;
        } else if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CLOB:
                byte[] clobLoc = new byte[length];
                System.arraycopy(data, offset, clobLoc, 0, length);
                return new TbClob(conn, clobLoc, freeTmpLobOnEOF);

            case DataType.NCLOB:
                byte[] nclobLoc = new byte[length];
                System.arraycopy(data, offset, nclobLoc, 0, length);
                return new TbNClob(conn, nclobLoc, freeTmpLobOnEOF);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public Date toDate(Object x, int offset, int length, int dataType)
        throws SQLException {
            Date date;
            long l;
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toDate", new Object[] { x,
                                                                       Integer.toString(offset), Integer.toString(length),
                                                                       DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                String dateStr = getDBDecodedString(data, offset, length);
                date = Date.valueOf(dateStr.trim());
                if (conn.getNlsCalendar().equals(BUDDHA_CALENDAR)){
                    l = date.getTime();
                    java.util.Date dU = new Date(l);
                    int y = dU.getYear();
                    dU.setYear(y + BUDDHA_YEAR_GAP);
                    date = new java.sql.Date(dU.getTime());
                }
                return date;

            case DataType.DATE:
                if (length != DBConst.TB_DATE_SIZE)
                    throw TbError.newSQLException(
                            TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_DATE,
                            length);
                date = toDateFromBytes(data, offset);
                if (conn.getNlsCalendar().equals(BUDDHA_CALENDAR)){
                    l = date.getTime();
                    java.util.Date dU = new Date(l);
                    int y = dU.getYear();
                    dU.setYear(y + BUDDHA_YEAR_GAP);
                    date = new java.sql.Date(dU.getTime());
                }
                return date;

            case DataType.TIMESTAMP:
                if (length != DBConst.TB_TIMESTAMP_SIZE)
                    throw TbError
                        .newSQLException(
                                TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                                length);
                date = toDateFromBytes(data, offset);
                if (conn.getNlsCalendar().equals(BUDDHA_CALENDAR)){
                    l = date.getTime();
                    java.util.Date dU = new Date(l);
                    int y = dU.getYear();
                    dU.setYear(y + BUDDHA_YEAR_GAP);
                    date = new java.sql.Date(dU.getTime());
                }
                return date;


            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    private Date toDateFromBytes(byte[] bytes, int offset) {
        int db_century = 0xff & bytes[offset];
        int db_year = 0xff & bytes[offset + 1];
        int db_month = 0xff & bytes[offset + 2];
        int day = 0xff & bytes[offset + 3];
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];
        int year = (db_century - 100) * 100 + (db_year - 100);
        int month = db_month - 1;

        Calendar calendar = Calendar.getInstance();
        calendar.set(year, month, day, hour, minute, second);
		calendar.clear(Calendar.MILLISECOND);

        return new Date(calendar.getTimeInMillis());
    }

    public TbDate toTbDate(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toTbDate", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.DATE:
                /* to TbTimestamp from DATE */
                if (length != DBConst.TB_DATE_SIZE)
                    throw TbError
                        .newSQLException(TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_DATE,
                                         length);

                byte[] dateData = new byte[DBConst.TB_DATE_SIZE];
                System.arraycopy(data, offset, dateData, 0,
                        DBConst.TB_DATE_SIZE);

                TbDate date = new TbDate(dateData);

                return date;

            case DataType.TIMESTAMP:
                /* to TbTimestamp from TIMESTAMP */
                if (length != DBConst.TB_TIMESTAMP_SIZE)
                    throw TbError
                        .newSQLException(TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                                         length);

                byte[] tsData = new byte[DBConst.TB_DATE_SIZE];
                System.arraycopy(data, offset, tsData, 0,
                        DBConst.TB_DATE_SIZE);

                TbDate tsdt = new TbDate(tsData);

                return tsdt;

            default:
                throw TbError
                    .newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                     DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                    x.toString());
        }
    }

    public double toDouble(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toDouble", new Object[] { x,
                                                                         Integer.toString(offset), Integer.toString(length),
                                                                         DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return 0.0d;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                try {
                    String value = getDBDecodedString(data, offset, length);
                    return Double.parseDouble(value.trim());
                } catch (NumberFormatException e) {
                    if (Debug.TRACE) {
                        Debug.log("DataTypeConverter.toDouble (FAILED) : " +
                                  e.getMessage());
                    }
                    return 0.0d;
                }

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                try {
                    String value = getDBDecodedNString(data, offset, length);
                    return Double.parseDouble(value.trim());
                } catch (NumberFormatException e) {
                    if (Debug.TRACE) {
                        Debug.log("DataTypeConverter.toDouble (FAILED) : " +
                                  e.getMessage());
                    }
                    return 0.0d;
                }

            case DataType.NUMBER:
                return TbNumber.toDouble(data, offset, length);

            case DataType.BIN_DOUBLE:
                return TbNumber.toBinaryDouble(data, offset, length);

            case DataType.BIN_FLOAT:
                return TbNumber.toBinaryFloat(data, offset, length);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public float toFloat(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toFloat", new Object[] { x,
                                                                        Integer.toString(offset), Integer.toString(length),
                                                                        DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return 0.0f;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                try {
                    String value = getDBDecodedString(data, offset, length);
                    return Float.parseFloat(value.trim());
                } catch (NumberFormatException e) {
                    if (Debug.TRACE) {
                        Debug.log("DataTypeConverter.toFloat (FAILED) : " +
                                  e.getMessage());
                    }
                    return 0.0f;
                }

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                try {
                    String value = getDBDecodedNString(data, offset, length);
                    return Float.parseFloat(value.trim());
                } catch (NumberFormatException e) {
                    if (Debug.TRACE) {
                        Debug.log("DataTypeConverter.toFloat (FAILED) : " +
                                  e.getMessage());
                    }
                    return 0.0f;
                }

            case DataType.NUMBER:
                return (float) TbNumber.toDouble(data, offset, length);

            case DataType.BIN_DOUBLE:
                return (float) TbNumber.toBinaryDouble(data, offset, length);

            case DataType.BIN_FLOAT:
                return TbNumber.toBinaryFloat(data, offset, length);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public int toInt(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toInt", new Object[] { x,
                                                                      Integer.toString(offset), Integer.toString(length),
                                                                      DataType.getDBTypeName(dataType) });
        }

        return toIntInternal(x, offset, length, dataType);
    }

    public TbIntervalDts toIntervalDts(Object x, int offset, int length,
                                       int dataType, int precision, int scale) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toIntervalDts", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType), 
                    Integer.toString(precision), Integer.toString(scale) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            switch (dataType) {
            case DataType.ITV_DTS:
                byte[] data = new byte[length];
                System.arraycopy(x, offset, data, 0, length);
                return new TbIntervalDts(data, precision, scale);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public TbIntervalYtm toIntervalYtm(Object x, int offset, int length,
                                       int dataType, int precision) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toIntervalYtm", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType),
                    Integer.toString(precision) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            switch (dataType) {
            case DataType.ITV_YTM:
                byte[] data = new byte[length];
                System.arraycopy(x, offset, data, 0, length);
                return new TbIntervalYtm(data, precision);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public int toIntInternal(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (length <= 0 || x == null)
            return 0;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                try {
                    String value = getDBDecodedString(data, offset, length);
                    return Integer.parseInt(value.trim());
                } catch (NumberFormatException e) {
                    return TbCommon.bytes2Int(data, offset, length);
                }

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                try {
                    String value = getDBDecodedString(data, offset, length);
                    return Integer.parseInt(value.trim());
                } catch (NumberFormatException e) {
                    return TbCommon.bytes2Int(data, offset, length);
                }

            case DataType.NUMBER:
                return TbNumber.toInteger(data, offset, length);
                
            case DataType.BIN_DOUBLE:
            	return (int) TbNumber.toBinaryDouble(data, offset, length); 
            case DataType.BIN_FLOAT:
            	return (int) TbNumber.toBinaryFloat(data, offset, length); 
                
            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public long toLong(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toLong", new Object[] { x,
                                                                       Integer.toString(offset), Integer.toString(length),
                                                                       DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return 0l;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                try {
                    String value = getDBDecodedString(data, offset, length);
                    return Long.parseLong(value.trim());
                } catch (NumberFormatException e) {
                    return TbCommon.bytes2Long(data, offset, length);
                }

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                try {
                    String value = getDBDecodedNString(data, offset, length);
                    return Long.parseLong(value.trim());
                } catch (NumberFormatException e) {
                    return TbCommon.bytes2Long(data, offset, length);
                }

            case DataType.NUMBER:
                return TbNumber.toLong(data, offset, length);

            case DataType.BIN_DOUBLE:
            	return (long) TbNumber.toBinaryDouble(data, offset, length); 
            case DataType.BIN_FLOAT:
            	return (long) TbNumber.toBinaryFloat(data, offset, length); 
                
            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    private byte[] toLongRawBytes(Object x, int offset, int length)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toLongRawBytes", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] locator = new byte[length];

            System.arraycopy(x, offset, locator, 0, length);

            synchronized (conn) {
                return conn.getTbComm().readLongRaw(locator);
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public InputStream toLongRawStream(Object x, int offset, int length,
                                       int dataType) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toLongRawStream", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.LONG:
            case DataType.LONGRAW:
                byte[] longLoc = new byte[length];
                System.arraycopy(data, offset, longLoc, 0, length);
                byte[] longData;
                synchronized (conn) {
                    longData = conn.getTbComm().readLongRaw(longLoc);
                }
                return new ByteArrayInputStream(longData, 0, longData.length);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    private String toLongString(Object x, int offset, int length)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toLongString", new Object[] { x,
                                                                             Integer.toString(offset), Integer.toString(length) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] locator = new byte[length];

            System.arraycopy(x, offset, locator, 0, length);

            synchronized (conn) {
                return conn.getTbComm().readLong(locator);
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    // #ifdef JDK1.6
    public NClob toNClob(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toNClob", new Object[] { x,
                                                                        Integer.toString(offset), Integer.toString(length),
                                                                        DataType.getDBTypeName(dataType) });
        }
        return toTbNClob(x, offset, length, dataType);
    }
    // #endif

    public TbNClob toTbNClob(Object x, int offset, int length, int dataType)
            throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toTbNClob", new Object[] { x,
                    Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof TbNClob 
                // #ifdef JDK1.6
                || x instanceof NClob
                // #endif
                ) {
            return (TbNClob) x;
        } else if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.NCLOB:
                byte[] nlobLoc = new byte[length];
                System.arraycopy(data, offset, nlobLoc, 0, length);
                return new TbNClob(conn, nlobLoc, false);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public TbNrowId toNrowId(Object x, int offset, int length)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toNrowId", new Object[] { x,
                                                                         Integer.toString(offset), Integer.toString(length) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            TbNrowId nrowId = new TbNrowId(conn);

            System.arraycopy(x, offset, nrowId.nrowid, 0,
                    TbNrowId.NROWID_BYTE_CNT);

            return nrowId;
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                    x.toString());
        }
    }

    public Object toObject(Object x, int offset, int length, int dataType,
                           int sqlType, boolean freeTmpLobOnEOF)
                                   throws SQLException {
        return toObject(x, offset, length, dataType, sqlType, -1, -1,
                        freeTmpLobOnEOF, null, null, null);
    }

    public Object toObject(Object x, int offset, int length, int dataType,
                           int sqlType, int precision, int scale,
                           boolean freeTmpLobOnEOF, TbTypeDescriptor desc,
                           // #ifdef JDK1.5
                           Class<?> clazz, Map<String, Class<?>> typeMap)
//                           // #else
//                           Class clazz, Map typeMap)
                           // #endif
                                   throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toObject", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType), Integer.toString(sqlType),
                    Integer.toString(precision), Integer.toString(scale)
            });
        }

        switch (dataType) {
        case DataType.CHAR:
        case DataType.VARCHAR:
        case DataType.NCHAR:
        case DataType.NVARCHAR:
            return toString(x, offset, length, dataType, freeTmpLobOnEOF);

        case DataType.LONG:
            return toLongString(x, offset, length);

        case DataType.LONGRAW:
            return toLongRawBytes(x, offset, length);

        case DataType.NUMBER:
            BigDecimal bd = toBigDecimal(x, offset, length, dataType);

            switch (sqlType) {
            case java.sql.Types.TINYINT:
            case java.sql.Types.SMALLINT:
            case java.sql.Types.INTEGER:
                return new Integer(bd.intValue());

            case java.sql.Types.BIGINT:
                return new Long(bd.longValue());

            case java.sql.Types.REAL:
                return new Float(bd.floatValue());

            case java.sql.Types.FLOAT:
            case java.sql.Types.DOUBLE:
                return new Double(bd.doubleValue());

            default:
                return bd;
            }

        case DataType.BIN_DOUBLE:
            return new Double(toDouble(x, offset, length, dataType));

        case DataType.BIN_FLOAT:
            return new Float(toFloat(x, offset, length, dataType));

        case DataType.DATE:
            switch (sqlType) {
            case Types.DATE:
                return toDate(x, offset, length, dataType);
                
            case Types.TIMESTAMP:
                return toTimestamp(x, offset, length, dataType);

            case Types.TIME:
                return toTime(x, offset, length, dataType);

            default:
                throw TbError.newSQLException(
                        TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                        Integer.toString(sqlType));
            }

        case DataType.TIME:
            return toTime(x, offset, length, dataType);

        case DataType.TIMESTAMP_TZ:
        case DataType.TIMESTAMP_LTZ:
        case DataType.TIMESTAMP:
            return toTimestamp(x, offset, length, dataType);

        case DataType.RAW:
            return toBytes(x, offset, length, dataType, freeTmpLobOnEOF);

        case DataType.ROWID:
            if (conn.getServerInfo().getServerIsNanobase() == ServerInfo.NANOBASE_SVR)
                return toNrowId(x, offset, length);
            else
                return toRowId(x, offset, length, dataType);

        case DataType.BLOB:
            return toBlob(x, offset, length, dataType, freeTmpLobOnEOF);

        case DataType.CLOB:
        case DataType.NCLOB:
            // #ifdef JDK1.6
            if (sqlType == Types.SQLXML) {
                return toSQLXML(x, offset, length, dataType, freeTmpLobOnEOF);
            }
            // #endif
            return toClob(x, offset, length, dataType, freeTmpLobOnEOF);

        case DataType.ITV_DTS:
            return toIntervalDts(x, offset, length, dataType, precision, scale);

        case DataType.ITV_YTM:
            return toIntervalYtm(x, offset, length, dataType, precision);

        case DataType.VARRAY:
        case DataType.TABLE:
        case DataType.IDX_BY_TBL:
            if (desc instanceof TbArrayDescriptor) {
                return toArray(x, offset, length, dataType, freeTmpLobOnEOF,
                               (TbArrayDescriptor) desc, typeMap);
            }
            else if (length == 0)
                return null;
            else
                break; // go to throw exception

        case DataType.RECORD:
        case DataType.OBJECT:
            if (desc instanceof TbStructDescriptor) {
                if ((desc.getOID().compareTo(TbTypeDescriptor.OID_XMLTYPE) == 0) &&
                        (clazz == null) && ((typeMap == null) ||
                        (typeMap.get(desc.getSQLTypeName()) == null))) {
                    // XMLTYPE as Object
                    return toStruct(x, offset, length, dataType,
                                    freeTmpLobOnEOF, (TbStructDescriptor) desc,
                                    TbSQLXML.class, typeMap);
                }

                return toStruct(x, offset, length, dataType, freeTmpLobOnEOF,
                                (TbStructDescriptor) desc, clazz, typeMap);
            }
            else if (length == 0)
                return null;
            else 
                break; // go to throw exception

        default:
        }
        throw TbError.newSQLException(TbError.INTERNAL_UNSUPPORTED_DATA_TYPE,
                                      DataType.getDBTypeName(dataType));
    }

    public TbResultSet toResultSet(Object x, int offset, int length,
                                   TbStatement stmt) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toResultSet", new Object[] { x,
                                                                            new Integer(offset), new Integer(length), stmt });
        }

        int csrId = TbCommon.bytes2Int((byte[]) x, offset, length);

        TbResultSet rs;
        synchronized (conn) {
            rs = conn.getTbComm().describeCSRReply(stmt, csrId);
        }

        return rs;
    }

    public TbResultSet toResultSet(int colCnt, int hiddenColCnt, int csrId,
                                   TbColumnDesc[] colMeta, TbStatement stmt,
                                   byte[] rowChunk) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toResultSet", new Object[] {
                    new Integer(colCnt), new Integer(hiddenColCnt),
                    new Integer(csrId), colMeta, stmt });
        }

        int realColCnt = colCnt - hiddenColCnt;

        TbResultSet rs = TbResultSetFactory
                .buildResultSet(stmt, csrId, realColCnt, hiddenColCnt,
                                rowChunk);

        buildColumnMetadata(colMeta, rs, colCnt);

        rs.setFetchCompleted(0);

        return rs;
    }

    public TbResultSet toResultSet(TbStatement stmt, byte[] data,
                                   BindItem item) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toResultSet", new Object[] {
                    stmt, item });
        }

        int length = item.getLength();
        int csrId = TbCommon.bytes2Int(data, 0, length);
        TbColumnDesc[] colMeta = item.getColMeta();

        if (colMeta == null)
            throw TbError.newSQLException(TbError.MU_NO_META_DATA);

        TbResultSet rs = TbResultSetFactory
                .buildResultSet(stmt, csrId, colMeta.length, 0, null);

        buildColumnMetadata(colMeta, rs, colMeta.length);

        rs.setFetchCompleted(0);

        return rs;
    }

    public TbRowId toRowId(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod(
                    "DataTypeConverter.toRowId",
                    new Object[] { x, Integer.toString(offset),
                                   Integer.toString(length),
                                   Integer.toString(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            switch (dataType) {
            case DataType.ROWID:
                TbRowId rowid = new TbRowId();
                rowid.fromBytes(conn.getServerInfo().getServerEndian(),
                                (byte[]) x, offset);
                return rowid;

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public short toShort(Object x, int offset, int length, int dataType)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toShort", new Object[] { x,
                                                                        Integer.toString(offset), Integer.toString(length),
                                                                        DataType.getDBTypeName(dataType) });
        }

        int value = toIntInternal(x, offset, length, dataType);

        if (value > 32767 || value < -32768)
            throw TbError.newSQLException(
                    TbError.INTERNAL_MU_BAD_DATA_FORMAT_CORRUPTED, value);

        return (short) value;
    }

    // #ifdef JDK1.6
    public SQLXML toSQLXML(Object x, int offset, int length, int dataType,
                           boolean freeTmpLobOnEOF) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toSQLXML", new Object[] { x,
                                                                         Integer.toString(offset), Integer.toString(length) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            switch (dataType) {
            case DataType.CLOB:
                byte[] locator = new byte[length];
                System.arraycopy(x, offset, locator, 0, length);
                TbClob clob = new TbClob(conn, locator, freeTmpLobOnEOF);
                TbXMLInputStream stream = new TbXMLInputStream(clob);
                return new TbSQLXML(conn, stream);

            case DataType.OBJECT:
            case DataType.RECORD:
                /*
                 * XMLTYPE as Object �� ���, 1��° attributes�� doc (cxmltype)�� ����
                 * TbClob���� deserialize�� doc�� �̿��� TbSQLXML�� �����Ѵ�.
                 */
                Object xmldescObj = conn.getDescriptor(_DESC_OID_PREFIX +
                        TbTypeDescriptor.OID_XMLTYPE);
                Object ret = null;
                if (xmldescObj instanceof TbStructDescriptor) {
                    ret = toStruct(x, offset, length, dataType, freeTmpLobOnEOF,
                                   (TbStructDescriptor) xmldescObj, null, null);
                }
                Object docObj = null;
                if (ret instanceof TbStruct &&
                        ((TbStruct) ret).getNumOfFields() > 1) {
                    docObj = ((TbStruct) ret).getAttributes()[0];
                }
                if (docObj instanceof TbClob) {
                    TbXMLInputStream xis =
                            new TbXMLInputStream((TbClob) docObj);
                    return new TbSQLXML(conn, xis);
                }
                // else go to exception
                
            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }
    // #endif

    public String toString(Object x, int offset, int length, int dataType,
                           boolean freeTmpLobOnEOF) throws SQLException {
        return toString(x, offset, length, dataType, -1, -1, freeTmpLobOnEOF);
    }

    public String toString(Object x, int offset, int length, int dataType,
                           int precision, int scale, boolean freeTmpLobOnEOF)
            throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toString", new Object[] { x,
                                                                         Integer.toString(offset), Integer.toString(length),
                                                                         DataType.getDBTypeName(dataType),
                                                                         Integer.toString(precision), Integer.toString(scale) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                return getDBDecodedString(data, offset, length);

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                return getDBDecodedNString(data, offset, length);

            case DataType.RAW:
                return TbCommon.bytes2String(data, offset, length);

            case DataType.CLOB:
                Clob clob = toClob(x, offset, length, dataType,
                                   freeTmpLobOnEOF);
                String tmpClobStr = clob.getSubString(1, (int) clob.length());
                if (((TbLob) clob).getIsTempLob() && freeTmpLobOnEOF)
                    ((TbLob)clob).free();
                return tmpClobStr;

            case DataType.NCLOB:
                TbNClob nclob = (TbNClob) toClob(x, offset, length, dataType,
                                                 freeTmpLobOnEOF);
                String tmpNClobStr = nclob
                    .getSubString(1, (int) nclob.length());
                if (nclob.getIsTempLob() && freeTmpLobOnEOF)
                    nclob.free();
                return tmpNClobStr;

            case DataType.BLOB:
                Blob blob = toBlob(x, offset, length, dataType,
                                   freeTmpLobOnEOF);
                byte[] blobBytes = blob.getBytes(1, (int) blob.length());
                if (((TbLob) blob).getIsTempLob() && freeTmpLobOnEOF)
                    ((TbLob)blob).free();
                return TbCommon.bytes2String(blobBytes, 0, blobBytes.length);

            case DataType.LONG:
                return toLongString(x, offset, length);

            case DataType.LONGRAW:
                byte[] longBytes = toLongRawBytes(x, offset, length);
                return TbCommon.bytes2String(longBytes, 0, longBytes.length);

            case DataType.NUMBER:
                return TbNumber.getNormalForm(data, offset, length);

            case DataType.BIN_DOUBLE:
                return Double.toString(toDouble(x, offset, length, dataType));
                
            case DataType.BIN_FLOAT:
                return Float.toString(toFloat(x, offset, length, dataType));

            case DataType.DATE:
                TbDate tbdt = toTbDate(x, offset, length, dataType);
                if (tbdt == null) {
                    return null;
                }
                
                if (conn.info.getNlsDatetimeFormatEnabled())
                    return TbDTFormatter.format(conn.getParsedNlsDateFormat(),
                                                tbdt);
                else
                    return tbdt.toString();

            case DataType.TIMESTAMP:
                TbTimestamp timestamp = toTbTimestamp(x, offset, length,
                                                      dataType);
                if (timestamp == null) {
                    return null;
                }

                if (conn.info.getNlsDatetimeFormatEnabled())
                    return TbDTFormatter.format(
                                                conn.getParsedNlsTimestampFormat(),
                                                timestamp);
                else
                    return timestamp.toString();

            case DataType.TIMESTAMP_TZ: 
            {
                TimeZone timezone = toTimeZoneFromBytes(data, offset, length);
                TbTimestamp tsTZ = getTbTimestampTZFromBytes(data, offset,
                                                             length, timezone);
                if (tsTZ == null) {
                    return null;
                }

                String tzID = timezone.getID();
                if (getTimeZoneIdFromBytes(data, offset, length) ==
                    ZoneInfo.TZ_ID_OFFSET.getId().intValue()) {
                    if (tzID.startsWith("GMT")) {
                        tzID = tzID.substring("GMT".length());
                    }
                }

                return tsTZ.toString() + " " + tzID;
            }
            case DataType.TIMESTAMP_LTZ:
            {
                TimeZone timezone = TimeZone.getDefault();
                TbTimestamp tsLTZ = getTbTimestampLTZFromBytes(data, offset,
                                                               length, timezone);
                if (tsLTZ == null) {
                    return null;
                }

                return tsLTZ.toString();
            }
            default:
                // XXX: toString�� typemap�� connection default�� �ؾ��ϴ°� null�� �ϴ°�??
                Object obj = toObject(x, offset, length, dataType,
                                      DataType.getSqlType(dataType, 0, conn
                                              .getMapDateToTimestamp()),
                                      precision, scale, freeTmpLobOnEOF, null, null, null);

                return obj == null ? null : obj.toString();
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                    x.toString());
        }
    }

    public Time toTime(Object x, int offset, int length, int dataType)
            throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toTime", new Object[] { x,
                    Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                String val1 = getDBDecodedString(data, offset, length);
                return Time.valueOf(val1.trim());

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                String val2 = getDBDecodedNString(data, offset, length);
                return Time.valueOf(val2.trim());

            case DataType.DATE:
                if (length != DBConst.TB_DATE_SIZE)
                    throw TbError.newSQLException(
                            TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_DATE,
                            length);

                return toTimeFromDate(data, offset);

            case DataType.TIME:
                if (length != DBConst.TB_TIME_SIZE)
                    throw TbError.newSQLException(
                            TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIME,
                            length);

                return toTimeFromBytes(data, offset);

            case DataType.TIMESTAMP:
                if (length != DBConst.TB_TIMESTAMP_SIZE)
                    throw TbError
                        .newSQLException(
                                TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                                length);

                return toTimeFromTimestamp(data, offset);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    private Time toTimeFromBytes(byte[] bytes, int offset) {
        int hour = 0xff & bytes[offset];
        int minute = 0xff & bytes[offset + 1];
        int second = 0xff & bytes[offset + 2];

        Calendar cal = Calendar.getInstance();
        cal.set(1970, Calendar.JANUARY, 1, hour, minute, second);
        cal.clear(Calendar.MILLISECOND);

        return new Time(cal.getTimeInMillis());
    }

    private Time toTimeFromDate(byte[] bytes, int offset) {
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];

        Calendar cal = Calendar.getInstance();
        cal.set(1970, Calendar.JANUARY, 1, hour, minute, second);
        cal.clear(Calendar.MILLISECOND);

        return new Time(cal.getTimeInMillis());
    }

    private Time toTimeFromTimestamp(byte[] bytes, int offset) {
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];

        Calendar cal = Calendar.getInstance();
        cal.set(1970, Calendar.JANUARY, 1, hour, minute, second);
        cal.clear(Calendar.MILLISECOND);

        Timestamp timestamp = new Timestamp(cal.getTimeInMillis());

        return new Time(timestamp.getTime());
    }

    public Timestamp toTimestamp(Object x, int offset, int length, int dataType)
        throws SQLException {
        return toTimestamp(x, offset, length, dataType, null);
    }

    public Timestamp toTimestamp(Object x, int offset, int length,
                                 int dataType, Calendar cal) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toTimestamp", new Object[] { x,
                                                                            Integer.toString(offset), Integer.toString(length),
                                                                            DataType.getDBTypeName(dataType), cal });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.CHAR:
            case DataType.VARCHAR:
                String val1 = getDBDecodedString(data, offset, length);
                return Timestamp.valueOf(val1.trim());

            case DataType.NCHAR:
            case DataType.NVARCHAR:
                String val2 = getDBDecodedNString(data, offset, length);
                return Timestamp.valueOf(val2.trim());

            case DataType.DATE:
                return toTimestampFromDate(data, offset, length);

            case DataType.TIME:
                return toTimestampFromTime(data, offset, length);

            case DataType.TIMESTAMP:
                if (cal == null)
                    return toTimestampFromBytes(data, offset, length);
                else
                    return toTimestampFromBytes(data, offset, length, cal);

            case DataType.TIMESTAMP_TZ:
                return toTimestampTZFromBytes(data, offset, length);

            case DataType.TIMESTAMP_LTZ:
                return toTimestampLTZFromBytes(data, offset, length);

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
                        DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                                          x.toString());
        }
    }

    public TbTimestamp toTbTimestamp(Object x, int offset, int length, int dataType)
    		throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toTbTimestamp", new Object[] { x,
                    Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (x instanceof byte[]) {
            byte[] data = (byte[]) x;

            switch (dataType) {
            case DataType.DATE:
                /* to TbTimestamp from DATE */
                if (length != DBConst.TB_DATE_SIZE)
                    throw TbError
                            .newSQLException(TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_DATE,
                                             length);

                byte[] dateData = new byte[DBConst.TB_TIMESTAMP_SIZE];
                System.arraycopy(data, offset, dateData, 0,
                                 DBConst.TB_DATE_SIZE);
                for (int i = DBConst.TB_DATE_SIZE; i < dateData.length; i++) {
                    dateData[i] = 0;
                }
                TbTimestamp tsDate = new TbTimestamp(dateData);
                return tsDate;

            case DataType.TIMESTAMP:
                /* to TbTimestamp from TIMESTAMP */
                if (length != DBConst.TB_TIMESTAMP_SIZE)
                    throw TbError
                            .newSQLException(TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                                             length);

                byte[] tsData = new byte[DBConst.TB_TIMESTAMP_SIZE];
                System.arraycopy(data, offset, tsData, 0,
                                 DBConst.TB_TIMESTAMP_SIZE);
                TbTimestamp ts = new TbTimestamp(tsData);
                return ts;

            default:
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION,
   	                    DataType.getDBTypeName(dataType));
            }
        } else {
            throw TbError.newSQLException(TbError.MU_COVERSION_RULE_VIOLATION,
                x.toString());
        }
    }

    private Timestamp toTimestampFromBytes(byte[] bytes, int offset, int length)
        throws SQLException {
        if (length != DBConst.TB_TIMESTAMP_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP, length);

        int db_century = 0xff & bytes[offset + 0];
        int db_year = 0xff & bytes[offset + 1];
        int db_month = 0xff & bytes[offset + 2];
        int day = 0xff & bytes[offset + 3];
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];
        int year = (db_century - 100) * 100 + (db_year - 100);
        int month = db_month - 1;
        int nanoSec = TbCommon.bytes2Int(bytes, offset + 8, 4);
        
        Calendar cal = Calendar.getInstance();
        cal.set(year, month, day, hour, minute, second);

        Timestamp timestamp = new Timestamp(cal.getTimeInMillis());
        timestamp.setNanos(nanoSec);

        return timestamp;
    }

    private Timestamp toTimestampFromBytes(byte[] bytes, int offset,
                                           int length, Calendar cal) throws SQLException {
        if (length != DBConst.TB_TIMESTAMP_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP, length);

        int db_century = 0xff & bytes[offset + 0];
        int db_year = 0xff & bytes[offset + 1];
        int db_month = 0xff & bytes[offset + 2];
        int day = 0xff & bytes[offset + 3];
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];
        int year = (db_century - 100) * 100 + (db_year - 100);
        int month = db_month - 1;
        int nanoSec = TbCommon.bytes2Int(bytes, offset + 8, 4);

        cal.set(year, month, day, hour, minute, second);

        Timestamp timestamp = new Timestamp(cal.getTimeInMillis());
        timestamp.setNanos(nanoSec);

        return timestamp;
    }

    private Timestamp toTimestampFromTime(byte[] bytes, int offset, int length)
            throws SQLException {
        if (length != DBConst.TB_TIME_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIME, length);

        int hour = 0xff & bytes[offset];
        int minute = 0xff & bytes[offset + 1];
        int second = 0xff & bytes[offset + 2];
        int nanoSec = TbCommon.bytes2Int(bytes, offset + 4, 4);

        Calendar cal = Calendar.getInstance();
        cal.set(1970, Calendar.JANUARY, 1, hour, minute, second);

        Timestamp timestamp = new Timestamp(cal.getTimeInMillis());
        timestamp.setNanos(nanoSec);

        return timestamp;
    }

    private Timestamp toTimestampFromDate(byte[] bytes, int offset, int length)
        throws SQLException {
        if (length != DBConst.TB_DATE_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_DATE, length);

        int db_century = 0xff & bytes[offset + 0];
        int db_year = 0xff & bytes[offset + 1];
        int db_month = 0xff & bytes[offset + 2];
        int day = 0xff & bytes[offset + 3];
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];
        int year = (db_century - 100) * 100 + (db_year - 100);
        int month = db_month - 1;
        int nanoSec = 0;

        Calendar cal = Calendar.getInstance();
        cal.set(year, month, day, hour, minute, second);

        Timestamp timestamp = new Timestamp(cal.getTime().getTime());
        timestamp.setNanos(nanoSec);

        return timestamp;
    }

    private int getTimeZoneIdFromBytes(byte[] bytes, int offset, int length)
        throws SQLException {
        
        if (length != DBConst.TB_TS_TZ_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                    length);

        return TbCommon.bytes2Int(bytes, offset + 15, 2);
    }

    private TimeZone toTimeZoneFromBytes(byte[] bytes, int offset, int length)
            throws SQLException {
        if (length != DBConst.TB_TS_TZ_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                    length);

        int zone_id = TbCommon.bytes2Int(bytes, offset + 15, 2);
        if (zone_id == ZoneInfo.TZ_ID_OFFSET.getId().intValue()) {
            int utc_hour = (0xff & bytes[offset + 12]) - 100;
            int utc_min = 0xff & bytes[offset + 13];
            
            NumberFormat nfTime = NumberFormat.getInstance();
            nfTime.setMinimumIntegerDigits(2);
            
            StringBuffer tzStr = new StringBuffer();
            tzStr.append("GMT");
            if (utc_hour >= 0)
                tzStr.append("+");
            tzStr.append(nfTime.format(utc_hour));
            tzStr.append(":");
            tzStr.append(nfTime.format(utc_min));
            return TimeZone.getTimeZone(tzStr.toString());
        } else {
            String timezoneName = ZoneInfo.getZoneNameById(zone_id);
            return TimeZone.getTimeZone(timezoneName);
        }
    }

    private TbTimestamp getTbTimestampTZFromBytes(byte[] bytes, int offset,
                                                  int length, TimeZone timezone) throws SQLException {
        if (length != DBConst.TB_TS_TZ_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                    length);

        int db_century = 0xff & bytes[offset + 0];
        int db_year = 0xff & bytes[offset + 1];
        int db_month = 0xff & bytes[offset + 2];
        int day = 0xff & bytes[offset + 3];
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];
        int year = (db_century - 100) * 100 + (db_year - 100);
        int month = db_month - 1;
        int nanoSec = TbCommon.bytes2Int(bytes, offset + 8, 4);

        Calendar calendar = Calendar.getInstance(ZoneInfo.TZ_UTC);
        calendar.set(year, month, day, hour, minute, second);
        calendar.clear(Calendar.MILLISECOND);

        long time = calendar.getTimeInMillis();

        calendar.setTimeZone(timezone);
        calendar.setTimeInMillis(time);

        TbTimestamp ts = new TbTimestamp(calendar.get(Calendar.YEAR),
                                         calendar.get(Calendar.MONTH) + 1,
                                         calendar.get(Calendar.DAY_OF_MONTH),
                                         calendar.get(Calendar.HOUR_OF_DAY),
                                         calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND),
                                         nanoSec);

        return ts;
    }

    private TbTimestamp getTbTimestampLTZFromBytes(byte[] bytes, int offset,
                                                   int length, TimeZone timezone) throws SQLException {
        if (length != DBConst.TB_TS_LTZ_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                    length);

        int db_century = 0xff & bytes[offset + 0];
        int db_year = 0xff & bytes[offset + 1];
        int db_month = 0xff & bytes[offset + 2];
        int day = 0xff & bytes[offset + 3];
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];
        int year = (db_century - 100) * 100 + (db_year - 100);
        int month = db_month - 1;
        int nanoSec = TbCommon.bytes2Int(bytes, offset + 8, 4);

        Calendar calendar = Calendar.getInstance(ZoneInfo.TZ_UTC);
        calendar.set(year, month, day, hour, minute, second);
        calendar.clear(Calendar.MILLISECOND);

        long time = calendar.getTimeInMillis();

        calendar.setTimeZone(timezone);

        calendar.setTimeInMillis(time);

        bytes = new byte[DBConst.TB_TS_LTZ_SIZE];

        int years = calendar.get(Calendar.YEAR);
        bytes[0] = (byte) (years / 100 + 100);
        bytes[1] = (byte) (years % 100 + 100);
        bytes[2] = (byte) (calendar.get(Calendar.MONTH) + 1);
        bytes[3] = (byte) (calendar.get(Calendar.DAY_OF_MONTH));
        bytes[4] = (byte) (calendar.get(Calendar.HOUR_OF_DAY));
        bytes[5] = (byte) (calendar.get(Calendar.MINUTE));
        bytes[6] = (byte) (calendar.get(Calendar.SECOND));
        bytes[7] = 0;
        // copy nano second
        TbCommon.int2Bytes(nanoSec, bytes, 8, 4);

        TbTimestamp ts = new TbTimestamp(bytes);

        return ts;
    }

    private Timestamp toTimestampTZFromBytes(byte[] bytes, int offset,
        int length) throws SQLException {
        
        if (length != DBConst.TB_TS_TZ_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP,
                    length);

        int db_century = 0xff & bytes[offset + 0];
        int db_year = 0xff & bytes[offset + 1];
        int db_month = 0xff & bytes[offset + 2];
        int day = 0xff & bytes[offset + 3];
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];
        int year = (db_century - 100) * 100 + (db_year - 100);
        int month = db_month - 1;
        int nanoSec = TbCommon.bytes2Int(bytes, offset + 8, 4);

        //        int utc_hour = 0xff & bytes[offset + 12] - 100;
        //        int utc_min = 0xff & bytes[offset + 13];
        //        int utc_sec = 0xff & bytes[offset + 14];
        //        int zone_id = TbCommon.bytes2Int(bytes, offset + 15, 2);

        Calendar utcCalendar = Calendar.getInstance(ZoneInfo.TZ_UTC);
        utcCalendar.set(year, month, day, hour, minute, second);
        utcCalendar.clear(Calendar.MILLISECOND);

        Timestamp result = new Timestamp(utcCalendar.getTimeInMillis());
        result.setNanos(nanoSec);
        return result;

    }

    private Timestamp toTimestampLTZFromBytes(byte[] bytes, int offset,
                                              int length) throws SQLException {
        if (length != DBConst.TB_TS_LTZ_SIZE)
            throw TbError.newSQLException(
                    TbError.INTERNAL_DATA_CONVERSION_FAIL_TYPE_TIMESTAMP, ""
                            + length);

        int db_century = 0xff & bytes[offset + 0];
        int db_year = 0xff & bytes[offset + 1];
        int db_month = 0xff & bytes[offset + 2];
        int day = 0xff & bytes[offset + 3];
        int hour = 0xff & bytes[offset + 4];
        int minute = 0xff & bytes[offset + 5];
        int second = 0xff & bytes[offset + 6];
        int year = (db_century - 100) * 100 + (db_year - 100);
        int month = db_month - 1;
        int nanoSec = TbCommon.bytes2Int(bytes, offset + 8, 4);

        Calendar calendar = Calendar.getInstance(ZoneInfo.TZ_UTC);
        calendar.set(year, month, day, hour, minute, second);

        long time = calendar.getTimeInMillis();
        calendar.setTimeInMillis(time);
        calendar.clear(Calendar.MILLISECOND);

        Timestamp localTimestamp = new Timestamp(calendar.getTimeInMillis());
        localTimestamp.setNanos(nanoSec);

        return localTimestamp;
    }

    public InputStream toUnicodeStream(Object x, int offset, int length,
                                       int dataType, boolean freeTmpLobOnEOF)
            throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("DataTypeConverter.toUnicodeStream", new Object[] {
                    x, Integer.toString(offset), Integer.toString(length),
                    DataType.getDBTypeName(dataType) });
        }

        if (length <= 0 || x == null)
            return null;

        if (DataType.isCharacterCategory(dataType)) {
            String value = toString(x, offset, length, dataType, freeTmpLobOnEOF);

            return new ByteArrayInputStream(value.getBytes());
        } else {
            if (x instanceof byte[]) {
                switch (dataType) {
                case DataType.LONG:
                    byte locator[] = new byte[length];
                    System.arraycopy(x, offset, locator, 0, length);
                    String longData;
                    synchronized (conn) {
                        longData = conn.getTbComm().readLong(locator);
                    }
                    return new ByteArrayInputStream(longData.getBytes());

                default:
                    throw TbError.newSQLException(
                            TbError.MU_COVERSION_RULE_VIOLATION,
                            DataType.getDBTypeName(dataType));
                }
            } else {
                throw TbError.newSQLException(
                        TbError.MU_COVERSION_RULE_VIOLATION, x.toString());
            }
        }
    }
    
    public static String tbBase64Encode(byte[] rawBytes) {
        int i;
        // #ifdef JDK1.5
        StringBuilder sb = new StringBuilder();
//        // #else
//        StringBuffer sb = new StringBuffer();
        // #endif

        for (i = 0; i < rawBytes.length - 2; i += 3) {
            sb.append(encode((rawBytes[i] >> 2) & 0x3F));
            sb.append(encode(((rawBytes[i] & 0x3) << 4)
                             | ((rawBytes[i + 1] & 0xF0 ) >> 4)));
            sb.append(encode(((rawBytes[i + 1] & 0xF) << 2)
                             | ((rawBytes[i + 2] & 0xC0) >> 6)));
            sb.append(encode(rawBytes[i + 2] & 0x3F));
        }

        if (i < rawBytes.length) {
            sb.append(encode((rawBytes[i] >> 2) & 0x3F));
            if (i == (rawBytes.length - 1)) {
                sb.append(encode((rawBytes[i] & 0x3) << 4));
                sb.append('=');
            }
            else {
                sb.append(encode(((rawBytes[i] & 0x3) << 4)
                                 | ((rawBytes[i + 1] & 0xF0 ) >> 4)));
                sb.append(encode((rawBytes[i + 1] & 0xF) << 2));
            }
            sb.append('=');
        }
        
        return sb.toString();
    }
    
    private static char encode(int i) {
        final char[] encodeMap = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
            'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',
            'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a',
            'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
            'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
            't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1',
            '2', '3', '4', '5', '6', '7', '8', '9', '+',
            '/'
        };

        return encodeMap[i];
    }

    private final static int[] pr2six = {
        /* ASCII table */
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
        64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
        64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
    };
    
    public static byte[] tbBase64Decode(byte[] in) {
        int i = 0;
        while (i < in.length && pr2six[in[i++]] <= 63)
            ;                   // skip

        int nprbytes = i - 1;
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        i = 0;
        while (nprbytes > 4) {
            buffer.write(pr2six[in[i]] << 2 | pr2six[in[i+1]] >> 4);
            buffer.write(pr2six[in[i+1]] << 4 | pr2six[in[i+2]] >> 2);
            buffer.write(pr2six[in[i+2]] << 6 | pr2six[in[i+3]]);
            i += 4;
            nprbytes -= 4;
        }

        /* Note: (nprbytes == 1) would be an error, so just ingore that case */
        if (nprbytes > 1) {
            buffer.write(pr2six[in[i]] << 2 | pr2six[in[i+1]] >> 4);
        }
        if (nprbytes > 2) {
            buffer.write(pr2six[in[i+1]] << 4 | pr2six[in[i+2]] >> 2);
        }
        if (nprbytes > 3) {
            buffer.write(pr2six[in[i+2]] << 6 | pr2six[in[i+3]]);
        }

        return buffer.toByteArray();
    }
    
    public static byte[] base64Decode2(String data) throws Exception {
        int[] tbl = {
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,
            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2,
            3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
            20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30,
            31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
        byte[] bytes = data.getBytes("ASCII");
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        for (int i = 0; i < bytes.length; ) {
            int b = 0;
            if (tbl[bytes[i]] != -1) {
                b = (tbl[bytes[i]] & 0xFF) << 18;
            }
            // skip unknown characters
            else {
                i++;
                continue;
            }

            int num = 0;
            if (i + 1 < bytes.length && tbl[bytes[i+1]] != -1) {
                b = b | ((tbl[bytes[i+1]] & 0xFF) << 12);
                num++;
            }
            if (i + 2 < bytes.length && tbl[bytes[i+2]] != -1) {
                b = b | ((tbl[bytes[i+2]] & 0xFF) << 6);
                num++;
            }
            if (i + 3 < bytes.length && tbl[bytes[i+3]] != -1) {
                b = b | (tbl[bytes[i+3]] & 0xFF);
                num++;
            }

            while (num > 0) {
                int c = (b & 0xFF0000) >> 16;
                buffer.write((char)c);
                b <<= 8;
                num--;
            }
            i += 4;
        }
        return buffer.toByteArray();
    }
    
    private final static byte d[] = {
        66,66,66,66,66,66,66,66,66,66,64,66,66,66,66,66,66,66,66,66,66,66,66,66,66,
        66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,62,66,66,66,63,52,53,
        54,55,56,57,58,59,60,61,66,66,66,65,66,66,66, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,66,66,66,66,66,66,26,27,28,
        29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,66,66,
        66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,
        66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,
        66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,
        66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,
        66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,
        66,66,66,66,66,66
    };

    public static byte[] base64Decode(byte[] in) throws Exception {
        final int WITHSPACE = 64;
        final int EQUALS    = 65;
        final int INVALID   = 66;
        int buf = 0;
        int iter = 0;
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        
        for (int i = 0; i < in.length; ++i) {
            byte c = d[in[i]];

            switch (c) {
            case WITHSPACE: continue;
            case INVALID:   return null;
            case EQUALS:
                break;
            default:
                buf = buf << 6 | c;
                iter++;
                if (iter == 4) {
                    buffer.write((byte)((buf >> 16) & 255));
                    buffer.write((byte)((buf >> 8) & 255));
                    buffer.write((byte)(buf & 255));
                    buf = 0;
                    iter = 0;
                }
            }
        }

        if (iter == 3) {
            buffer.write((byte)((buf >> 10) & 255));
            buffer.write((byte)((buf >> 2) & 255));
        }
        else if (iter == 2) {
            buffer.write ((byte)((buf >> 4) & 255));
        }

        return buffer.toByteArray();
    }

    class ObjInstBldCtx {
        TbStructDescriptor desc;
        Object[] values;
        int attrProcessed;

        ObjInstBldCtx(TbStructDescriptor desc) {
            this.desc = desc;
            values = new Object[desc.getNumOfFields()];
            attrProcessed = 0;
        }
    }
}
