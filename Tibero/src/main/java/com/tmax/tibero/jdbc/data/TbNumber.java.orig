/**
 * Copyright (c) 2011-, TmaxData, Inc. / Seoul, Republic of Korea
 *
 * This document contains proprietary and confidential information.  No
 * parts of this document or the computer program it embodies may be in
 * any way copied, duplicated, reproduced, translated into a different
 * programming language, or distributed to any person, company, or
 * corporation without the prior written consent of Tibero, Inc.
 */
package com.tmax.tibero.jdbc.data;

import java.io.IOException;
import java.io.StringReader;
import java.math.BigDecimal;
import java.sql.SQLException;

import com.tmax.tibero.jdbc.err.TbError;
import com.tmax.tibero.jdbc.util.TbCommon;

/**
 * TbNumber class.
 * 
 * @version $Id: TbNumber.java 179267 2020-06-30 01:56:52Z jihun_park $
 */
public class TbNumber {
    private static final int NUMBER_MAX_PREC = 38;
    private static final int EXP_BIAS_POS = 65;
    private static final int EXP_BIAS_NEG = (0x7f - EXP_BIAS_POS);
    private static final int NUMBER_MAX_EXP = (0x7f - EXP_BIAS_POS);
    private static final int NUMBER_MIN_EXP = (0x00 - EXP_BIAS_POS);
    private static final int NUMBER_TOP = ((byte)0xf0);
    private static final int NUMBER_BOT = ((byte)0x10);
    private static final int NUMBER_BASE = 100;
    private static final int NUMBER_MAX_LEN = (NUMBER_MAX_PREC >> 1) + 2;
    private static final int NUMBER_MASK_SIGN = 0x80;
    private static final int NUMBER_MASK_EXP = 0x7f;

    private static final byte[] MAX_INTEGER =
        {0x06, (byte)0xc5, (byte)0x95, (byte)0xaf, (byte)0xb0, (byte)0xa4,
         (byte)0xaf};
    private static final byte[] MIN_INTEGER =
        {0x07, 0x3a, 0x6b, 0x51, 0x50, 0x5c, 0x50, (byte)0xf0};

    private static final byte[] MAX_LONG =
        {0x0b, (byte)0xca, (byte)0x89, (byte)0x96, (byte)0xa1, (byte)0xc8,
         (byte)0x83, (byte)0xc4, (byte)0xb6, (byte)0xcd, (byte)0xba, (byte)0x87};
    private static final byte[] MIN_LONG =
        {0x0c, 0x35, 0x77, 0x6a, 0x5f, 0x38, 0x7d, 0x3c, 0x4a, 0x33, 0x46,
         0x78, (byte)0xf0};

    private static char coefToChar[][] =
        {{'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'},
         {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'},
         {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'},
         {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'},
         {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'},
         {'0', '0'}, {'0', '0'}, {'0', '0'}, {'0', '0'}, {'9', '9'},
         {'9', '8'}, {'9', '7'}, {'9', '6'}, {'9', '5'}, {'9', '4'},
         {'9', '3'}, {'9', '2'}, {'9', '1'}, {'9', '0'}, {'8', '9'},
         {'8', '8'}, {'8', '7'}, {'8', '6'}, {'8', '5'}, {'8', '4'},
         {'8', '3'}, {'8', '2'}, {'8', '1'}, {'8', '0'}, {'7', '9'},
         {'7', '8'}, {'7', '7'}, {'7', '6'}, {'7', '5'}, {'7', '4'},
         {'7', '3'}, {'7', '2'}, {'7', '1'}, {'7', '0'}, {'6', '9'},
         {'6', '8'}, {'6', '7'}, {'6', '6'}, {'6', '5'}, {'6', '4'},
         {'6', '3'}, {'6', '2'}, {'6', '1'}, {'6', '0'}, {'5', '9'},
         {'5', '8'}, {'5', '7'}, {'5', '6'}, {'5', '5'}, {'5', '4'},
         {'5', '3'}, {'5', '2'}, {'5', '1'}, {'5', '0'}, {'4', '9'},
         {'4', '8'}, {'4', '7'}, {'4', '6'}, {'4', '5'}, {'4', '4'},
         {'4', '3'}, {'4', '2'}, {'4', '1'}, {'4', '0'}, {'3', '9'},
         {'3', '8'}, {'3', '7'}, {'3', '6'}, {'3', '5'}, {'3', '4'},
         {'3', '3'}, {'3', '2'}, {'3', '1'}, {'3', '0'}, {'2', '9'},
         {'2', '8'}, {'2', '7'}, {'2', '6'}, {'2', '5'}, {'2', '4'},
         {'2', '3'}, {'2', '2'}, {'2', '1'}, {'2', '0'}, {'1', '9'},
         {'1', '8'}, {'1', '7'}, {'1', '6'}, {'1', '5'}, {'1', '4'},
         {'1', '3'}, {'1', '2'}, {'1', '1'}, {'1', '0'}, {'0', '9'},
         {'0', '8'}, {'0', '7'}, {'0', '6'}, {'0', '5'}, {'0', '4'},
         {'0', '3'}, {'0', '2'}, {'0', '1'}, {'0', '0'}, {'0', '1'},
         {'0', '2'}, {'0', '3'}, {'0', '4'}, {'0', '5'}, {'0', '6'},
         {'0', '7'}, {'0', '8'}, {'0', '9'}, {'1', '0'}, {'1', '1'},
         {'1', '2'}, {'1', '3'}, {'1', '4'}, {'1', '5'}, {'1', '6'},
         {'1', '7'}, {'1', '8'}, {'1', '9'}, {'2', '0'}, {'2', '1'},
         {'2', '2'}, {'2', '3'}, {'2', '4'}, {'2', '5'}, {'2', '6'},
         {'2', '7'}, {'2', '8'}, {'2', '9'}, {'3', '0'}, {'3', '1'},
         {'3', '2'}, {'3', '3'}, {'3', '4'}, {'3', '5'}, {'3', '6'},
         {'3', '7'}, {'3', '8'}, {'3', '9'}, {'4', '0'}, {'4', '1'},
         {'4', '2'}, {'4', '3'}, {'4', '4'}, {'4', '5'}, {'4', '6'},
         {'4', '7'}, {'4', '8'}, {'4', '9'}, {'5', '0'}, {'5', '1'},
         {'5', '2'}, {'5', '3'}, {'5', '4'}, {'5', '5'}, {'5', '6'},
         {'5', '7'}, {'5', '8'}, {'5', '9'}, {'6', '0'}, {'6', '1'},
         {'6', '2'}, {'6', '3'}, {'6', '4'}, {'6', '5'}, {'6', '6'},
         {'6', '7'}, {'6', '8'}, {'6', '9'}, {'7', '0'}, {'7', '1'},
         {'7', '2'}, {'7', '3'}, {'7', '4'}, {'7', '5'}, {'7', '6'},
         {'7', '7'}, {'7', '8'}, {'7', '9'}, {'8', '0'}, {'8', '1'},
         {'8', '2'}, {'8', '3'}, {'8', '4'}, {'8', '5'}, {'8', '6'},
         {'8', '7'}, {'8', '8'}, {'8', '9'}, {'9', '0'}, {'9', '1'},
         {'9', '2'}, {'9', '3'}, {'9', '4'}, {'9', '5'}, {'9', '6'},
         {'9', '7'}, {'9', '8'}, {'9', '9'}};

    private static int convertCoef(byte[] bytes, int byteOff, char[] buf,
                                   int bufOff, int posDecpoint) {
        int convLen = 0;

        int coef = bytes[byteOff + 2];
        if (coef < 0)
            coef += 256;

        char[] coefp = coefToChar[coef];
        buf[bufOff + convLen] = coefp[0];

        if (coefp[0] != '0')
            convLen++;

        buf[bufOff + convLen++] = coefp[1];

        int siglen = getSiglen(bytes, byteOff);

        for (int i = 1; i < siglen; i++) {
            coef = bytes[byteOff + 2 + i];
            if (coef < 0)
                coef += 256;

            coefp = coefToChar[coef];
            buf[bufOff + convLen++] = coefp[0];
            buf[bufOff + convLen++] = coefp[1];
        }

        if (buf[bufOff + convLen - 1] == '0')
            convLen--;

        if (posDecpoint > 0 && posDecpoint < convLen) {
            for (int i = bufOff + convLen; i >= posDecpoint + bufOff; i--) {
                buf[i + 1] = buf[i];
            }
            buf[bufOff + posDecpoint] = '.';
            convLen++;
        }

        return convLen;
    }

    private static int convertExp(int exp10, int offset, char[] buf) {
        int i;
        boolean leadingZero = false;
        String exp;

        exp10 = exp10 < 0 ? -exp10 : exp10;

        if (exp10 >= 0 && exp10 < 10) {
            buf[offset++] = '0';
            leadingZero = true;
        }

        exp = Integer.toString(exp10);

        for (i = 0; i < exp.length(); i++) {
            buf[offset + i] = exp.charAt(i);
        }

        return i + (leadingZero ? 1 : 0);
    }

    private static byte digitEncode(boolean isPositive, int x) {
        return (isPositive ? (byte)(128 + x) : (byte)(128 - x));
    }

    public static int fromInteger(byte[] buf, int offset, int v) {
        int size;
        int lastNonZeroPos = 0;
        int c;
        boolean isPositive;
        int[] coef = new int[NUMBER_MAX_LEN];

        isPositive = v >= 0;

        for (size = 0; v != 0; ++size) {
            c = v / NUMBER_BASE;
            coef[size] = v - NUMBER_BASE * c;
            v = c;
        }

        if (size == 0)
            return toZero(buf, offset);

        if (isPositive) {
            for (int i = 0; i < size; ++i) {
                buf[offset + 2 + i] = (byte)(0x80 + coef[size - i - 1]);
                if (coef[size - i - 1] != 0)
                    lastNonZeroPos = i;
            }
            buf[offset + 1] = (byte)(0x80 | (byte)(EXP_BIAS_POS + (size - 1)));
            size = lastNonZeroPos + 1;
        }
        else {
            for (int i = 0; i < size; ++i) {
                buf[offset + 2 + i] = (byte)(0x80 - -coef[size - i - 1]);
                if (coef[size - i - 1] != 0)
                    lastNonZeroPos = i;
            }
            buf[offset + 1] = (byte)(EXP_BIAS_NEG - (size - 1));
            size = lastNonZeroPos + 1;
            buf[offset + 2 + size] = NUMBER_TOP;
            ++size;
        }
        buf[offset] = (byte)(size + 1);

        return size + 2;
    }

    public static byte[] fromInteger(int v) throws SQLException {
        int size;
        int lastNonZeroPos = 0;
        int c;
        boolean isPositive;
        int[] coef = new int[NUMBER_MAX_LEN];

        isPositive = v >= 0;

        for (size = 0; v != 0; ++size) {
            c = v / NUMBER_BASE;
            coef[size] = v - NUMBER_BASE * c;
            v = c;
        }

        if (size == 0)
            return toZero();

        byte[] bytes = new byte[NUMBER_MAX_LEN + 2];

        if (isPositive) {
            for (int i = 0; i < size; ++i) {
                bytes[2 + i] = (byte)(0x80 + coef[size - i - 1]);
                if (coef[size - i - 1] != 0)
                    lastNonZeroPos = i;
            }
            bytes[1] = (byte)(0x80 | (byte)(EXP_BIAS_POS + (size - 1)));
            size = lastNonZeroPos + 1;
        }
        else {
            for (int i = 0; i < size; ++i) {
                bytes[2 + i] = (byte)(0x80 - -coef[size - i - 1]);
                if (coef[size - i - 1] != 0)
                    lastNonZeroPos = i;
            }
            bytes[1] = (byte)(EXP_BIAS_NEG - (size - 1));
            size = lastNonZeroPos + 1;
            bytes[2 + size] = NUMBER_TOP;
            ++size;
        }
        bytes[0] = (byte)(size + 1);

        return bytes;
    }

    public static int fromLong(byte[] buf, int offset, long v)
        throws SQLException {
        int size;
        int lastNonZeroPos = 0;
        long c;
        boolean isPositive;
        int[] coef = new int[NUMBER_MAX_LEN];

        isPositive = v >= 0;

        for (size = 0; v != 0; ++size) {
            c = v / NUMBER_BASE;
            coef[size] = (int)(v - NUMBER_BASE * c);
            v = c;
        }

        if (size == 0)
            return toZero(buf, offset);

        if (isPositive) {
            for (int i = 0; i < size; ++i) {
                buf[offset + 2 + i] = (byte)(0x80 + coef[size - i - 1]);
                if (coef[size - i - 1] != 0)
                    lastNonZeroPos = i;
            }
            buf[offset + 1] = (byte)(0x80 | (EXP_BIAS_POS + (size - 1)));
            size = lastNonZeroPos + 1;
        }
        else {
            for (int i = 0; i < size; ++i) {
                buf[offset + 2 + i] = (byte)(0x80 - -coef[size - i - 1]);
                if (coef[size - i - 1] != 0)
                    lastNonZeroPos = i;
            }
            buf[offset + 1] = (byte)(EXP_BIAS_NEG - (size - 1));
            size = lastNonZeroPos + 1;
            buf[offset + 2 + size] = NUMBER_TOP;
            ++size;
        }
        buf[offset] = (byte)(size + 1);

        return size + 2;
    }

    public static byte[] fromLong(long v) throws SQLException {
        int size;
        int lastNonZeroPos = 0;
        long c;
        boolean isPositive;
        int[] coef = new int[NUMBER_MAX_LEN];

        isPositive = v >= 0;

        for (size = 0; v != 0; ++size) {
            c = v / NUMBER_BASE;
            coef[size] = (int)(v - NUMBER_BASE * c);
            v = c;
        }

        if (size == 0)
            return toZero();

        byte[] bytes = new byte[NUMBER_MAX_LEN + 2];

        if (isPositive) {
            for (int i = 0; i < size; ++i) {
                bytes[2 + i] = (byte)(0x80 + coef[size - i - 1]);
                if (coef[size - i - 1] != 0)
                    lastNonZeroPos = i;
            }
            bytes[1] = (byte)(0x80 | (EXP_BIAS_POS + (size - 1)));
            size = lastNonZeroPos + 1;
        }
        else {
            for (int i = 0; i < size; ++i) {
                bytes[2 + i] = (byte)(0x80 - -coef[size - i - 1]);
                if (coef[size - i - 1] != 0)
                    lastNonZeroPos = i;
            }
            bytes[1] = (byte)(EXP_BIAS_NEG - (size - 1));
            size = lastNonZeroPos + 1;
            bytes[2 + size] = NUMBER_TOP;
            ++size;
        }
        bytes[0] = (byte)(size + 1);

        return bytes;
    }

    public static int fromString(byte[] buf, int offset, String str)
        throws SQLException {
        /*
         * direct conversion from the C function num_from_str() except that:
         * this version doesn't care about validity of input string
         */

        /*
         * ASSUMES that the input string str is well-formatted string
         * representation of a number
         */

        byte temp_coef[] = new byte[NUMBER_MAX_PREC + 3];
        boolean isPositive, expIsNegative, initialZeroInCoef, isLower;
        int i, t, sum, coefIdx, posLastNonzero, totalLen;
        int pos1stNonzeroBeforePoint, numZeroesFollowingPoint, exp, exp10, orderOfCoef;
        int coef_prc41 = 0; //ims224477
        char scan;
        // byte[] bytes;
        StringReader sr = new StringReader(str);

        try { /* to completely ignore IOException */

            coefIdx = 0;
            posLastNonzero = -1;
            numZeroesFollowingPoint = 0;
            scan = (char)sr.read();

            isPositive = true;
            if (scan == '-') {
                isPositive = false;
                scan = (char)sr.read();
            }
            else if (scan == '+') {
                scan = (char)sr.read();
            }

            while (scan == '0') {
                scan = (char)sr.read();
            }

            while (Character.isDigit(scan)) {
                if (coefIdx < NUMBER_MAX_PREC + 2) { // limit to 40 
                    temp_coef[coefIdx] = (byte)Character.getNumericValue(scan);
                    if (scan != '0') {
                        posLastNonzero = coefIdx;
                    }
                } else if (coefIdx == NUMBER_MAX_PREC + 2) {
                    coef_prc41 = (byte)Character.getNumericValue(scan);
                }
                coefIdx++;
                scan = (char)sr.read();
            }

            pos1stNonzeroBeforePoint = coefIdx;

            if (scan == '.') {
                scan = (char)sr.read();

                if (posLastNonzero < 0) {
                    while (scan == '0') {
                        numZeroesFollowingPoint++;
                        scan = (char)sr.read();
                    }
                }

                while (Character.isDigit(scan)) {
                    if (coefIdx < NUMBER_MAX_PREC + 2) { // limit to 38 digits
                        temp_coef[coefIdx] =
                            (byte)Character.getNumericValue(scan);
                        if (scan != '0') {
                            posLastNonzero = coefIdx;
                        }
                    } else if (coefIdx == NUMBER_MAX_PREC + 2) {
                        coef_prc41 = (byte)Character.getNumericValue(scan);
                    }
                    coefIdx++;
                    scan = (char)sr.read();
                }
            }

            exp10 = 0;
            expIsNegative = false;

            if ((scan == 'e') | (scan == 'E')) {
                scan = (char)sr.read();

                if (scan == '-') {
                    expIsNegative = true;
                    scan = (char)sr.read();
                }
                else if (scan == '+') {
                    scan = (char)sr.read();
                }

                exp10 = 0;
                while (Character.isDigit(scan)) {
                    exp10 = (exp10 * 10) + Character.getNumericValue(scan);
                    scan = (char)sr.read();
                }
            }

            if (posLastNonzero < 0) {
                return toZero(buf, offset);
            }

            orderOfCoef =
                (pos1stNonzeroBeforePoint > 0 ? pos1stNonzeroBeforePoint - 1
                    : (-(numZeroesFollowingPoint + 1)));

            if (expIsNegative) {
                exp10 = -exp10;
            }

            exp10 += orderOfCoef;

            initialZeroInCoef = ((exp10 & 0x1) == 0);
            
            if (initialZeroInCoef && coefIdx >= NUMBER_MAX_PREC + 2)
                coef_prc41 = temp_coef[39];
            
            exp = (exp10 >> 1);

            /* overflow or underflow error */
            if (exp > NUMBER_MAX_EXP)
                throw TbError.newSQLException(TbError.MU_NUMBER_OVERFLOW, str);
            if (exp < NUMBER_MIN_EXP)
                throw TbError.newSQLException(TbError.MU_NUMBER_UNDERFLOW, str);

            totalLen =
                1 + (isPositive ? 0 : 1) +
                    ((posLastNonzero + 1) + 1 + (initialZeroInCoef ? 1 : 0)) /
                    2;
            /* totalLen incremented for right-shifting coefficient */
            // bytes = new byte[totalLen + 1];

            buf[offset] = (byte)totalLen;

            if (isPositive) {
                buf[offset + 1] = (byte)(0x80 | (EXP_BIAS_POS + exp));
            }
            else {
                buf[offset + 1] = (byte)(EXP_BIAS_NEG - exp);
            }

            isLower = initialZeroInCoef;
            i = 0;
            sum = 0;
            t = 2;

            while (i <= posLastNonzero) {
                if (isLower) {
                    buf[offset + t++] =
                        digitEncode(isPositive, sum + temp_coef[i]);
                }
                else {
                    sum = temp_coef[i] * 10;
                }
                isLower = !isLower;
                i++;
            }
            if (isLower) {
                buf[offset + t++] = digitEncode(isPositive, sum);
            }
            if (!isPositive) {
                buf[offset + t++] = NUMBER_TOP;
            }
            if(isPositive && totalLen >= 21) {
            	totalLen = 21;
				buf[offset] = (byte) totalLen;
			} else if (!isPositive && totalLen >= 22) {
				totalLen = 22;
				buf[offset] = (byte) totalLen;
				buf[offset + NUMBER_MAX_LEN + 1] = NUMBER_TOP;
			}
            
            /* number_rounding_at_41_prec */
            if (coef_prc41 >= 5) {
                roundingAt41Prec(buf, offset, isPositive, totalLen, exp, str);
            }
            
            /* remove_tail_zero */
            int isNeg = isPositive ? 0 : 1;
            int j = totalLen - isNeg;
            for (; j >= 2; --j) 
                if (buf[offset + j] != (byte) 0x80)
                    break;

            if (j < totalLen - isNeg) { 
                if (j < 2) { 
                    buf[offset] = 1;
                    return 2;
                }
                else {
                    buf[offset + j + 1] = NUMBER_TOP;
                    buf[offset] = (byte)(j + isNeg);
                    return j + isNeg + 1;
                }
            } 
            
            return totalLen + 1;
        }
        catch (IOException e) {
            /* to completely ignore IOException */
            return 0;
        }
    }

    public static byte[] fromString(String str) throws SQLException {
        /*
         * direct conversion from the C function num_from_str() except that:
         * this version doesn't care about validity of input string
         */

        /*
         * ASSUMES that the input string str is well-formatted string
         * representation of a number
         */
        byte temp_coef[] = new byte[NUMBER_MAX_PREC + 3];
        boolean isPositive, expIsNegative, initialZeroInCoef, isLower;
        int i, t, sum, coefIdx, posLastNonzero, totalLen;
        int pos1stNonzeroBeforePoint, numZeroesFollowingPoint, exp, exp10, orderOfCoef;
        int coef_prc41 = 0; //ims-224477
        char scan;
        byte[] bytes;
        StringReader sr = new StringReader(str);

        try { /* to completely ignore IOException */
            coefIdx = 0;
            posLastNonzero = -1;
            numZeroesFollowingPoint = 0;
            scan = (char)sr.read();

            isPositive = true;
            if (scan == '-') {
                isPositive = false;
                scan = (char)sr.read();
            }
            else if (scan == '+') {
                scan = (char)sr.read();
            }

            while (scan == '0') {
                scan = (char)sr.read();
            }

            while (Character.isDigit(scan)) {
                if (coefIdx < NUMBER_MAX_PREC + 2) { // limit to 38 digits
                    temp_coef[coefIdx] = (byte)Character.getNumericValue(scan);
                    if (scan != '0') {
                        posLastNonzero = coefIdx;
                    }
                } else if (coefIdx == NUMBER_MAX_PREC + 2) {
                    coef_prc41 = (byte)Character.getNumericValue(scan);
                }
                coefIdx++;
                scan = (char)sr.read();
            }

            pos1stNonzeroBeforePoint = coefIdx;

            if (scan == '.') {
                scan = (char)sr.read();

                if (posLastNonzero < 0) {
                    while (scan == '0') {
                        numZeroesFollowingPoint++;
                        scan = (char)sr.read();
                    }
                }

                while (Character.isDigit(scan)) {
                    if (coefIdx < NUMBER_MAX_PREC + 2) { // limit to 38 digits
                        temp_coef[coefIdx] =
                            (byte)Character.getNumericValue(scan);
                        if (scan != '0') {
                            posLastNonzero = coefIdx;
                        }
                    } else if (coefIdx == NUMBER_MAX_PREC + 2) {
                        coef_prc41 = (byte)Character.getNumericValue(scan);
                    }
                    coefIdx++;
                    scan = (char)sr.read();
                }
            }

            exp10 = 0;
            expIsNegative = false;

            if ((scan == 'e') | (scan == 'E')) {
                scan = (char)sr.read();

                if (scan == '-') {
                    expIsNegative = true;
                    scan = (char)sr.read();
                }
                else if (scan == '+') {
                    scan = (char)sr.read();
                }

                exp10 = 0;
                while (Character.isDigit(scan)) {
                    exp10 = (exp10 * 10) + Character.getNumericValue(scan);
                    scan = (char)sr.read();
                }
            }

            if (posLastNonzero < 0) {
                return toZero();
            }

            orderOfCoef =
                (pos1stNonzeroBeforePoint > 0 ? pos1stNonzeroBeforePoint - 1
                    : (-(numZeroesFollowingPoint + 1)));

            if (expIsNegative) {
                exp10 = -exp10;
            }

            exp10 += orderOfCoef;

            initialZeroInCoef = ((exp10 & 0x1) == 0);
            
            if (initialZeroInCoef && coefIdx >= NUMBER_MAX_PREC + 2)
                coef_prc41 = temp_coef[39];

            exp = (exp10 >> 1);
            
            /* overflow or underflow error */
            if (exp > NUMBER_MAX_EXP)
                throw TbError.newSQLException(TbError.MU_NUMBER_OVERFLOW, str);
            if (exp < NUMBER_MIN_EXP)
                throw TbError.newSQLException(TbError.MU_NUMBER_UNDERFLOW, str);

            totalLen =
                1 + (isPositive ? 0 : 1) +
                    ((posLastNonzero + 1) + 1 + (initialZeroInCoef ? 1 : 0)) /
                    2;
            /* totalLen incremented for right-shifting coefficient */
            bytes = new byte[totalLen + 1];

            bytes[0] = (byte)totalLen;

            if (isPositive) {
                bytes[1] = (byte)(0x80 | (EXP_BIAS_POS + exp));
            }
            else {
                bytes[1] = (byte)(EXP_BIAS_NEG - exp);
            }

            isLower = initialZeroInCoef;
            i = 0;
            sum = 0;
            t = 2;

            while (i <= posLastNonzero) {
                if (isLower) {
                    bytes[t++] = digitEncode(isPositive, sum + temp_coef[i]);
                }
                else {
                    sum = temp_coef[i] * 10;
                }
                isLower = !isLower;
                i++;
            }
            if (isLower) {
                bytes[t++] = digitEncode(isPositive, sum);
            }
            if (!isPositive) {
                bytes[t++] = NUMBER_TOP;
            }
            if(isPositive && totalLen >= 21) {
            	totalLen = 21;
				bytes[0] = (byte) totalLen;
			} else if (!isPositive && totalLen >= 22) {
				totalLen = 22;
				bytes[0] = (byte) totalLen;
				bytes[NUMBER_MAX_LEN + 1] = NUMBER_TOP;
			}
     
            /* number_rounding_at_41_prec */
            if (coef_prc41 >= 5) {
                roundingAt41Prec(bytes, 0, isPositive, totalLen, exp, str);
            }

            /* remove_tail_zero */
            int isNeg = isPositive ? 0 : 1;
            int j = totalLen - isNeg;
            for (; j >= 2; --j) 
                if (bytes[j] != (byte) 0x80)
                    break;

            if (j < totalLen - isNeg) { 
                if (j < 2) 
                    bytes[0] = 1;
                else {
                    bytes[j+1] = NUMBER_TOP;
                    bytes[0] = (byte)(j + isNeg);
                }
            }    
            
            return bytes;
        }
        catch (IOException e) {
            /* to completely ignore IOException */
            return null;
        }
    }
    private static void roundingAt41Prec(byte[] bytes, int offset, boolean isPositive, 
    		int totalLen, int exp, String str) throws SQLException{
    	int idx = 21;
        int tmp,c;
        
        if(isPositive){
        	tmp = getDecoPos(bytes[offset + idx]) + 1;
        	c = tmp >= 100 ? 1 : 0;
        	tmp -= c * 100;
        	bytes[offset + idx--] = digitEncode(isPositive, tmp);
        	
        	if(c==1) {
        		while(idx > 1){
        			tmp = getDecoPos(bytes[offset + idx]) + 1;
                	c = tmp >= 100 ? 1 : 0;
                	tmp -= c * 100;
                	bytes[offset + idx--] = digitEncode(isPositive, tmp);
        		}
        	}
        } else {
        	tmp = getDecoNeg(bytes[offset + idx]) + 1;
        	c = tmp >= 100 ? 1 : 0;
        	tmp -= c * 100;
        	bytes[offset + idx--] = digitEncode(isPositive, tmp);
        	
        	if(c==1) {
        		while(idx > 1){
        			tmp = getDecoNeg(bytes[offset + idx]) + 1;
                	c = tmp >= 100 ? 1 : 0;
                	tmp -= c * 100;
                	bytes[offset + idx--] = digitEncode(isPositive, tmp);
        		}
        	}
        }
        
        if(c==1) {
        	System.arraycopy(bytes, offset + 2, bytes, offset + 3, 19);
        	bytes[offset + 2] = digitEncode(isPositive, 1);
        	if(isPositive)
        		bytes[offset + 1] = (byte)(0x80 | (EXP_BIAS_POS + getExpPos(bytes[offset + 1]) + 1));
        	else
                bytes[offset + 1] = (byte)(EXP_BIAS_NEG - getExpNeg(bytes[offset + 1]) - 1);
        	
        	if(!isPositive)
                bytes[offset + 21] = NUMBER_TOP;
        	
            /* overflow or underflow error */
            if (exp + 1 > NUMBER_MAX_EXP)
                throw TbError.newSQLException(TbError.MU_NUMBER_OVERFLOW, str);
            if (exp + 1 < NUMBER_MIN_EXP)
                throw TbError.newSQLException(TbError.MU_NUMBER_UNDERFLOW, str);
        }
    }

    private static int getDecoNeg(byte coef) {
        byte deco = (byte)(0x80 - coef);

        return (deco < 0) ? deco + 256 : deco;
    }

    private static int getDecoPos(byte coef) {
        byte deco = (byte)(coef - 0x80);

        return (deco < 0) ? deco + 256 : deco;
    }

    private static int getExpNeg(byte x) {
        int signexp = x < 0 ? x + 256 : x;

        return EXP_BIAS_NEG - (signexp & NUMBER_MASK_EXP);
    }

    private static int getExpPos(byte x) {
        int signexp = x < 0 ? x + 256 : x;

        return (signexp & NUMBER_MASK_EXP) - EXP_BIAS_POS;
    }

    public static String getNormalForm(byte[] x, int offset, int length) {
        int i;
        int bufMax;
        int bufOff;
        int numWritten;
        int exp10, siglen10, posDecpoint;
        char[] buf = null;
        boolean isPositive;

        if (x[offset] == 1)
            return "0";

        isPositive = isPositive(x[offset + 1]);

        if (isPositive) {
            exp10 =
                (getExpPos(x[offset + 1]) << 1) +
                    (getDecoPos(x[offset + 2]) >= 10 ? 1 : 0);

            siglen10 =
                (getSiglen(x, offset) << 1) -
                    (getDecoPos(x[offset + 2]) < 10 ? 1 : 0) -
                    lastHalfFilledPos(x, offset);
        }
        else {
            exp10 =
                (getExpNeg(x[offset + 1]) << 1) +
                    (getDecoNeg(x[offset + 2]) >= 10 ? 1 : 0);

            siglen10 =
                (getSiglen(x, offset) << 1) -
                    (getDecoNeg(x[offset + 2]) < 10 ? 1 : 0) -
                    lastHalfFilledNeg(x, offset);
        }

        /* optional sign + digits before point + optional point +
         * optional digits after point + NULL */
        if (exp10 >= 0)
            bufMax =
                (isPositive ? 0 : 1) +
                    ((siglen10 <= (exp10 + 1)) ? ((exp10 + 1) + 0 + 0)
                        : ((exp10 + 1) + 1 + (siglen10 - (exp10 + 1)))) + 1;
        else
            bufMax = (isPositive ? 0 : 1) + 1 + (-exp10 - 1) + siglen10 + 1;

        buf = new char[bufMax];
        bufOff = 0;

        if (!isPositive)
            buf[bufOff++] = '-';

        posDecpoint = exp10 + 1;

        if (posDecpoint <= 0) {
            buf[bufOff++] = '.';
            for (i = 0; i < (-posDecpoint); i++) {
                buf[bufOff++] = '0';
            }
        }

        numWritten = convertCoef(x, offset, buf, bufOff, posDecpoint);

        bufOff += numWritten;

        for (i = 0; i < posDecpoint - numWritten; i++) {
            buf[bufOff++] = '0';
        }

        return new String(buf, 0, bufOff);
    }

    public static String getRoughSciForm(byte[] x, int offset, int length) {
        int bufOff;
        int bufMax;
        int exp10, siglen10, explen10;
        char[] buf;
        boolean isPositive;

        if (x[offset] == 1)
            return "0E+00";

        isPositive = isPositive(x[offset + 1]);

        if (isPositive) {
            exp10 =
                (getExpPos(x[offset + 1]) << 1) +
                    (getDecoPos(x[offset + 2]) >= 10 ? 1 : 0);

            siglen10 =
                (getSiglen(x, offset) << 1) -
                    (getDecoPos(x[offset + 2]) < 10 ? 1 : 0) -
                    lastHalfFilledPos(x, offset);
        }
        else {
            exp10 =
                (getExpNeg(x[offset + 1]) << 1) +
                    (getDecoNeg(x[offset + 2]) >= 10 ? 1 : 0);

            siglen10 =
                (getSiglen(x, offset) << 1) -
                    (getDecoNeg(x[offset + 2]) < 10 ? 1 : 0) -
                    lastHalfFilledNeg(x, offset);
        }

        explen10 = ((exp10 >= 100 || exp10 <= -100) ? 3 : 2);

        /* optional sign + coefficient + optional point + 'e' +
         * exp-sign + exp + NULL-character */
        bufMax =
            (isPositive ? 0 : 1) + siglen10 + (siglen10 > 1 ? 1 : 0) + 1 + 1 +
                explen10 + 1;

        buf = new char[bufMax];
        bufOff = 0;

        if (!isPositive)
            buf[bufOff++] = '-';

        bufOff += convertCoef(x, offset, buf, bufOff, 1);

        buf[bufOff++] = 'E';
        buf[bufOff++] = (exp10 >= 0 ? '+' : '-');

        bufOff += convertExp(exp10, bufOff, buf);

        return new String(buf, 0, bufOff);
    }

    public static int getSiglen(byte[] bytes, int offset) {
        int signexp = bytes[offset + 1];

        if (signexp < 0)
            signexp += 256;

        return (bytes[offset] - 1) - ((~signexp & NUMBER_MASK_SIGN) >> 7);
    }

    /* check if x is a non-extreme value */
    public static boolean isOrdinary(byte[] x, int offset) {
        return ((x[offset] == 0x01)  /* zero */
            || ((x[offset + 2] != NUMBER_TOP) && (x[offset + 2] != NUMBER_BOT)));
    }

    private static boolean isPositive(byte signexp) {
        if (signexp < 0)
            signexp += 256;

        return (signexp & NUMBER_MASK_SIGN) != 0;
    }

    public static boolean isValid(byte[] x, int offset) {
        /* Only for test */
        int nsize = x[offset];
        int nsignexp = x[offset + 1];

        if (nsize > NUMBER_MAX_LEN + 2)
            return false;

        if (nsignexp < 0)
            nsignexp += 256;

        switch (nsize) {
        case 0:
            break;

        case 1:
            /* zero */
            if (nsignexp == 0x80)
                return true;
            break;

        case 2:
            /* +inf || -0 */
            if (x[offset + 2] == 0xf0 &&
                (nsignexp == 0xff || nsignexp == 0x7f))
                return true;
            else if (x[offset + 2] == 0x10 &&
                     (nsignexp == 0x80 || nsignexp == 0x00))
                return true;

        default:
            if (nsignexp >= 0x80 && nsignexp <= 0xff) {
                /* positive */
                int i, esize, coef;

                esize = nsize - 2;
                for (i = 0; i <= esize; i++) {
                    coef = x[offset + 2 + i];
                    if (coef < 0)
                        coef += 256;

                    if (coef < 0x80 || coef > 0xe3)
                        return false;
                }

                return true;
            }
            else if (nsignexp >= 0x00 && nsignexp <= 0x7f) {
                /* negative */
                int i, esize, coef;

                esize = nsize - 2;
                for (i = 0; i < esize; i++) {
                    coef = x[offset + 2 + i];
                    if (coef < 0)
                        coef += 256;

                    if (coef < 0x1d || coef > 0x80)
                        return false;
                }

                return true;
            }
            break;
        }

        return false;
    }

    private static int lastHalfFilledNeg(byte[] x, int offset) {
        int coef = 0x80 - x[offset + 2 + getSiglen(x, offset) - 1];

        if (coef < 0)
            coef += 256;

        return (coef % 10 == 0) ? 1 : 0;
    }

    private static int lastHalfFilledPos(byte[] x, int offset) {
        int coef = x[offset + 2 + getSiglen(x, offset) - 1] - 0x80;

        if (coef < 0)
            coef += 256;

        return (coef % 10 == 0) ? 1 : 0;
    }

    /* returns true iff x <= y */
    private static boolean lessThanOrEqualTo(byte[] x, int xOff, byte[] y,
                                             int yOff) {
        int minsize = (x[xOff] <= y[yOff]) ? x[xOff] : y[yOff];

        for (int i = 1; i <= minsize; i++) {
            if ((byte)(128 + x[xOff + i]) < (byte)(128 + y[yOff + i]))
                return true;
            else if ((byte)(128 + x[xOff + i]) > (byte)(128 + y[yOff + i]))
                return false;
        }

        return (x[xOff] <= y[yOff]);
    }

    public static BigDecimal toBigDecimal(byte[] bytes, int offset, int length)
        throws SQLException {
        /* needs no range-check against BigDecimal */
        if (!isOrdinary(bytes, offset))
            throw TbError.newSQLException(TbError.INTERNAL_DATA_CONVERSION_FAIL);

        String normalForm = getNormalForm(bytes, offset, length);

        return new BigDecimal(normalForm);
    }

    public static double toDouble(byte[] bytes, int offset, int length)
        throws SQLException {
        String sciForm = getRoughSciForm(bytes, offset, length);

        return Double.valueOf(sciForm).doubleValue();
    }
    
    public static double toBinaryDouble(byte[] bytes, int offset, int length)
        throws SQLException {
        
        if (TbCommon.isPositiveInfinityDoubleBytes(bytes, offset, length)) {
            return Double.POSITIVE_INFINITY;
        }
        else if (TbCommon.isNegativeInfinityDoubleBytes(bytes, offset, length)) {
            return Double.NEGATIVE_INFINITY;
        }
        else if (TbCommon.isMaxValueDoubleBytes(bytes, offset, length)) {
            return Double.MAX_VALUE;
        }
        else if (TbCommon.isMinValueDoubleBytes(bytes, offset, length)) {
            return Double.MIN_VALUE;
        }
        else if (TbCommon.isNanDoubleBytes(bytes, offset, length)) {
            return Double.NaN;
        }
        else if (TbCommon.isNegativeZeroDoubleBytes(bytes, offset, length)) {
            return 0d;
        }
        else {
            double d;
            long longBits = TbCommon.bytes2Long(bytes, offset, length);
            if (longBits < 0) {
                d = Double.longBitsToDouble(longBits);
                d *= -1;
            }
            else if (longBits > 0) {
                longBits = ~longBits;
                d = Double.longBitsToDouble(longBits);
            }
            else {
                d = Double.longBitsToDouble(longBits);
            }
            return d;
        }
    }

    public static float toBinaryFloat(byte[] bytes, int offset, int length) {
        if (TbCommon.isPositiveInfinityFloatBytes(bytes, offset, length)) {
            return Float.POSITIVE_INFINITY;
        }
        else if (TbCommon.isNegativeInfinityFloatBytes(bytes, offset, length)) {
            return Float.NEGATIVE_INFINITY;
        }
        else if (TbCommon.isMaxValueFloatBytes(bytes, offset, length)) {
            return Float.MAX_VALUE;
        }
        else if (TbCommon.isMinValueFloatBytes(bytes, offset, length)) {
            return Float.MIN_VALUE;
        }
        else if (TbCommon.isNanFloatBytes(bytes, offset, length)) {
            return Float.NaN;
        }
        else if (TbCommon.isNegativeZeroFloatBytes(bytes, offset, length)) {
            return 0f;
        }
        else {
            float f;
            int intBits = TbCommon.bytes2Int(bytes, offset, length);
            if (intBits < 0) {
                f = Float.intBitsToFloat(intBits);
                f *= -1;
            }
            else if (intBits > 0) {
                intBits = ~intBits;
                f = Float.intBitsToFloat(intBits);
            }
            else {
                f = Float.intBitsToFloat(intBits);
            }
            return f;
        }
    }

    public static int toInteger(byte[] x, int offset, int length)
        throws SQLException {
        boolean isPositive;
        int i, exp, len;
        int tv = 0;

        if (x[offset] == 1)
            return 0;

        if (!isOrdinary(x, offset))
            throw TbError.newSQLException(TbError.INTERNAL_DATA_CONVERSION_FAIL);

        if (!lessThanOrEqualTo(MIN_INTEGER, 0, x, offset))
            throw TbError.newSQLException(TbError.MU_NUMBER_UNDERFLOW);

        if (!lessThanOrEqualTo(x, offset, MAX_INTEGER, 0))
            throw TbError.newSQLException(TbError.MU_NUMBER_OVERFLOW);

        isPositive = isPositive(x[offset + 1]);

        if (isPositive) {
            exp = getExpPos(x[offset + 1]);

            len = getSiglen(x, offset);
            len = (len > exp + 1 ? exp + 1 : len);

            for (i = 0; i < len; ++i) {
                tv = tv * NUMBER_BASE + getDecoPos(x[offset + 2 + i]);
            }
        }
        else {
            exp = getExpNeg(x[offset + 1]);

            len = getSiglen(x, offset);
            len = (len > exp + 1 ? exp + 1 : len);

            for (i = 0; i < len; ++i) {
                tv = tv * NUMBER_BASE + getDecoNeg(x[offset + 2 + i]);
            }
        }

        for (i = 0; i < exp + 1 - len; ++i) {
            tv *= NUMBER_BASE;
        }

        return isPositive ? tv : -tv;
    }

    public static long toLong(byte[] x, int offset, int length)
        throws SQLException {
        boolean isPositive;
        int i, exp, len;
        long tv = 0;

        if (x[offset] == 1)
            return 0;

        if (!isOrdinary(x, offset))
            throw TbError.newSQLException(TbError.INTERNAL_DATA_CONVERSION_FAIL);

        if (!lessThanOrEqualTo(MIN_LONG, 0, x, offset))
            throw TbError.newSQLException(TbError.MU_NUMBER_UNDERFLOW);

        if (!lessThanOrEqualTo(x, offset, MAX_LONG, 0))
            throw TbError.newSQLException(TbError.MU_NUMBER_OVERFLOW);

        isPositive = isPositive(x[offset + 1]);

        if (isPositive) {
            exp = getExpPos(x[offset + 1]);

            len = getSiglen(x, offset);
            len = (len > exp + 1 ? exp + 1 : len);

            for (i = 0; i < len; ++i) {
                tv = tv * NUMBER_BASE + getDecoPos(x[offset + 2 + i]);
            }
        }
        else {
            exp = getExpNeg(x[offset + 1]);

            len = getSiglen(x, offset);
            len = (len > exp + 1 ? exp + 1 : len);

            for (i = 0; i < len; ++i) {
                tv = tv * NUMBER_BASE + getDecoNeg(x[offset + 2 + i]);
            }
        }

        for (i = 0; i < exp + 1 - len; ++i) {
            tv *= NUMBER_BASE;
        }

        return isPositive ? tv : -tv;
    }

    private static byte[] toZero() {
        return (new byte[] {(byte)0x01, (byte)0x80});
    }

    private static int toZero(byte [] buf, int offset) {
        buf[offset] = (byte)0x01;
        buf[offset + 1] = (byte)0x80;
        return 2;
    }

    private TbNumber() {
    }
}
