package com.tmax.tibero.jdbc.driver;

import com.tmax.tibero.jdbc.data.BigLiteral;
import com.tmax.tibero.jdbc.data.DataTypeConverter;
import com.tmax.tibero.jdbc.data.RsetType;
import com.tmax.tibero.jdbc.err.TbError;
import com.tmax.tibero.jdbc.msg.TbPivotInfo;
import com.tmax.tibero.jdbc.util.TbSQLParser;
import com.tmax.tibero.jdbc.util.TbSQLTypeScanner;
import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

public class TbStatement extends TbStatement {
  protected int queryTimeout = 0;
  
  protected int fetchDirection = 1000;
  
  protected int maxRow = 0;
  
  protected int sqlType = 0;
  
  protected TbConnection conn;
  
  protected DataTypeConverter typeConverter;
  
  protected RsetType userRsetType;
  
  protected RsetType realRsetType;
  
  protected String originalSql;
  
  protected String sqlWithRowId;
  
  protected boolean rsetTypeDowngraded;
  
  protected SQLWarning warnings;
  
  protected TbSQLTypeScanner sqlTypeScanner;
  
  protected boolean enableEscapeProcessing = true;
  
  private boolean closed;
  
  private boolean closeOnCompletion;
  
  protected boolean isExecuting;
  
  protected List<String> batchStmts;
  
  protected int[] batchCounts;
  
  protected TbResultSet currentRs;
  
  protected ArrayList<TbResultSet> subResultSets;
  
  protected long rowsUpdated = -1L;
  
  protected boolean noMoreUpdateCount;
  
  protected int curCsrId = -1;
  
  protected int maxFieldSize = 65535;
  
  protected int preFetchSize = 64000;
  
  protected int fetchSize = this.preFetchSize;
  
  protected TbPivotInfo[] pivotInfo;
  
  protected Vector<byte[]> pivotData = (Vector)new Vector<byte>();
  
  protected boolean returnAutoGeneratedKeys = false;
  
  protected boolean poolable;
  
  protected boolean defaultNChar = false;
  
  private TbSQLParser sqlParser;
  
  public TbStatement(TbConnection paramTbConnection) {
    this(paramTbConnection, 1003, 1007, 64000);
  }
  
  public TbStatement(TbConnection paramTbConnection, int paramInt1, int paramInt2, int paramInt3) {
    this.conn = paramTbConnection;
    this.typeConverter = paramTbConnection.typeConverter;
    this.userRsetType = RsetType.getRsetType(paramInt1, paramInt2);
    this.preFetchSize = paramInt3;
    this.fetchSize = paramInt3;
    this.closed = false;
    this.isExecuting = false;
    this.subResultSets = new ArrayList<TbResultSet>();
    this.poolable = paramTbConnection.info.isStmtCache();
    this.rsetTypeDowngraded = false;
    this.defaultNChar = this.conn.info.getDefaultNChar();
    this.sqlParser = new TbSQLParser();
  }
  
  public synchronized void addBatch(String paramString) throws SQLException {
    if (this.batchStmts == null)
      this.batchStmts = new ArrayList<String>(); 
    this.batchStmts.add(paramString);
  }
  
  public void addPivotData(byte[] paramArrayOfbyte) {
    this.pivotData.add(paramArrayOfbyte);
  }
  
  public void addWarning(SQLWarning paramSQLWarning) {
    if (this.warnings != null) {
      this.warnings.setNextWarning(paramSQLWarning);
    } else {
      this.warnings = paramSQLWarning;
    } 
  }
  
  public void cancel() throws SQLException {
    if (this.closed || this.conn == null || this.conn.isClosed())
      return; 
    if (this.isExecuting)
      this.conn.getTbComm().cancelStatement(); 
  }
  
  protected void checkBatchStmtRemained() throws SQLException {
    if (this.batchStmts.size() > 0)
      throw TbError.newSQLException(-90606); 
  }
  
  protected void checkConnectionOpen() throws SQLException {
    if (this.conn == null || this.conn.isClosed())
      throw TbError.newSQLException(-90603); 
  }
  
  public synchronized void clearBatch() throws SQLException {
    if (this.batchStmts != null) {
      this.batchStmts.clear();
      this.batchStmts = null;
    } 
  }
  
  public void clearWarnings() throws SQLException {
    this.warnings = null;
  }
  
  public synchronized void close() throws SQLException {
    if (this.conn != null && this.conn.getStmtCache() != null && this.conn.getStmtCache().add(this, 0))
      return; 
    closeInternal();
  }
  
  public synchronized void closeInternal() throws SQLException {
    try {
      closeResultSets();
    } catch (SQLException sQLException) {
    
    } finally {
      reset();
    } 
  }
  
  private void closeResultSets() throws SQLException {
    if (this.subResultSets.size() > 0) {
      for (ResultSet resultSet : this.subResultSets) {
        try {
          resultSet.close();
        } catch (SQLException sQLException) {}
      } 
      this.subResultSets.removeAll(this.subResultSets);
    } 
    if (this.currentRs != null) {
      this.currentRs.close();
      this.currentRs = null;
    } 
  }
  
  public synchronized boolean execute(String paramString) throws SQLException {
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    this.returnAutoGeneratedKeys = false;
    if (this.queryTimeout != 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      executeInternal(paramString);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
    return (this.currentRs != null);
  }
  
  public boolean execute(String paramString, int paramInt) throws SQLException {
    if (paramInt == 2)
      return execute(paramString); 
    if (paramInt != 1)
      TbError.newSQLException(-590733); 
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    this.returnAutoGeneratedKeys = true;
    if (this.queryTimeout != 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      executeInternal(paramString);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
    return false;
  }
  
  public boolean execute(String paramString, int[] paramArrayOfint) throws SQLException {
    if (paramArrayOfint == null || paramArrayOfint.length == 0)
      TbError.newSQLException(-590732); 
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    this.returnAutoGeneratedKeys = true;
    if (this.queryTimeout != 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      executeInternal(paramString, paramArrayOfint);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
    return false;
  }
  
  public boolean execute(String paramString, String[] paramArrayOfString) throws SQLException {
    if (paramArrayOfString == null || paramArrayOfString.length == 0)
      TbError.newSQLException(-590734); 
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    this.returnAutoGeneratedKeys = true;
    if (this.queryTimeout != 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      executeInternal(paramString, paramArrayOfString);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
    return false;
  }
  
  boolean isInsertStmt(String paramString) {
    return (paramString != null) ? ((this.sqlType == 36)) : false;
  }
  
  public synchronized int[] executeBatch() throws SQLException {
    checkConnectionOpen();
    initBeforeExecute();
    if (this.batchStmts == null)
      return new int[0]; 
    int i = this.batchStmts.size();
    if (i <= 0)
      return new int[0]; 
    this.batchCounts = new int[i];
    byte b = 0;
    try {
      if (this.queryTimeout != 0)
        this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
      this.isExecuting = true;
      for (b = 0; b < i; b++) {
        this.batchCounts[b] = executeInternal((String)this.batchStmts.get(b));
        if (this.currentRs != null)
          throw TbError.newSQLException(-90630); 
      } 
      return this.batchCounts;
    } catch (SQLException sQLException) {
      int[] arrayOfInt = new int[b];
      System.arraycopy(this.batchCounts, 0, arrayOfInt, 0, b);
      this.batchCounts = arrayOfInt;
      throw new BatchUpdateException(sQLException.getMessage(), sQLException.getSQLState(), sQLException.getErrorCode(), this.batchCounts);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
      clearBatch();
    } 
  }
  
  private synchronized int executeInternal(String paramString) throws SQLException {
    return executeInternal(paramString, null);
  }
  
  private synchronized int executeInternal(String paramString, Object paramObject) throws SQLException {
    initSql(paramString);
    if (!isInsertStmt(paramString))
      this.returnAutoGeneratedKeys = false; 
    int i = this.conn.typeConverter.getMaxBytesPerChar();
    if (this.originalSql.length() > 65535 / i) {
      ArrayList<BigLiteral> arrayList = new ArrayList();
      String str = TbSQLParser.getBigLiteral(this.originalSql, i, arrayList);
      int j = arrayList.size();
      if (j > 0) {
        TbPreparedStatement tbPreparedStatement = (TbPreparedStatement)this.conn.prepareStatement(str);
        for (byte b = 0; b < j; b++) {
          BigLiteral bigLiteral = arrayList.get(b);
          tbPreparedStatement.setString(b + 1, bigLiteral.getLiteralValue());
        } 
        arrayList.clear();
        return tbPreparedStatement.impl().executeInternal(str);
      } 
    } 
    if (TbSQLTypeScanner.isQueryStmt(this.sqlType)) {
      if (this.userRsetType.getType() == 1005 || this.userRsetType.getConcurrency() == 1008) {
        this.sqlWithRowId = getQueryWithRowId(this.originalSql);
        try {
          this.realRsetType = this.userRsetType;
          synchronized (this.conn) {
            return this.conn.getTbComm().executeDirect(this, this.sqlWithRowId);
          } 
        } catch (SQLException sQLException) {
          this.realRsetType = RsetType.getDownGradedRsetType(this.userRsetType.getRank());
          synchronized (this.conn) {
            return this.conn.getTbComm().executeDirect(this, this.originalSql);
          } 
        } 
      } 
      try {
        this.realRsetType = this.userRsetType;
        synchronized (this.conn) {
          return this.conn.getTbComm().executeDirect(this, this.originalSql);
        } 
      } catch (SQLException sQLException) {
        if (this.conn.isClosed() || !this.conn.info.isFailoverCursorEnabled() || sQLException.getErrorCode() != -90700)
          throw sQLException; 
        synchronized (this.conn) {
          int j = this.conn.getTbComm().executeDirect(this, this.originalSql);
          addWarning(TbError.newSQLWarning(-90700, sQLException));
          return j;
        } 
      } 
    } 
    if (TbSQLTypeScanner.isDMLStmt(this.sqlType) || (!TbSQLTypeScanner.isQueryStmt(this.sqlType) && !TbSQLTypeScanner.isPSMStmt(this.sqlType))) {
      this.realRsetType = this.userRsetType;
      String str = this.originalSql;
      if (this.returnAutoGeneratedKeys) {
        if (this.realRsetType.isSensitive() || this.realRsetType.isUpdatable())
          this.realRsetType = RsetType.SIRD; 
        if (paramObject == null) {
          str = getAutoGenSql(this.originalSql);
        } else if (paramObject instanceof int[]) {
          str = getAutoGenSql(this.originalSql, (int[])paramObject);
        } else if (paramObject instanceof String[]) {
          str = getAutoGenSql(this.originalSql, (String[])paramObject);
        } 
      } 
      synchronized (this.conn) {
        this.rowsUpdated = this.conn.getTbComm().executeDirect(this, str);
      } 
      return (int)this.rowsUpdated;
    } 
    this.realRsetType = this.userRsetType;
    synchronized (this.conn) {
      return this.conn.getTbComm().executeDirect(this, this.originalSql);
    } 
  }
  
  protected String getAutoGenSql(String paramString) {
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append(paramString).append(" RETURNING ROWID INTO GENKEY0");
    return stringBuffer.toString();
  }
  
  protected String getAutoGenSql(String paramString, String[] paramArrayOfString) {
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append(paramString).append(" RETURNING ");
    int i = paramArrayOfString.length;
    byte b;
    for (b = 0; b < i; b++) {
      if (b > 0)
        stringBuffer.append(", "); 
      stringBuffer.append(paramArrayOfString[b]);
    } 
    stringBuffer.append(" INTO ");
    for (b = 0; b < i; b++) {
      if (b > 0)
        stringBuffer.append(", "); 
      stringBuffer.append("GENKEY").append(b);
    } 
    return stringBuffer.toString();
  }
  
  protected String getAutoGenSql(String paramString, int[] paramArrayOfint) throws SQLException {
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append(paramString).append(" RETURNING ");
    int i = paramArrayOfint.length;
    int j = paramString.toUpperCase().indexOf("INTO", this.sqlTypeScanner.getCurrentIndex());
    if (j < 0)
      TbError.newSQLException(-90608); 
    int k = paramString.length();
    int m;
    for (m = j + 5; m < k && paramString.charAt(m) == ' '; m++);
    if (m >= k)
      TbError.newSQLException(-90608); 
    int n;
    for (n = m + 1; n < k && paramString.charAt(n) != ' ' && paramString.charAt(n) != '('; n++);
    String str = paramString.substring(m, n);
    Statement statement = null;
    try {
      statement = this.conn.createStatement();
      ResultSet resultSet = statement.executeQuery("SELECT * FROM " + str);
      ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
      int i1 = resultSetMetaData.getColumnCount();
      byte b;
      for (b = 0; b < i; b++) {
        if (paramArrayOfint[b] < 1 || paramArrayOfint[b] > i1)
          TbError.newSQLException(-90608); 
        if (b > 0)
          stringBuffer.append(", "); 
        stringBuffer.append(resultSetMetaData.getColumnName(paramArrayOfint[b]));
      } 
      stringBuffer.append(" INTO ");
      for (b = 0; b < i; b++) {
        if (b > 0)
          stringBuffer.append(", "); 
        stringBuffer.append("GENKEY").append(b);
      } 
      return stringBuffer.toString();
    } finally {
      if (statement != null)
        try {
          statement.close();
        } catch (Exception exception) {} 
    } 
  }
  
  public synchronized ResultSet executeQuery(String paramString) throws SQLException {
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    if (this.queryTimeout > 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      executeInternal(paramString);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout > 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
    if (this.currentRs == null)
      this.currentRs = TbResultSetFactory.buildResultSet(this, -1, 0, 0, null); 
    return (ResultSet)this.currentRs;
  }
  
  public synchronized int executeUpdate(String paramString) throws SQLException {
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    this.returnAutoGeneratedKeys = false;
    if (this.queryTimeout != 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      return executeInternal(paramString);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
  }
  
  public int executeUpdate(String paramString, int paramInt) throws SQLException {
    if (paramInt == 2)
      return executeUpdate(paramString); 
    if (paramInt != 1)
      TbError.newSQLException(-590733); 
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    this.returnAutoGeneratedKeys = true;
    if (this.queryTimeout != 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      return executeInternal(paramString);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
  }
  
  public int executeUpdate(String paramString, int[] paramArrayOfint) throws SQLException {
    if (paramArrayOfint == null || paramArrayOfint.length == 0)
      TbError.newSQLException(-590732); 
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    this.returnAutoGeneratedKeys = true;
    if (this.queryTimeout != 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      return executeInternal(paramString, paramArrayOfint);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
  }
  
  public int executeUpdate(String paramString, String[] paramArrayOfString) throws SQLException {
    if (paramArrayOfString == null || paramArrayOfString.length == 0)
      TbError.newSQLException(-590732); 
    checkConnectionOpen();
    if (this.batchStmts != null) {
      checkBatchStmtRemained();
      initBatchStmts();
    } 
    initBeforeExecute();
    this.returnAutoGeneratedKeys = true;
    if (this.queryTimeout != 0)
      this.conn.getTimeout().setTimeout((this.queryTimeout * 1000), this); 
    try {
      this.isExecuting = true;
      return executeInternal(paramString, paramArrayOfString);
    } finally {
      this.isExecuting = false;
      if (this.queryTimeout != 0)
        this.conn.getTimeout().cancelTimeout(); 
    } 
  }
  
  public synchronized void fetch(TbResultSetBase paramTbResultSetBase) throws SQLException {
    synchronized (this.conn) {
      this.conn.getTbComm().fetch(this, paramTbResultSetBase);
    } 
  }
  
  public Connection getConnection() throws SQLException {
    checkConnectionOpen();
    return (Connection)this.conn;
  }
  
  public int getCurCsrId() {
    return this.curCsrId;
  }
  
  public int getFetchDirection() throws SQLException {
    return this.fetchDirection;
  }
  
  public int getFetchSize() throws SQLException {
    return this.fetchSize;
  }
  
  public ResultSet getGeneratedKeys() throws SQLException {
    if (this.returnAutoGeneratedKeys)
      return (ResultSet)this.currentRs; 
    throw TbError.newSQLException(-90600);
  }
  
  public int getMaxFieldSize() throws SQLException {
    return this.maxFieldSize;
  }
  
  public int getMaxRows() throws SQLException {
    return this.maxRow;
  }
  
  public synchronized boolean getMoreResults() throws SQLException {
    return false;
  }
  
  public boolean getMoreResults(int paramInt) throws SQLException {
    throw TbError.newSQLException(-90201);
  }
  
  public String getOriginalSql() {
    return this.originalSql;
  }
  
  protected void initSql(String paramString) throws SQLException {
    if (paramString == null || paramString.length() <= 0)
      throw TbError.newSQLException(-590737); 
    String str = null;
    if (this.conn.serverInfo.getServerCharSet() == 3) {
      str = TbSQLParser.replaceIDEOGraphicSpace(paramString);
    } else {
      str = paramString;
    } 
    this.sqlTypeScanner = new TbSQLTypeScanner();
    str = this.sqlTypeScanner.callDeclareSyntax(str);
    this.sqlType = this.sqlTypeScanner.getSQLType(str);
    if (136 != this.sqlType) {
      if (this.enableEscapeProcessing && str.indexOf('{') >= 0)
        str = this.sqlParser.parse(str); 
      if (str.indexOf('?') > 0)
        str = TbSQLParser.replace(str); 
    } 
    this.originalSql = str;
  }
  
  public Vector<byte[]> getPivotData() {
    return this.pivotData;
  }
  
  public TbPivotInfo[] getPivotInfo() {
    return this.pivotInfo;
  }
  
  public int getPreFetchSize() {
    return (TbSQLTypeScanner.isQueryStmt(getSqlType()) && getRealRsetType().getType() != 1005) ? this.preFetchSize : 0;
  }
  
  public int getQueryTimeout() throws SQLException {
    return this.queryTimeout;
  }
  
  protected String getQueryWithRowId(String paramString) {
    StringBuffer stringBuffer = new StringBuffer(100);
    String str = paramString.toUpperCase();
    int i = str.lastIndexOf("FOR");
    int j = str.lastIndexOf("UPDATE");
    if (str.lastIndexOf("\"") < i && i < j) {
      stringBuffer.append(paramString).append(") ROWID_ALIAS0");
      stringBuffer.delete(i, i + 3);
      stringBuffer.delete(j - 3, j + 3);
      stringBuffer.insert(0, "select ROWIDTOCHAR(ROWID) _ROWID_CHAR0_, ROWID_ALIAS0.* from (");
      stringBuffer.append(" FOR UPDATE");
    } else {
      stringBuffer.append("select ROWIDTOCHAR(ROWID) _ROWID_CHAR0_, ROWID_ALIAS0.* from (").append(paramString).append(") ROWID_ALIAS0");
    } 
    return stringBuffer.toString();
  }
  
  public RsetType getUserRsetType() {
    return this.userRsetType;
  }
  
  public RsetType getRealRsetType() {
    return this.realRsetType;
  }
  
  public ResultSet getResultSet() throws SQLException {
    return (ResultSet)(this.returnAutoGeneratedKeys ? null : this.currentRs);
  }
  
  public int getResultSetConcurrency() throws SQLException {
    return this.userRsetType.getConcurrency();
  }
  
  public int getResultSetHoldability() throws SQLException {
    return this.userRsetType.getHoldability();
  }
  
  public int getResultSetType() throws SQLException {
    return this.userRsetType.getType();
  }
  
  public int getSqlType() {
    return this.sqlType;
  }
  
  public String getSqlWithRowId() {
    return this.sqlWithRowId;
  }
  
  public int getUpdateCount() throws SQLException {
    if (this.batchCounts != null) {
      int i = 0;
      for (byte b = 0; b < this.batchCounts.length; b++)
        i += this.batchCounts[b]; 
      return i;
    } 
    if (!this.noMoreUpdateCount) {
      this.noMoreUpdateCount = true;
      return (int)this.rowsUpdated;
    } 
    return -1;
  }
  
  public SQLWarning getWarnings() throws SQLException {
    return this.warnings;
  }
  
  protected void initBatchStmts() {
    if (this.batchStmts != null) {
      this.batchStmts.clear();
      this.batchStmts = null;
    } 
  }
  
  protected void initBeforeExecute() throws SQLException {
    this.batchCounts = null;
    this.rowsUpdated = -1L;
    this.noMoreUpdateCount = false;
    if (this.currentRs != null) {
      this.currentRs.close();
      this.currentRs = null;
    } 
  }
  
  public boolean isClosed() throws SQLException {
    return this.closed;
  }
  
  public boolean isPoolable() throws SQLException {
    if (isClosed())
      throw TbError.newSQLException(-90659); 
    return this.poolable;
  }
  
  public boolean isWrapperFor(Class<?> paramClass) throws SQLException {
    return paramClass.isInstance(this);
  }
  
  protected void reset() {
    this.closed = true;
    this.closeOnCompletion = false;
    this.warnings = null;
    this.conn = null;
    this.typeConverter = null;
    this.userRsetType = null;
    this.noMoreUpdateCount = false;
    this.returnAutoGeneratedKeys = false;
    this.currentRs = null;
    this.batchCounts = null;
    this.maxRow = 0;
    this.rsetTypeDowngraded = false;
    this.subResultSets.removeAll(this.subResultSets);
    if (this.batchStmts != null) {
      this.batchStmts.clear();
      this.batchStmts = null;
    } 
  }
  
  public void resetForCache() {
    this.currentRs = null;
    this.batchCounts = null;
    this.warnings = null;
    this.subResultSets.removeAll(this.subResultSets);
    if (this.batchStmts != null) {
      this.batchStmts.clear();
      this.batchStmts = null;
    } 
  }
  
  public void setCurCsrId(int paramInt) {
    this.curCsrId = paramInt;
  }
  
  public void setCursorName(String paramString) throws SQLException {}
  
  public synchronized void setEscapeProcessing(boolean paramBoolean) throws SQLException {
    this.enableEscapeProcessing = paramBoolean;
  }
  
  public synchronized void setFetchDirection(int paramInt) throws SQLException {
    switch (paramInt) {
      case 1000:
      case 1002:
        this.fetchDirection = 1000;
        return;
      case 1001:
        this.fetchDirection = 1001;
        break;
    } 
    throw TbError.newSQLException(-590738);
  }
  
  public synchronized void setFetchSize(int paramInt) throws SQLException {
    if (paramInt == 0) {
      this.fetchSize = 50;
    } else if (paramInt > 0) {
      this.fetchSize = paramInt;
    } else {
      throw TbError.newSQLException(-590735);
    } 
  }
  
  public synchronized void setPreparedFetchSize(int paramInt) throws SQLException {
    if (paramInt == 0) {
      this.fetchSize = 50;
    } else if (paramInt > 0) {
      this.fetchSize = (paramInt > 64) ? -64 : (paramInt * -1);
    } else {
      throw TbError.newSQLException(-590735);
    } 
  }
  
  public void setMaxFieldSize(int paramInt) throws SQLException {
    if (paramInt < 0)
      throw TbError.newSQLException(-590739); 
    this.maxFieldSize = paramInt;
  }
  
  public synchronized void setMaxRows(int paramInt) throws SQLException {
    if (paramInt < 0)
      throw TbError.newSQLException(-590740); 
    this.maxRow = paramInt;
  }
  
  public void setPivotInfo(TbPivotInfo[] paramArrayOfTbPivotInfo) {
    this.pivotInfo = paramArrayOfTbPivotInfo;
  }
  
  public void setPoolable(boolean paramBoolean) throws SQLException {
    this.poolable = paramBoolean;
  }
  
  public synchronized void setQueryTimeout(int paramInt) throws SQLException {
    if (paramInt < 0)
      throw TbError.newSQLException(-590741); 
    this.queryTimeout = paramInt;
  }
  
  public void setResultSet(TbResultSet paramTbResultSet) {
    this.currentRs = paramTbResultSet;
  }
  
  public void addSubResultSet(TbResultSet paramTbResultSet) {
    this.subResultSets.add(paramTbResultSet);
  }
  
  public synchronized void setRowPreFetch(int paramInt) throws SQLException {
    if (paramInt < 0)
      throw TbError.newSQLException(-590735); 
    this.preFetchSize = paramInt;
    if (paramInt == 0) {
      setFetchSize(50);
    } else {
      setFetchSize(paramInt);
    } 
  }
  
  public <T> T unwrap(Class<T> paramClass) throws SQLException {
    try {
      return paramClass.cast(this);
    } catch (ClassCastException classCastException) {
      throw TbError.newSQLException(-90657);
    } 
  }
  
  boolean isReturnAutoGeneratedKeys() {
    return this.returnAutoGeneratedKeys;
  }
  
  protected void setReturnAutoGeneratedKeys(boolean paramBoolean) {
    this.returnAutoGeneratedKeys = paramBoolean;
  }
}


/* Location:              C:\Users\Lenovo\Desktop\tibero\tibero6-jdbc.jar!\com\tmax\tibero\jdbc\driver\TbStatement.class
 * Java compiler version: 6 (50.0)
 * JD-Core Version:       1.1.3
 */