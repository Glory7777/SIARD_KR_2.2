/**
 * Copyright (c) 2011-, TmaxData, Inc. / Seoul, Republic of Korea
 *
 * This document contains proprietary and confidential information.  No
 * parts of this document or the computer program it embodies may be in
 * any way copied, duplicated, reproduced, translated into a different
 * programming language, or distributed to any person, company, or
 * corporation without the prior written consent of Tibero, Inc.
 */
package tibero.jdbc.driver;

import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import tibero.Debug;
import tibero.DriverConstants;
import tibero.jdbc.data.BigLiteral;
import tibero.jdbc.data.DataTypeConverter;
import tibero.jdbc.data.RsetType;
import tibero.jdbc.data.charset.Charset;
import tibero.jdbc.err.TbError;
import tibero.jdbc.ext.TbStatementCache;
import tibero.jdbc.msg.TbPivotInfo;
import tibero.jdbc.util.TbSQLParser;
import tibero.jdbc.util.TbSQLTypeScanner;

/**
 * TbStatement class.
 * 
 * @author yjlee@tmax.co.kr, wyvern@tmax.co.kr, kskim@tmax.co.kr
 * @version $Id: TbStatement.java 179428 2020-06-30 06:25:30Z jihun_park $
 */
public class TbStatement extends tibero.jdbc.TbStatement {
    protected int queryTimeout = 0;
    protected int fetchDirection = ResultSet.FETCH_FORWARD;
    protected int maxRow = 0;
    protected int sqlType = TbSQLTypeScanner.STMT_UNKNOWN;
    protected TbConnection conn;
    protected DataTypeConverter typeConverter;
    /* resultset type which user defines */
    protected RsetType userRsetType;
    /* resultset type which used really */
    protected RsetType realRsetType;
    /* escaped processed sql */
    protected String originalSql;
    /* rowid is attached at SELECT */
    protected String sqlWithRowId;
    protected boolean rsetTypeDowngraded;
    protected SQLWarning warnings;
    protected TbSQLTypeScanner sqlTypeScanner;
    protected boolean enableEscapeProcessing = true;
    private boolean closed;
    protected boolean isExecuting;
    /* batch update list */
    protected List
        // #ifdef JDK1.5
        <String>
        // #endif
                batchStmts;
    protected int[] batchCounts;
    protected TbResultSet currentRs;
    protected ArrayList 
        // #ifdef JDK1.5
        <TbResultSet>
        // #endif
                subResultSets;
    protected int rowsUpdated = -1;
    protected boolean noMoreUpdateCount;
    /* current cursor id */
    protected int curCsrId = -1;
    protected int maxFieldSize = DriverConstants.MAX_FIELD_SIZE;
    /* prefetch size */
    protected int preFetchSize = DriverConstants.PRE_FETCH_SIZE;
    protected int fetchSize = preFetchSize;
    /* pivot chunk */
    protected TbPivotInfo[] pivotInfo;
    protected Vector 
        // #ifdef JDK1.5
        <byte[]>
        // #endif
            pivotData = new Vector
                // #ifdef JDK1.5
                <byte[]>
                // #endif
            ();
    // for auto generate values
    protected boolean returnAutoGeneratedKeys = false;
    
    protected boolean poolable;
    protected boolean defaultNChar = false;
    private TbSQLParser sqlParser;

    public TbStatement(TbConnection conn) {
        this(conn, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
             DriverConstants.PRE_FETCH_SIZE);
    }

    public TbStatement(TbConnection conn1, int rsetType, int rsetConcur,
                       int size) {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement", new Object[] {this});
        }

        conn = conn1;
        typeConverter = conn1.typeConverter;
        userRsetType = RsetType.getRsetType(rsetType, rsetConcur);
        preFetchSize = size;
        fetchSize = size;
        closed = false;
        isExecuting = false;
        subResultSets = new ArrayList 
            // #ifdef JDK1.5
            <TbResultSet>
            // #endif
            ();
        poolable = conn1.info.isStmtCache();
        rsetTypeDowngraded = false;
        defaultNChar = conn.info.getDefaultNChar();
        sqlParser = new TbSQLParser();
    }

    /**
     * Adds an SQL command to the current batch of commmands for this
     * <code>Statement</code> object. This method is optional.
     *
     * @param sql
     *            typically this is a static SQL <code>INSERT</code> or
     *            <code>UPDATE</code> statement
     * @throws SQLException
     *             if a database access error occurs, or the driver does not
     *             support batch statements
     * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0
     *      API</a>
     * @since 1.2
     */
    public synchronized void addBatch(String sql) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.addBatch", new Object[] {this});
        }

        if (batchStmts == null)
            batchStmts = new ArrayList
                                // #ifdef JDK1.5
                                <String>
                                // #endif
                                ();

        batchStmts.add(sql);
    }

    public void addPivotData(byte[] data) {
        pivotData.add(data);
    }

    public void addWarning(SQLWarning warning) {
        if (warnings != null)
            warnings.setNextWarning(warning);
        else
            warnings = warning;
    }

    /**
     * Cancels this <code>Statement</code> object if both the DBMS and driver
     * support aborting an SQL statement. This method can be used by one thread
     * to cancel a statement that is being executed by another thread.
     *
     * @throws SQLException
     *             if a database access error occurs
     */
    public void cancel() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.cancel", new Object[] {this});
        }

        if (closed || conn == null || conn.isClosed())
            return;

        if (isExecuting) {
            conn.getTbComm().cancelStatement();
        }
    }

    /**
     * if there are statements not been execute, throw exception
     *
     * @throws SQLException
     */
    protected void checkBatchStmtRemained() throws SQLException {
        if (batchStmts.size() > 0)
            throw TbError.newSQLException(TbError.MU_NOT_EXECUTED_BATCH);
    }

    /**
     * check this statement's connection is on
     *
     * @throws SQLException
     *             if connection is not valid or closed
     */
    protected void checkConnectionOpen() throws SQLException {
        if (conn == null || conn.isClosed())
            throw TbError.newSQLException(TbError.MU_ACTION_ON_CLOSED_CONNECTION);
    }

    /**
     * Makes the set of commands in the current batch empty. This method is
     * optional.
     *
     * @throws SQLException
     *             if a database access error occurs or the driver does not
     *             support batch statements
     * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0
     *      API</a>
     * @since 1.2
     */
    public synchronized void clearBatch() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.clearBatch", new Object[] {this});
        }

        if (batchStmts != null) {
            batchStmts.clear();
            batchStmts = null;
        }
    }

    /**
     * Clears all the warnings reported on this <code>Statement</code> object.
     * After a call to this method, the method <code>getWarnings</code> will
     * return <code>null</code> until a new warning is reported for this
     * <code>Statement</code> object.
     *
     * @throws SQLException
     *             if a database access error occurs
     */
    public void clearWarnings() throws SQLException {
        warnings = null;
    }

    /**
     * Releases this <code>Statement</code> object's database and JDBC resources
     * immediately instead of waiting for this to happen when it is
     * automatically closed. It is generally good practice to release resources
     * as soon as you are finished with them to avoid tying up database
     * resources.
     * <P>
     * <B>Note:</B> A <code>Statement</code> object is automatically closed when
     * it is garbage collected. When a <code>Statement</code> object is closed,
     * its current <code>ResultSet</code> object, if one exists, is also closed.
     *
     * @exception SQLException
     *                if a database access error occurs
     */
    public synchronized void close() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.close", new Object[] {this});
        }

        if (conn != null && conn.getStmtCache() != null) {
            if (Debug.TRACE) {
                Debug.log("TbStatement.close (CACHE ADDED)");
            }

            if (conn.getStmtCache().add(this, TbStatementCache.ENTRY_TYPE_TBSTATEMENT)) {
                return;
            }
        }

        closeInternal();
    }
    
    public synchronized void closeInternal() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.closeInternal", new Object[] {this});
        }
        
        try {
            closeResultSets();
        }
        catch (SQLException e) {
            if (Debug.TRACE) {
                Debug.log("TbStatement.close (FAILED) : " + e.getMessage());
            }
        }
        finally {
            reset();
        }
    }

    /**
     * close opened result set
     *
     * @throws SQLException
     */
    private void closeResultSets() throws SQLException {
        if (subResultSets.size() > 0) {
            Iterator
                // #ifdef JDK1.5
                <TbResultSet>
                // #endif
                    it = subResultSets.iterator();
            while (it.hasNext()) {
                ResultSet rs = (ResultSet) it.next();
                try {
                    rs.close();
                } catch (SQLException e) {
                    /* 
                     * sub resultset�� ��� close�� ���� ���� ��,
                     * ����ڿ��Ա��� �˸��� �ʰ� �����Ѵ�. 
                     * �׸��� ���� sub resultset�� �ݵ����Ѵ�.
                     * ���� resultset�� ������ �ʴ°��� �����ϱ� ����.
                     */
                }
            }
            subResultSets.removeAll(subResultSets);
        }
        if (currentRs != null) {
            currentRs.close();
            currentRs = null;
        }
    }

    /**
     * Executes an SQL statement that may return multiple results. Under some
     * (uncommon) situations a single SQL statement may return multiple result
     * sets and/or update counts. Normally you can ignore this unless you are
     * (1) executing a stored procedure that you know may return multiple
     * results or (2) you are dynamically executing an unknown SQL string. The
     * methods <code>execute</code>, <code>getMoreResults</code>,
     * <code>getResultSet</code>, and <code>getUpdateCount</code> let you
     * navigate through multiple results.
     * <p/>
     * The <code>execute</code> method executes an SQL statement and indicates
     * the form of the first result. You can then use the methods
     * <code>getResultSet</code> or <code>getUpdateCount</code> to retrieve the
     * result, and <code>getMoreResults</code> to move to any subsequent
     * result(s).
     *
     * @param sql
     *            any SQL statement
     * @return <code>true</code> if the next result is a <code>ResultSet</code>
     *         object; <code>false</code> if it is an update count or there are
     *         no more results
     * @throws SQLException
     *             if a database access error occurs
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     */
    public synchronized boolean execute(String sql) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.execute", new Object[] {this, sql});
        }

        checkConnectionOpen();

        if (batchStmts != null) {
            checkBatchStmtRemained();
            initBatchStmts();
        }

        initBeforeExecute();
        returnAutoGeneratedKeys = false;

        if (queryTimeout != 0)
            conn.getTimeout().setTimeout(queryTimeout * 1000, this);

        try {
            isExecuting = true;
            executeInternal(sql);
        }
        finally {
            isExecuting = false;

            if (queryTimeout != 0)
                conn.getTimeout().cancelTimeout();
        }
        
        return currentRs != null;
    }

    // #ifdef JDK1.4
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		if (autoGeneratedKeys == Statement.NO_GENERATED_KEYS) {
			return execute(sql);
		} else if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS) {
			TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_AUTO_GENERATED_KEY);
		}

		if (Debug.TRACE) {
			Debug.logMethod("TbStatement.execute", new Object[] { this, sql,
					Integer.toString(autoGeneratedKeys) });
		}

		checkConnectionOpen();

		if (batchStmts != null) {
			checkBatchStmtRemained();
			initBatchStmts();
		}

		initBeforeExecute();
		returnAutoGeneratedKeys = true;

		if (queryTimeout != 0)
			conn.getTimeout().setTimeout(queryTimeout * 1000, this);

		try {
			isExecuting = true;

			executeInternal(sql);
		}

		finally {
			isExecuting = false;

			if (queryTimeout != 0)
				conn.getTimeout().cancelTimeout();
		}

		return false;
	}
	// #endif

	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		if (columnIndexes == null || columnIndexes.length == 0) {
			TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_COLUMN_INDEX);
		}

		if (Debug.TRACE) {
			Debug.logMethod("TbStatement.execute", new Object[] { this, sql,
					columnIndexes });
		}

		checkConnectionOpen();

		if (batchStmts != null) {
			checkBatchStmtRemained();
			initBatchStmts();
		}

		initBeforeExecute();
		returnAutoGeneratedKeys = true;

		if (queryTimeout != 0)
			conn.getTimeout().setTimeout(queryTimeout * 1000, this);

		try {
			isExecuting = true;

			executeInternal(sql, columnIndexes);
		}

		finally {
			isExecuting = false;

			if (queryTimeout != 0)
				conn.getTimeout().cancelTimeout();
		}

		return false;
	}

	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		if (columnNames == null || columnNames.length == 0) {
			TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_COLUMN_NAME);
		}

		if (Debug.TRACE) {
			Debug.logMethod("TbStatement.execute", new Object[] { this, sql,
					columnNames });
		}

		checkConnectionOpen();

		if (batchStmts != null) {
			checkBatchStmtRemained();
			initBatchStmts();
		}

		initBeforeExecute();
		returnAutoGeneratedKeys = true;

		if (queryTimeout != 0)
			conn.getTimeout().setTimeout(queryTimeout * 1000, this);

		try {
			isExecuting = true;

			executeInternal(sql, columnNames);
		}

		finally {
			isExecuting = false;

			if (queryTimeout != 0)
				conn.getTimeout().cancelTimeout();
		}

		return false;
	}
    
    boolean isInsertStmt(String sql) {
    	if (sql != null) {
    		return sqlType == TbSQLTypeScanner.STMT_DML_INSERT;
    	}
    	return false;
    }

    public synchronized int[] executeBatch() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.executeBatch", new Object[] {this});
        }

        checkConnectionOpen();
        initBeforeExecute();

        if (batchStmts == null)
            return new int[0];

        int size = batchStmts.size();
        if (size <= 0)
            return new int[0];

        batchCounts = new int[size];
        int i = 0;

        try {
            if (queryTimeout != 0)
                conn.getTimeout().setTimeout(queryTimeout * 1000, this);

            isExecuting = true;

            for (i = 0; i < size; i++) {
                batchCounts[i] = executeInternal((String)batchStmts.get(i));

                if (currentRs != null)
                    throw TbError.newSQLException(TbError.MU_SELECT_BATCHUPDATE);
            }

            return batchCounts;
        }
        catch (SQLException e) {
            int newResultCount[] = new int[i];

            System.arraycopy(batchCounts, 0, newResultCount, 0, i);
            batchCounts = newResultCount;

            throw new BatchUpdateException(e.getMessage(), e.getSQLState(),
                                           e.getErrorCode(), batchCounts);
        }
        finally {
            isExecuting = false;

            if (queryTimeout != 0)
                conn.getTimeout().cancelTimeout();

            clearBatch();
        }
    }

    /**
     * execute sql
     *
     * @param sql
     *            sql statement to be excuted
     * @return TbResultSet result set
     * @throws SQLException
     *             connection
     */
    private synchronized int executeInternal(final String sql)
        throws SQLException {
    	return executeInternal(sql, null);
    }
    
    private synchronized int executeInternal(final String sql, Object keyArr)
			throws SQLException {
		if (Debug.TRACE || Debug.FAILOVER) {
		    String sqlForLog = sql == null ? "null" :
		        sql.length() <= 20 ? sql : sql.substring(0, 19);
		    Debug.logMethod("TbStatement.executeInternal",
                    new Object[] { this, conn, sqlForLog });
		}

        // SQL initialize
        initSql(sql);

		if (!isInsertStmt(sql)) {
			returnAutoGeneratedKeys = false;
		}

		int maxByteCount = conn.typeConverter.getMaxBytesPerChar();
		if (originalSql.length() > DriverConstants.MAX_FIELD_SIZE / maxByteCount) {
			ArrayList
			// #ifdef JDK1.5
			<BigLiteral>
			// #endif
			literal = new ArrayList
			// #ifdef JDK1.5
			<BigLiteral>
			// #endif
			();
			String nsql = TbSQLParser.getBigLiteral(originalSql, maxByteCount,
					literal);

			int count = literal.size();
			if (count > 0) {
				TbPreparedStatement pstmt = (TbPreparedStatement) conn
						.prepareStatement(nsql);

				for (int i = 0; i < count; i++) {
					BigLiteral bl = (BigLiteral) literal.get(i);
					pstmt.setString(i + 1, bl.getLiteralValue());
				}

				literal.clear();

				return pstmt.impl().executeInternal(nsql);
			}
		}

        if (TbSQLTypeScanner.isQueryStmt(sqlType)) {
            if (userRsetType.getType() == ResultSet.TYPE_SCROLL_SENSITIVE ||
                    userRsetType
                            .getConcurrency() == ResultSet.CONCUR_UPDATABLE) {
                sqlWithRowId = getQueryWithRowId(originalSql);

                try {
                    realRsetType = userRsetType;
                    synchronized (conn) {
                        return conn.getTbComm().executeDirect(this,
                                                              sqlWithRowId);
                    }
                }
                catch (SQLException se) {
                    // if cannot execute updatable select query, downgrade resetType
                    realRsetType = RsetType
                            .getDownGradedRsetType(userRsetType.getRank());
                    synchronized (conn) {
                        return conn.getTbComm().executeDirect(this,
                                                              originalSql);
                    }
                }
            }
            else {
                try {
                    realRsetType = userRsetType;
                    synchronized (conn) {
                        return conn.getTbComm().executeDirect(this, originalSql);
                    }
                }
                catch (SQLException e) {
                    // Failover CURSOR ��忡�� execute ������ failover�� �߻��� ���, ������Ѵ�.
                    if (conn.isClosed() ||
                            !conn.info.isFailoverCursorEnabled() ||
                            e.getErrorCode() != TbError.FO_RECONNECTED)
                        throw e;

                    if (Debug.TRACE || Debug.FAILOVER) {
                        Debug.log("Failover cursor: re-execute query " + this);
                    }
                    synchronized (conn) {
                        int ucnt = conn.getTbComm().executeDirect(this,
                                                                  originalSql);
                        addWarning(TbError.newSQLWarning(TbError.FO_RECONNECTED,
                                                         e));
                        return ucnt;
                    }
                }
            }
		} else if (TbSQLTypeScanner.isDMLStmt(sqlType)
				|| (!TbSQLTypeScanner.isQueryStmt(sqlType) && !TbSQLTypeScanner
						.isPSMStmt(sqlType))) {
			realRsetType = userRsetType;
			String autoGeneratedValuesSql = originalSql;
			if (this.returnAutoGeneratedKeys) {
				if (realRsetType.isSensitive() || realRsetType.isUpdatable()) {
					realRsetType = RsetType.SIRD;
				}

				if (keyArr == null)
					autoGeneratedValuesSql = getAutoGenSql(originalSql);
				else {
					if (keyArr instanceof int[]) {
						autoGeneratedValuesSql = getAutoGenSql(originalSql,
								(int[]) keyArr);
					} else if (keyArr instanceof String[]) {
						autoGeneratedValuesSql = getAutoGenSql(originalSql,
								(String[]) keyArr);
					}
				}
			}
			
			synchronized (conn) {
			    rowsUpdated = conn.getTbComm().executeDirect(this,
			            autoGeneratedValuesSql);
			}

			return rowsUpdated;
		} else {
			realRsetType = userRsetType;
			synchronized (conn) {
			    return conn.getTbComm().executeDirect(this, originalSql);
			}
		}
	}
    
	protected String getAutoGenSql(String originalSql) {
		StringBuffer sb = new StringBuffer();
		sb.append(originalSql).append(" RETURNING ROWID INTO GENKEY0");
		return sb.toString();
	}
    
	protected String getAutoGenSql(String originalSql, String[] colNames) {
		StringBuffer sb = new StringBuffer();
		sb.append(originalSql).append(" RETURNING ");

		int colCnt = colNames.length;
		for (int i = 0; i < colCnt; i++) {
			if (i > 0) {
				sb.append(", ");
			}
			sb.append(colNames[i]);
		}
		sb.append(" INTO ");
		for (int i = 0; i < colCnt; i++) {
			if (i > 0) {
				sb.append(", ");
			}
			sb.append("GENKEY").append(i);
		}
		return sb.toString();
	}
    
    protected String getAutoGenSql(String originalSql, int[] colIndexes)
			throws SQLException {
		StringBuffer sb = new StringBuffer();
		sb.append(originalSql).append(" RETURNING ");

		int colCnt;

		colCnt = colIndexes.length;

		int intoIndex = originalSql.toUpperCase().indexOf("INTO",
				sqlTypeScanner.getCurrentIndex());
		if (intoIndex < 0)
			TbError.newSQLException(TbError.MU_INVALID_PARAMETER);
		int sqlLen = originalSql.length();
		int beginIndex;
		for (beginIndex = intoIndex + 5; beginIndex < sqlLen
				&& originalSql.charAt(beginIndex) == ' '; beginIndex++)
			;
		if (beginIndex >= sqlLen) {
			TbError.newSQLException(TbError.MU_INVALID_PARAMETER);
		}
		int endIndex;
		for (endIndex = beginIndex + 1; endIndex < sqlLen
				&& originalSql.charAt(endIndex) != ' '
				&& originalSql.charAt(endIndex) != '('; endIndex++)
			;
		String tableName = originalSql.substring(beginIndex, endIndex);

		Statement tempstmt = null;
		try {
			tempstmt = conn.createStatement();
			ResultSet temprs = tempstmt.executeQuery("SELECT * FROM "
					+ tableName);
			ResultSetMetaData temprsmd = temprs.getMetaData();

			int rsColCnt = temprsmd.getColumnCount();
			for (int i = 0; i < colCnt; i++) {
				if (colIndexes[i] < 1 || colIndexes[i] > rsColCnt) {
					TbError.newSQLException(TbError.MU_INVALID_PARAMETER);
				}
				if (i > 0) {
					sb.append(", ");
				}
				sb.append(temprsmd.getColumnName(colIndexes[i]));
			}
			sb.append(" INTO ");
			for (int i = 0; i < colCnt; i++) {
				if (i > 0) {
					sb.append(", ");
				}
				sb.append("GENKEY").append(i);
			}
			return sb.toString();
		} finally {
			if (tempstmt != null) {
				try {
					tempstmt.close();
				} catch (Exception ignore) {
				}
			}
		}
	}
    
    /**
     * Executes an SQL statement that returns a single <code>ResultSet</code>
     * object.
     *
     * @param sql
     *            typically this is a static SQL <code>SELECT</code> statement
     * @return a <code>ResultSet</code> object that contains the data produced
     *         by the given query; never <code>null</code>
     * @exception SQLException
     *                if a database access error occurs
     */
    public synchronized ResultSet executeQuery(String sql) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.executeQuery",
                            new Object[] {this, sql});
        }

        checkConnectionOpen();

        if (batchStmts != null) {
            checkBatchStmtRemained();
            initBatchStmts();
        }

        initBeforeExecute();

        if (queryTimeout > 0)
            conn.getTimeout().setTimeout(queryTimeout * 1000, this);

        try {
            isExecuting = true;
            executeInternal(sql);
        }
        finally {
            isExecuting = false;

            if (queryTimeout > 0)
                conn.getTimeout().cancelTimeout();
        }
        
        if (currentRs == null) {
            currentRs = TbResultSetFactory.buildResultSet(this,
                                                          TbResultSetBase.EMPTY_CURSOR_ID,
                                                          0, 0, null);
        }

        return currentRs;
    }

    /**
     * Executes an DDL SQL statement
     *
     * @param sql
     *            INSERT, UPDATE, DELETE statement or an SQL statement that
     *            returns nothing
     * @return the row count for INSERT, UPDATE, DELETE or 0 for SQL statements
     *         that return nothing
     * @throws SQLException
     *             query
     */
    public synchronized int executeUpdate(String sql) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.executeUpdate", new Object[] {this,
                                                                       sql});
        }

        checkConnectionOpen();

        if (batchStmts != null) {
            checkBatchStmtRemained();
            initBatchStmts();
        }

        initBeforeExecute();
        returnAutoGeneratedKeys = false;

        if (queryTimeout != 0)
            conn.getTimeout().setTimeout(queryTimeout * 1000, this);

        try {
            isExecuting = true;

            return executeInternal(sql);
        }
        finally {
            isExecuting = false;

            if (queryTimeout != 0)
                conn.getTimeout().cancelTimeout();
        }
    }

    // #ifdef JDK1.4
    public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		if (autoGeneratedKeys == Statement.NO_GENERATED_KEYS) {
			return executeUpdate(sql);
		} else if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS) {
			TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_AUTO_GENERATED_KEY);
		}

		if (Debug.TRACE) {
			Debug.logMethod("TbStatement.executeUpdate", new Object[] { this,
					sql });
		}

		checkConnectionOpen();

		if (batchStmts != null) {
			checkBatchStmtRemained();
			initBatchStmts();
		}

		initBeforeExecute();
		this.returnAutoGeneratedKeys = true;

		if (queryTimeout != 0)
			conn.getTimeout().setTimeout(queryTimeout * 1000, this);

		try {
			isExecuting = true;

			return executeInternal(sql);
		} finally {
			isExecuting = false;

			if (queryTimeout != 0)
				conn.getTimeout().cancelTimeout();
		}
	}
    // #endif

    public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		if (columnIndexes == null || columnIndexes.length == 0) {
			TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_COLUMN_INDEX);
		}

		if (Debug.TRACE) {
			Debug.logMethod("TbStatement.executeUpdate", new Object[] { this,
					sql });
		}

		checkConnectionOpen();

		if (batchStmts != null) {
			checkBatchStmtRemained();
			initBatchStmts();
		}

		initBeforeExecute();
		this.returnAutoGeneratedKeys = true;

		if (queryTimeout != 0)
			conn.getTimeout().setTimeout(queryTimeout * 1000, this);

		try {
			isExecuting = true;

			return executeInternal(sql, columnIndexes);
		} finally {
			isExecuting = false;

			if (queryTimeout != 0)
				conn.getTimeout().cancelTimeout();
		}
	}

    public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		if (columnNames == null || columnNames.length == 0) {
			TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_COLUMN_INDEX);
		}

		if (Debug.TRACE) {
			Debug.logMethod("TbStatement.executeUpdate", new Object[] { this,
					sql });
		}

		checkConnectionOpen();

		if (batchStmts != null) {
			checkBatchStmtRemained();
			initBatchStmts();
		}

		initBeforeExecute();
		this.returnAutoGeneratedKeys = true;

		if (queryTimeout != 0)
			conn.getTimeout().setTimeout(queryTimeout * 1000, this);

		try {
			isExecuting = true;

			return executeInternal(sql, columnNames);
		} finally {
			isExecuting = false;

			if (queryTimeout != 0)
				conn.getTimeout().cancelTimeout();
		}
	}

    /**
     * fetch row data from server
     *
     * @param rs
     *            result set will be fetched
     * @return Row[] row data array
     * @throws SQLException
     */
    public synchronized void fetch(TbResultSetBase rs) throws SQLException {
        synchronized (conn) {
            conn.getTbComm().fetch(this, rs);
        }
    }

    public Connection getConnection() throws SQLException {
        checkConnectionOpen();

        return conn;
    }

    public int getCurCsrId() {
        return curCsrId;
    }

    public int getFetchDirection() throws SQLException {
        return fetchDirection;
    }

    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    public ResultSet getGeneratedKeys() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("getGeneratedKeys",
                    new Object[] { this, currentRs });
        }
        if (this.returnAutoGeneratedKeys) {
            return currentRs;
        } else {
            throw TbError.newSQLException(TbError.MU_JDBC_SPEC);
        }
    }

    /**
     * Returns the maximum number of bytes allowed for any column value.
     * (BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, LONGVARCHAR)
     *
     * @return the current max column size limit; zero means unlimited
     * @throws SQLException
     *             if a database access error occurs
     */
    public int getMaxFieldSize() throws SQLException {
        return maxFieldSize;
    }

    /**
     * Retrieves the maximum number of rows that a ResultSet object can contain.
     *
     * @return the current max row limit; zero means unlimited
     * @throws SQLException
     *             if a database access error occurs
     */
    public int getMaxRows() throws SQLException {
        return maxRow;
    }

    /**
     * Moves to a <code>Statement</code> object's next result. It returns
     * <code>true</code> if this result is a <code>ResultSet</code> object. This
     * method also implicitly closes any current <code>ResultSet</code> object
     * obtained with the method <code>getResultSet</code>.
     * <p/>
     * <P>
     * There are no more results when the following is true:
     *
     * <PRE>
     * &lt;code&gt;
     * (!getMoreResults() &amp;&amp; (getUpdateCount() == -1)
     * &lt;/code&gt;
     * </PRE>
     *
     * @return <code>true</code> if the next result is a <code>ResultSet</code>
     *         object; <code>false</code> if it is an update count or there are
     *         no more results
     * @throws SQLException
     *             if a database access error occurs
     * @see #execute
     */
    public synchronized boolean getMoreResults() throws SQLException {
        return false;
    }

    public boolean getMoreResults(int current) throws SQLException {
        throw TbError.newSQLException(TbError.UNSUPPORTED_OPERATION);
    }

    public String getOriginalSql() {
        return originalSql;
    }

    protected void initSql(String userSql) throws SQLException {
        // process original SQL statement..
        // check invalid sql string
        if (userSql == null || userSql.length() <= 0)
            throw TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_EMPTY_SQL);

        String returnSql = null;
        if (conn.serverInfo.getServerCharSet() == Charset.UTF_8) {
            returnSql = TbSQLParser.replaceIDEOGraphicSpace(userSql);
        } else {
            returnSql = userSql;
        }

        // check sqlType : SELECT_DML, UPDATE_DML ....
        sqlTypeScanner = new TbSQLTypeScanner();
        returnSql = sqlTypeScanner.callDeclareSyntax(returnSql); //IMS-145831 {call declare ~} parsing

        sqlType = sqlTypeScanner.getSQLType(returnSql);

        if (TbSQLTypeScanner.STMT_DDL_JAVA_SRC != sqlType) {
            // process EscapeSyntax
            if (enableEscapeProcessing) {
                if (returnSql.indexOf('{') >= 0)
                    returnSql = sqlParser.parse(returnSql);
            }

            if (returnSql.indexOf('?') > 0)
                returnSql = TbSQLParser.replace(returnSql);
        }

        originalSql = returnSql;
    }

    public Vector
            // #ifdef JDK1.5
            <byte[]>
            // #endif
                getPivotData() {
        return pivotData;
    }

    public TbPivotInfo[] getPivotInfo() {
        return pivotInfo;
    }

    public int getPreFetchSize() {
        if (TbSQLTypeScanner.isQueryStmt(getSqlType()) &&
            getRealRsetType().getType() != ResultSet.TYPE_SCROLL_SENSITIVE)
            return preFetchSize;
        else
            return 0;
    }

    /**
     * Retrieves the number of seconds the driver will wait for executing.
     *
     * @return the current query timeout limit in seconds; zero means unlimited
     * @throws SQLException
     *             if a database access error occurs
     */
    public int getQueryTimeout() throws SQLException {
        return queryTimeout;
    }

    protected String getQueryWithRowId(String sql) {
        StringBuffer sqlBuffer = new StringBuffer(100);

        String upperSql = sql.toUpperCase();
        int index1 = upperSql.lastIndexOf("FOR");
        int index2 = upperSql.lastIndexOf("UPDATE");

        if (upperSql.lastIndexOf("\"") < index1 && index1 < index2) {
            sqlBuffer.append(sql).append(") ROWID_ALIAS0");
            sqlBuffer.delete(index1, index1 + 3);
            sqlBuffer.delete(index2 - 3, index2 + 3);
            sqlBuffer.insert(0,"select ROWIDTOCHAR(ROWID) _ROWID_CHAR0_, ROWID_ALIAS0.* from (");
            sqlBuffer.append(" FOR UPDATE");
        } else {
            sqlBuffer.append("select ROWIDTOCHAR(ROWID) _ROWID_CHAR0_, ROWID_ALIAS0.* from (").
                    append(sql).append(") ROWID_ALIAS0");
        }

        return sqlBuffer.toString();
    }

    public RsetType getUserRsetType() {
        return userRsetType;
    }
    
    public RsetType getRealRsetType() {
        return realRsetType;
    }

    /**
     * Returns the current result as a <code>ResultSet</code> object. This
     * method should be called only once per result.
     *
     * @return the current result as a <code>ResultSet</code> object;
     *         <code>null</code> if the result is an update count or there are
     *         no more results
     * @throws SQLException
     *             if a database access error occurs
     * @see #execute
     */
    public ResultSet getResultSet() throws SQLException {
    	if (this.returnAutoGeneratedKeys) {
    		return null;
    	}
    	else {
    		return currentRs;
    	}
    }

    public int getResultSetConcurrency() throws SQLException {
        return userRsetType.getConcurrency();
    }

    public int getResultSetHoldability() throws SQLException {
        return userRsetType.getHoldability();
    }

    public int getResultSetType() throws SQLException {
        return userRsetType.getType();
    }

    public int getSqlType() {
        return sqlType;
    }

    public String getSqlWithRowId() {
        return sqlWithRowId;
    }

    /**
     * Returns the current result as an update count; if the result is a
     * <code>ResultSet</code> object or there are no more results, -1 is
     * returned. This method should be called only once per result.
     *
     * @return the current result as an update count; -1 if the current result
     *         is a <code>ResultSet</code> object or there are no more results
     * @throws SQLException
     *             if a database access error occurs
     * @see #execute
     */
    public int getUpdateCount() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.getUpdateCount", new Object[] {this});
        }

        if (batchCounts != null) {
            int updateCount = 0;

            for (int i = 0; i < batchCounts.length; i++) {
                updateCount += batchCounts[i];
            }

            return updateCount;
        }
        else {
            if (!noMoreUpdateCount) {
                noMoreUpdateCount = true;

                return rowsUpdated;
            }

            return -1;
        }
    }

    /**
     * Retrieves the first warning reported by calls on this
     * <code>Statement</code> object. Subsequent <code>Statement</code> object
     * warnings will be chained to this <code>SQLWarning</code> object.
     * <p/>
     * <p>
     * The warning chain is automatically cleared each time a statement is
     * (re)executed.
     * <p/>
     * <P>
     * <B>Note:</B> If you are processing a <code>ResultSet</code> object, any
     * warnings associated with reads on that <code>ResultSet</code> object will
     * be chained on it.
     *
     * @return the first <code>SQLWarning</code> object or <code>null</code>
     * @throws SQLException
     *             if a database access error occurs
     */
    public SQLWarning getWarnings() throws SQLException {
        return warnings;
    }

    protected void initBatchStmts() {
        if (batchStmts != null) {
            batchStmts.clear();
            batchStmts = null;
        }
    }

    /**
     * before executing a sql, close all result set and clear batch statement
     * list
     *
     * @throws SQLException
     */
    protected void initBeforeExecute() throws SQLException {
        batchCounts = null;
        rowsUpdated = -1;
        noMoreUpdateCount = false;

        // close prev resultset. if don't close, many cursors exist in server.
        if (currentRs != null) {
            currentRs.close();
            currentRs = null;
        }
    }

    public boolean isClosed() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.isClosed", new Object[] {this});
        }
        return closed;
    }

    public boolean isPoolable() throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.isPoolable", new Object[] {this});
        }
        
        if (isClosed())
            throw TbError.newSQLException(TbError.MU_ACTION_ON_CLOSED_STATEMENT);
        
        return poolable;
    }

    // #ifdef JDK1.6
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.isWrapperFor", new Object[] {iface});
        }

        return iface.isInstance(this);
    }
    // #endif

    protected void reset() {
        closed = true;
        warnings = null;
        conn = null;
        typeConverter = null;
        userRsetType = null;
        noMoreUpdateCount = false;
        returnAutoGeneratedKeys = false;
        currentRs = null;
        batchCounts = null;
        maxRow = 0;
        rsetTypeDowngraded = false;
        subResultSets.removeAll(subResultSets);

        if (batchStmts != null) {
            batchStmts.clear();
            batchStmts = null;
        }
    }

    public void resetForCache() {
        currentRs = null;
        batchCounts = null;
        warnings = null;
        subResultSets.removeAll(subResultSets);

        if (batchStmts != null) {
            batchStmts.clear();
            batchStmts = null;
        }
    }

    public void setCurCsrId(int csrId) {
        curCsrId = csrId;
    }

    /**
     * Defines the SQL cursor name that will be used by subsequent
     * <code>Statement</code> object <code>execute</code> methods. This name can
     * then be used in SQL positioned update/delete statements to identify the
     * current row in the <code>ResultSet</code> object generated by this
     * statement. If the database doesn't support positioned update/delete, this
     * method is a noop. To insure that a cursor has the proper isolation level
     * to support updates, the cursor's <code>SELECT</code> statement should be
     * of the form 'select for update ...'. If the 'for update' phrase is
     * omitted, positioned updates may fail.
     * <p/>
     * <P>
     * <B>Note:</B> By definition, positioned update/delete execution must be
     * done by a different <code>Statement</code> object than the one which
     * generated the <code>ResultSet</code> object being used for positioning.
     * Also, cursor names must be unique within a connection.
     *
     * @param name
     *            the new cursor name, which must be unique within a connection
     * @throws SQLException
     *             if a database access error occurs
     */
    public void setCursorName(String name) throws SQLException {
        //throw TbError.newSQLException(TbError.UNSUPPORTED_OPERATION);
    }

    /**
     * Sets escape processing on or off.
     *
     * @param enable
     * @throws SQLException
     *             if a database access error occurs
     */
    public synchronized void setEscapeProcessing(boolean enable)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setEscapeProcessing",
                            new Object[] {this, new Boolean(enable)});
        }

        enableEscapeProcessing = enable;
    }

    /**
     * Gives the driver a hint as to the direction in which the rows in a result
     * set will be processed. The hint applies only to result sets created using
     * this <code>Statement</code> object. The default value is
     * <code>ResultSet.FETCH_FORWARD</code>.
     * <p>
     * Note that this method sets the default fetch direction for result sets
     * generated by this <code>Statement</code> object. Each result set has its
     * own methods for getting and setting its own fetch direction.
     *
     * @param direction
     *            the initial direction for processing rows
     * @throws SQLException
     *             if a database access error occurs or the given direction is
     *             not one of <code>ResultSet.FETCH_FORWARD</code>,
     *             <code>ResultSet.FETCH_REVERSE</code>, or
     *             <code>ResultSet.FETCH_UNKNOWN</code>
     * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0
     *      API</a>
     * @since 1.2
     */
    public synchronized void setFetchDirection(int direction)
        throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setFethDirection",
                            new Object[] {this, Integer.toString(direction)});
        }

        switch (direction) {
        case ResultSet.FETCH_FORWARD:
        case ResultSet.FETCH_UNKNOWN:
            fetchDirection = ResultSet.FETCH_FORWARD;
            return;

        case ResultSet.FETCH_REVERSE:
            fetchDirection = ResultSet.FETCH_REVERSE;

        default:
            throw TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_FETCH_DIRECTION);
        }
    }

    /**
     * Gives the JDBC driver a hint as to the number of rows that should be
     * fetched from the database when more rows are needed. The number of rows
     * specified affects only result sets created using this statement. If the
     * value specified is zero, then the hint is ignored. The default value is
     * zero.
     *
     * @param rows
     *            the number of rows to fetch
     * @throws SQLException
     *             if a database access error occurs, or the condition 0 <= rows
     *             <= this.getMaxRows() is not satisfied.
     * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0
     *      API</a>
     * @since 1.2
     */
    public synchronized void setFetchSize(int rows) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setFetchSize",
                            new Object[] {this, Integer.toString(rows)});
        }

        if (rows == 0)
            fetchSize = DriverConstants.FETCH_SIZE;
        else if (rows > 0)
            fetchSize = rows;
        else
            throw TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_FETCH_SIZE);
    }
    
    public synchronized void setPreparedFetchSize(int size) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setPreparedFetchSize",
                            new Object[] {this, Integer.toString(size)});
        }

        if (size == 0)
            fetchSize = DriverConstants.FETCH_SIZE;
        else if (size > 0)
            fetchSize = size > 64 ? -64 : size * (-1);
        else
            throw TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_FETCH_SIZE);
    }

    /**
     * Sets the limit for the maximum number of bytes in a column to the given
     * number of bytes.
     *
     * @param max
     *            the new max column size limit; zero means unlimited
     * @throws SQLException
     *             if a database access error occurs
     */
    public void setMaxFieldSize(int max) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setMaxFieldSize",
                            new Object[] {this, Integer.toString(max)});
        }

        if (max < 0)
            throw TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_MAX_COLUMN_SIZE);

        maxFieldSize = max;
    }

    public synchronized void setMaxRows(int max) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setMaxRows",
                            new Object[] {this, Integer.toString(max)});
        }

        if (max < 0)
            throw TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_MAX_ROW_SIZE);

        maxRow = max;
    }

    public void setPivotInfo(TbPivotInfo[] info) {
        pivotInfo = info;
    }

    public void setPoolable(boolean poolable) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setPoolable", 
                            new Object[] {this,
                                          Boolean.toString(poolable)});
        }
        
        this.poolable = poolable;
    }

    /**
     * Sets the number of seconds the driver will wait for executing.
     *
     * @param seconds
     *            the new query timeout limit in seconds; zero means unlimited
     * @throws SQLException
     *             if a database access error occurs
     */
    public synchronized void setQueryTimeout(int seconds) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setQueryTimeout",
                            new Object[] {this, Integer.toString(seconds)});
        }

        if (seconds < 0)
            throw TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_TIMEOUT);

        queryTimeout = seconds;
    }

    public void setResultSet(TbResultSet rs1) {
        currentRs = rs1;
    }
    
    public void addSubResultSet(TbResultSet subRs) {
        subResultSets.add(subRs);
    }

    public synchronized void setRowPreFetch(int fetchSize) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.setFetchSize",
                            new Object[] {this, Integer.toString(fetchSize)});
        }

        if (fetchSize < 0)
            throw TbError.newSQLException(TbError.INTERNAL_MU_INVALID_PARAMETER_FETCH_SIZE);

        preFetchSize = fetchSize;

        if (fetchSize == 0)
            setFetchSize(DriverConstants.FETCH_SIZE);
        else
            setFetchSize(fetchSize);
    }

    // #ifdef JDK1.6
    public <T> T unwrap(Class<T> iface) throws SQLException {
        if (Debug.TRACE) {
            Debug.logMethod("TbStatement.unwrap", new Object[] {iface});
        }

        try {
            return iface.cast(this);
        }
        catch (ClassCastException e) {
            throw TbError.newSQLException(TbError.MU_FAILED_TO_CAST);
        }
    }
    // #endif

    boolean isReturnAutoGeneratedKeys() {
        return returnAutoGeneratedKeys;
    }

    protected void setReturnAutoGeneratedKeys(boolean returnAutoGeneratedKeys) {
        if (Debug.TRACE) {
            Debug.logMethod("setReturnAutoGeneratedKeys",
                    new Object[] { String.valueOf(returnAutoGeneratedKeys) });
        }
        this.returnAutoGeneratedKeys = returnAutoGeneratedKeys;
    }
}
